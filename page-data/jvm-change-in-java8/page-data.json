{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/jvm-change-in-java8/",
    "result": {"data":{"cur":{"id":"970ad7e7-c529-5911-b5d5-ca08c1dcb821","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAADJElEQVQozwEZA+b8AImBY7OpjtvTu9vUwMG5o+jn4Pz89vn58vv58Pj25/z77vDgz7Gkg3d7X7CZiP/Ut+69oJySh4WCfDcwKQCXjGnFwqvz8OHVz7zEvavk5Nv8/fb6+u76+O369+fd1MHItqCnooeBfWihkH+xln+yln6elIaHf3VfVkUAiIFjubag5uLQ0su6xsGyv7Wi8e7d5ubW9vPkzMGvl29TkG9crqOScmdXgXVfqpp+mYtwlYZtinpjdWtYAIGAaYeHd6CWgtjWy7CYgdirkamKbuXexPPs2rKjkK95YMmJa66cioV2W66ijOLPs6WYhJeVhJCPez45LgB8emNtb12km4nRzL+ecVjcoouUY0q8rJb79uS7sqqzl4udgXigrsOblIbGvKjmxayGYk9WRS69tp5WVU0Agn1oX19RoJuNraOVkl5G15Z/nWZNlXxrwKulsZ+ZqpyXnaCpn6q+hpSuyc3IuZV7q3ZXXkElnW5BTEU9ALGYfX5yYcaoj4R0X0QoFsuCXlw2IU85J9awocW4tp+ZnKGiqLCxs4CImr2+v3JbRJBoSdi7n5CEYqCbfwDHuKnDq5ffzr+gal16QSfDjWarfWJ/OCvy2tTX19O/v8GIjJSiprKoqrGppKGnloOxm4nOtKGawKzM0KoAtpJ4npmK2aKb/TtJ50dL4Vtc82Jl/jdG9Y6H///5sbTAOUZee2FXqYd+bW5/vLKrvbSwp6eop6qqdnR5AM69qZ6UfsBsUOBSWcPAwsenq7+Rl+pKU+SLafrz6KOpuT5KYqF3YJWAfnBrd6ymob+MbI+Tkc3V3J2eqQD1+POUiG6fWTjyMTn0NEbzNkf1PU34PEPYiGHu3tF5g5ZeZn6gdmJsbn+IjJ/dwbCuinGMq7na29jP0dQA5+jhxMa9rXVYyQ0J5wAF6wEK7QAM3BEW2o9pzMG7ZXOQfYGVmHdrZXaUmpmpuI50jJ6nttfm6+3p9fLsAOjo5erm3sGOcsxGQOIAB+cEDt4AAcYSDNyeeqSjqlBZbGFSUpl0bmBuioeEkHt2fE5kioukuuDm6f///vOR1ytpahhqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"meme\"\n        title=\"meme\"\n        src=\"/static/2117ef67cec6809a66915464c50776bd/37523/meme.png\"\n        srcset=\"/static/2117ef67cec6809a66915464c50776bd/e9ff0/meme.png 180w,\n/static/2117ef67cec6809a66915464c50776bd/f21e7/meme.png 360w,\n/static/2117ef67cec6809a66915464c50776bd/37523/meme.png 720w,\n/static/2117ef67cec6809a66915464c50776bd/1d69c/meme.png 750w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"java-7의-jvm\" style=\"position:relative;\"><a href=\"#java-7%EC%9D%98-jvm\" aria-label=\"java 7의 jvm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Java 7의 JVM</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.111111111111107%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABfElEQVQY0y2OPUsbAQBA8zfEtaMQsZIOKgaswY8Qo0bp4FAnEeng1k5SxMmlfgx+UyQfkkrd7FAbmsRGPNIKiTTJ3eVMzhg/yJlE8ZJyxidKhwfvbc+Uv7gklpSRszkS6QzBA4EfoV/EEiJSJkfqRGX/MEogFCF0ILAXjhAMhUnHY5xGwmTDP8kGA2T+RMlIIib/oYp1I4XLK+PcUuj3ygz40nTNC/S6JVy7BZwe6bn73CKOPZ2Ps16ObWYK48OcjjqID7/mamwQfX4ak084o3lV5NVSAsuahGU5iXnxL/XvA7Ssp3j5tYh5RaFpahvrwjfadkQmPywQb6pDe2tHaX3BkbUBbdTO/dQ7TNu/87R/lnF6ZBy+E+xuGYcnjW1OoHtTZPBLFpdfpXNOoHczSc93nZlPfhK2RgpjLnIjXRwPdaBNvMF4OqwaNUqVe8rV/zx5xaBUrVG+vqHo2UJR80jqOUrugqvbKnrlH0bpmtpN+RmjqFErajzodzwCEIszbXlPJeoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/51f2865401bf42f831eebc6e076cd1cf/37523/jvm7.png\"\n        srcset=\"/static/51f2865401bf42f831eebc6e076cd1cf/e9ff0/jvm7.png 180w,\n/static/51f2865401bf42f831eebc6e076cd1cf/f21e7/jvm7.png 360w,\n/static/51f2865401bf42f831eebc6e076cd1cf/37523/jvm7.png 720w,\n/static/51f2865401bf42f831eebc6e076cd1cf/6c2f2/jvm7.png 767w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n기존의 Java 7 까지의 Non Heap Area였던 Permanent Generation이 Native 영역인 Metaspace로 바뀌었다.</p>\n<p>기존의 Permanent 영역에는 아래와 같은 정보들이 저장되었다.</p>\n<ul>\n<li><strong>Class의 메타데이터 (바이트코드 포함)</strong></li>\n<li>Method의 메타데이터</li>\n<li><strong>static 객체, static 상수</strong></li>\n<li><strong>상수화된 String Object</strong></li>\n<li>Class와 관련된 배열 객체 메타데이터</li>\n<li>JVM 내부적인 객체들과 JIT의 최적화 정보</li>\n</ul>\n<h3 id=\"oom-문제점\" style=\"position:relative;\"><a href=\"#oom-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"oom 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OOM 문제점</h3>\n<p>이런 많은것들이 PermG안에 있다보니 , String Constant Pool, static object, Class 메타 데이터들이 쌓여 OOM이 발생하곤 했다. PermG는 시작할때부터 크게 잡지 않는 이상 리사이징이 되지 않아 그런 문제가 발생하곤 했다. <a href=\"https://goodgid.github.io/Java-8-JVM-Metaspace/\">좋은 글</a></p>\n<h2 id=\"java-8의-jvm\" style=\"position:relative;\"><a href=\"#java-8%EC%9D%98-jvm\" aria-label=\"java 8의 jvm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Java 8의 JVM</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiElEQVQY0xXFT2hSAQDA4XfquFuHOi1ownITIUi2CTtFh9aldqmIEMnw0laHBh46hCyCDo6IFtSYjFJnBKNLRAddysRZ6bbH5mZP36IYOn2+9/Z8zn+/0Xf5hKZep9tQodXAqJUpiDlKuyJdU4Njg46uUKlVUdodtG4P1WyiFSX0fZn6/80mBqC0OigNE2EmlMa9LOINZfFGNvCEc9wLpnEvrOGJbuH58oePgXmqTx7wz++jPOtja8pF2j1J6fF9xIduMt7b7E27OAgtINz9kGf0/V9G3mwz8u4340sy1hdZLP4UzqCE9XObiG+W9rV+KpN21Bt2xItn2RgbQL9zBcl5HnHCgea6Cq+fIdxc3MSxWGQokGP41Ta2+TyDzzNYniZxvM1jWzGZ8zxCHD7Fj9Ez/Lx0mqSlj6zjHLVbl9l1DvBr/AKH18dov/QjrMsqMdnge1EjIR+R2D8iIanE92rESzrJSg8plaESXmInGqHwaRlpJYoS+0orvYqRilNf/cZxKkZPLnACNfgunqfsHK0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/bb5245914008655bff34d9e7e26c4ef6/37523/jvm8.png\"\n        srcset=\"/static/bb5245914008655bff34d9e7e26c4ef6/e9ff0/jvm8.png 180w,\n/static/bb5245914008655bff34d9e7e26c4ef6/f21e7/jvm8.png 360w,\n/static/bb5245914008655bff34d9e7e26c4ef6/37523/jvm8.png 720w,\n/static/bb5245914008655bff34d9e7e26c4ef6/c8e86/jvm8.png 758w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\nJava 8에서부턴 PermG 영역을 삭제하고 <strong>Metaspace</strong> 영역을 추가해 <strong>Native 메모리의 영역</strong>으로 이동시켰다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 398px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQY01WR6U7CQBRG+5QaiZFn8QcuzyEhLvAILggxcUmUVoEAVRHsAqUVCAXtzBzTAY3+OLknmck3d+41QAFyxV+XSAmeH/D5JbQnYomQ/1FKIaXS1cjfC7bPFbuXityFYKesyJVhr6K47r7R9js0PJumb9MavmhSb3o2dbeNPejrx9JWEqEw9iuwXojJHsdkS4KNgxEb+YitQshZu0lzUMNyLcz3B64aVar1ivYnz6Lm3NMJnlnMF3i+R5IkGGlna4cJW8WEzaIgczgnc7QgezLXgQ3/AdMxMZ0ady833L3ean90TR3YGthIIZnFM6SUGKcdQaGmKNXRFOtwZClOLEnDG9CPHLojl17k4U4D3MmQXujyFrp0Rw5OFCBWc/1KFMby94LZ9INxNGI2iX4XpCR6PumVOF4wDCLCcKwDlFqepTVdxg/fWoS2MAIE3uAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/0201f2a4812c06c34fcf9d31f598e0f4/692d4/jvm8_area.png\"\n        srcset=\"/static/0201f2a4812c06c34fcf9d31f598e0f4/e9ff0/jvm8_area.png 180w,\n/static/0201f2a4812c06c34fcf9d31f598e0f4/f21e7/jvm8_area.png 360w,\n/static/0201f2a4812c06c34fcf9d31f598e0f4/692d4/jvm8_area.png 398w\"\n        sizes=\"(max-width: 398px) 100vw, 398px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"구체적인-변경점\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%EB%B3%80%EA%B2%BD%EC%A0%90\" aria-label=\"구체적인 변경점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구체적인 변경점</h3>\n<p>기존의 PermG 영역에 있던 정보들은 이렇게 변경되었다.</p>\n<ul>\n<li>Class의 메타데이터 (바이트코드 포함) → MetaSpace로 이동</li>\n<li>Method의 메타데이터 → MetaSpace로 이동</li>\n<li>static 객체,static 변수 (class variable) → <strong>Heap으로 이동,</strong></li>\n<li>상수화된 String Object → <strong>Heap으로 이동</strong></li>\n<li>Class와 관련된 배열 객체 메타데이터 → Metaspace로 이동</li>\n<li>JVM 내부적인 객체들과 JIT의 최적화 정보 → Metaspace로 이동</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 631px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACFUlEQVQozz2QSW8TQRCF57chEUggYCRuQXAAEZMQHHEhiAST4CAOQJByR+I/ES+zuWfrGXvGs2c8i52HuuT48NTV9XVVVz1pb+sUndY5Oo97ePeoh06rR7HIfXp+gfdPv+Ng+ysOn5wTF7E4j3Z+4Gjn5/ou+lwe/4X06s4xdjc+4/XdE7TvdfH24Rl2N05wsN1D9+UlDlvf6PGbzS7a979gf+uMdPziNz4++4W9zVPsPzhDe6OLiw9/IHHXgcNt2I6JvMiwWNQQubKao24qNIsaN1jADyaIkxA3WKJZ1qjrivhi2ZCWNw2KIoc06A+gqipkWYaiKAgCH5qmIQgCJHGMKIoQxzEMxsAdB1mWUT5JEsRRRPxWsyCAJIrHug7GGCzLwnQ6oTgMQ6RpSoVZmsK2rDWfTibwfR9pkhBPV4rCGSTxs65p0DQVlmnCMg2YpoE8z1GVJebzOcpyDu7YNLmqKDAMBtu2UZYlsds3WZpAGg2HUGSZ1sqzjNYQ649GIwh2dfWPYvGhLI/IHkWRoaoKsX6/j8FggOFwCIONIcUrj9I0WfvDOYfjrMQ5oiiE53mwLJtytu2QXNdFFIYIwxlZRB6OGSPPiqJAXdc0uudNoY8N6GMGZlrkZTCbQdMZdGasmAHTcpDn12iahnSd55CEV2Iy4UdVVdTY9wM43F3JA+cegmAG7nqwaWpvLdebrmuzLMV/OK2xFYhJGpwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/b3af97e1eb3705e13c4c5454c9a8e632/4597d/diff.png\"\n        srcset=\"/static/b3af97e1eb3705e13c4c5454c9a8e632/e9ff0/diff.png 180w,\n/static/b3af97e1eb3705e13c4c5454c9a8e632/f21e7/diff.png 360w,\n/static/b3af97e1eb3705e13c4c5454c9a8e632/4597d/diff.png 631w\"\n        sizes=\"(max-width: 631px) 100vw, 631px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위와 같이 변경하면서 , 기존 PermG에 있던 Static Object가 Heap 영역으로 옮겨져서 GC의 대상이 될 수 있게 하였다.</p>\n<ul>\n<li>장점\n<ul>\n<li>Native(Metaspace)로 많은 부분을 옮기면서, Native 영역은 JVM에 의해서 크기가 강제되지 않고, 프로세스가 이용할 수 있는 메모리 자원을 최대로 활용할 수 있게 되었다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 Metaspace 영역은 Heap이 아닌 Native 메모리 영역안에 있다. Heap 영역은 JVM이 관리하고 Native 영역은 OS레벨에서 관리해 자동으로 크기를 조절하고, Metaspace가 Native 메모리를 사용함으로써 개발자는 메모리에서의 영역확보의 상한을 크게 인식할 필요가 없게 되었다. 이것이 Java 8에서 Metaspace가 도입된 이유이다.</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#java-7%EC%9D%98-jvm\">Java 7의 JVM</a></p>\n<ul>\n<li><a href=\"#oom-%EB%AC%B8%EC%A0%9C%EC%A0%90\">OOM 문제점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#java-8%EC%9D%98-jvm\">Java 8의 JVM</a></p>\n<ul>\n<li><a href=\"#%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%EB%B3%80%EA%B2%BD%EC%A0%90\">구체적인 변경점</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"Java 7의 JVM \n기존의 Java 7 까지의 Non Heap Area였던 Permanent Generation이 Native 영역인 Metaspace로 바뀌었다. 기존의 Permanent 영역에는 아래와 같은 정보들이 저장되었다. Class의 메타데이터 (바이트코드 포함) Method의 메타데이터 static 객체, static 상수 상수화된 String Object Class와 관련된 배열 객체 메타데이터 JVM 내부적인 객체들과 JIT의 최적화 정보 OOM 문제점 이런 많은것들이 PermG안에 있다보니 , String Constant Pool, static object, Class 메타 데이터들이 쌓여 OOM이 발생하곤 했다. PermG는 시작할때부터 크게 잡지 않는 이상 리사이징이 되지 않아 그런 문제가 발생하곤 했다. 좋은 글 Java 8의 JVM \nJava 8에서부턴 PermG 영역을 삭제하고 Metaspace 영역을 추가해 Native 메모리의 영역으로 이동시켰다.…","frontmatter":{"date":"January 13, 2022","title":"JVM의 Java 8에서의 변화","categories":"Java","author":"weasel","emoji":"📓"},"fields":{"slug":"/jvm-change-in-java8/"}},"next":{"id":"a0255f2f-f9e3-5e68-8b8b-192aaa664f95","html":"<p>내부적으로 배열을 사용하여 조회,삽입,삭제 모두 <code class=\"language-text\">O(1)</code>안에 수행하기 위한 특별한 자료구조다. 배열의 인덱스를 유일하게(혹은 그에 가깝게) 지정하기 위해서 데이터와 연관된 고유한 숫자를 만들어낸 후 그것을 인덱스로 사용한다.</p>\n<p>또 일반적으로 순서를 보장하지 않기 때문에, 순서, 관계가 있는 목적에는 적합하지 않다.</p>\n<h2 id=\"hash-funciton\" style=\"position:relative;\"><a href=\"#hash-funciton\" aria-label=\"hash funciton permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hash funciton</h2>\n<p>데이터에 연관된 고유한 값을 만들기 위해서 해시 함수를 사용한다. 이 해시 함수를 통해서 나온 결과값을 해시 값(혹은 해쉬 코드,해쉬)라고 하고 이것을 이용해 데이터에 대한 접근 연산을 수행한다.</p>\n<p>가장 많이 쓰이는 해시 함수는 나머지 연산(modulo)를 이용한다. 키 <code class=\"language-text\">k</code> 를 어떤 정해진 수 <code class=\"language-text\">D</code> 로 나눈 나머지를 <code class=\"language-text\">k</code> 를 저장하는 버킷의 인덱스로 사용하는 것이다.\n→ <code class=\"language-text\">h(k)=k</code></p>\n<p>일반적으로 <code class=\"language-text\">D</code> 는 적절히 큰 소수(prime number)를 사용하는데 이유는 다음과 같다.</p>\n<blockquote>\n<p>만약 D를 소수가 아닌 값이라 하면, D의 모든 약수는 자신의 배수가 곧 키값이 된다. 해시충돌이 많이  일어나는것이다.</p>\n</blockquote>\n<p>만약 이 해시 함수가 엄밀하지 못해서 <strong>여러개의 객체가 서로 같은 값을 가지게 된다면 이것을 해시 충돌(hash collision)이라고 한다</strong>.</p>\n<p>일반적인 경우에서 가능한 키들의 집합을 <code class=\"language-text\">U</code>라고 하고, 버킷들의 개수를 <code class=\"language-text\">m</code>이라고 할때 <code class=\"language-text\">U>>m</code>인 경우가 대부분이므로 충돌은 필연적으로 발생한다. 이것을 해결하기 위해서 버킷의 사이즈를 단순히 키우는것은 좋은 해결책이 아니다. 메모리 사용량에서 치명적이다.</p>\n<p>좋은 해시 함수를 고안해도, <strong>여전히 해시 충돌은 불가피하다</strong>. 해시충돌이 늘어나게되면 <code class=\"language-text\">O(1)</code>의 시간복잡도 장점을 잃어버리고 <code class=\"language-text\">O(n)</code>에 가깝게 되니, 적절한 해결책을 세워야 한다.</p>\n<h2 id=\"open-addressing\" style=\"position:relative;\"><a href=\"#open-addressing\" aria-label=\"open addressing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Open Addressing</h2>\n<p>개방주소법(Open Addressing)은 간단히 말해서 해시충돌이 발생하면(계산된 인덱스로 접근한 버킷이 이미 사용중이면) 단순히 다른 인덱스에 데이터를 저장하는 방식이다.</p>\n<p>개방주소법 안에서도 여러개로 나뉜다.</p>\n<ul>\n<li><strong>Linear Probing</strong>\n<ul>\n<li>계산된 해시값에서 해시충돌이 발생한다면, 고정폭만큼 건너뛰어 비어있는 해시에 저장하는 방법이다. 만약 그 자리에도 차있다면, 그 다음 고정폭의 위치를 탐색한다.</li>\n<li>이 방법은 단순해서 계산을 하기 쉽지만, 최악의 경우 탐색을 시작한 위치까지 돌아오게 되어 종료할 수 있다.  <code class=\"language-text\">O(n)</code>이 걸리는 것이다.</li>\n<li>또 primary clustering이라는 특정 해쉬 값 슬롯 근처에 값들이 뭉치게 되는 문제도 생길 수 있다. <code class=\"language-text\">x</code> 라는 해쉬 값을 공유하는 객체들이 <code class=\"language-text\">x+1,x+2,x+3</code> 등으로 모이기 때문이다.</li>\n</ul>\n<strong>클러스터의 크기가 커질수록, 비슷한 해쉬값들이 적절히 배치되지 못하고 다음을 probing하니 클러스터가 더 빠르게 자라나고</strong>, 이는 성능적으로 이슈를 불러일으킨다.\n<ul>\n<li>다만 값들이 <em>클러스터링</em> 되어있기 때문에 <strong>cache hit</strong> 적인 측면에서는 유리하다. 처음 키에 대해서 접근을 하면 <strong>다음 키도 캐쉬에 올라와 있기 때문</strong>이다.</li>\n</ul>\n</li>\n<li><strong>Quadratic Probing</strong>\n<ul>\n<li>Linear Probing과 비슷하게 , 해시충돌이 발생한다면 다음 슬롯을 찾는다. 다른 점은 <code class=\"language-text\">idx=(hash(key)+i^2) mod m</code> 의 꼴을 취하는 것이다.</li>\n<li>이 방법도 primary clustering보다는 덜 하지만 성능에 영향을 주는 secondary clustering 문제를 일으킨다.</li>\n<li>초기 hash 포지션이 아닌 좀 더 광범위하게 퍼져있는 것이다.</li>\n</ul>\n</li>\n<li><strong>Double hashing</strong>\n<ul>\n<li>이름 그대로 해시 충돌이 생기면, 2차 해시함수를 이용해서 다시 해시를 하는 방법.</li>\n<li>값이 퍼지게 되어서 캐쉬의 측면에서는 비효율적이고 연산량이 많이 들지만, 클러스터링에는 큰 영향을 받지 않는다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"장점과-단점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90\" aria-label=\"장점과 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점과 단점</h3>\n<p>이처럼 개방주소법 내에서도 여러가지 충돌 처리방식이 있다. 일반적으로 개방주소법은 <strong>적은 양의 데이터에는 효과</strong>를 보이고 메모리 효율도 분리연결법에 비해 상대적으로 좋고, 메모리 할당에 대한 오버헤드도 없는 편이다.</p>\n<p>또 일반적으로 연결리스트를 사용하는 분리연결법에 비하여 <strong>캐쉬 효율이 좋기</strong> 때문에 (<strong>특히 Linear Probing</strong>) Python에서 hashtable을 구현할때 사용된다.</p>\n<p>하지만 <strong>데이터의 삭제에서 좋지 않은 퍼포먼스를 보인다.</strong>\n예를 들어 <code class=\"language-text\">A,B,C</code> 가 연속적으로 있을때(linear probing) <code class=\"language-text\">A</code> 를 삭제한다고 해보자. 그럼 <code class=\"language-text\">NULL,B,C</code> 라고 변경될텐데, 이때 <code class=\"language-text\">C</code> 에 대해서 조회를 한다면, <code class=\"language-text\">NULL</code> 을 만나게 된다. 이것을 <strong>원래부터 비어있는 공간</strong>인지 혹은 <strong>삭제되어서 비어있는 공간</strong>인지 알 수 없기 때문에 <code class=\"language-text\">C</code> 를 조회하지 못하고 탐색이 종료된다.\n이를 극복하기 위해서 삭제된 공간은 삭제되었음을 표시해주는 <code class=\"language-text\">DEL</code> 같은 표기자를 사용해 다음 index를 조회할수 있게끔 해야한다.\n물론 이러한 <code class=\"language-text\">DEL</code> 표시자가 늘어난다면, <strong>조회할 데이터가 없어도 계속적인 탐색을 수행해줘야 하니 표시자의 개수에 따라 해시테이블 전체에 대해서 rehashing을 해줘야 한다.</strong></p>\n<p><strong>load factor를 <code class=\"language-text\">l</code>이라고 하였을때 삽입과 조회, 삭제 모두 <code class=\"language-text\">O(\\frac{1}{1-l})</code>의 성능을 보여준다.</strong></p>\n<h2 id=\"seperate-chaining\" style=\"position:relative;\"><a href=\"#seperate-chaining\" aria-label=\"seperate chaining permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Seperate Chaining</h2>\n<p>분리연결법(Separate Chaining)은 일반적인 상황에서 개방주소법보다는 빠른데, 개방주소법의 경우 load factor가 커질수록 최악의 경우( <code class=\"language-text\">O(n)</code>)의 발생 빈도가 높아지기 때문이다.</p>\n<p>분리연결법은 해시충돌이 잘 발생하지 않게끔 하기 위해서 보조 해시 함수를 이용해 최악의 경우로 가는 상황을 줄이려고 한다.</p>\n<p>분리연결법에도 두가지 방법이 존재한다.</p>\n<ul>\n<li><strong>Linked List</strong>\n<ul>\n<li>각각의 버킷들을 연결리스트로 두어 충돌이 발생하면 해당 버킷의 리스트에 추가하는 방식.</li>\n<li>단, 연결리스트의 단점을 그대로 가지고 있다. 메모리 주소 상에서 연속적이지 않기 때문에 <strong>캐시의 효율이 나쁘고</strong>, <strong>아주 적은 데이터가 있을때의 메모리 오버헤드가 있다.(개방주소법과 비교해서)</strong></li>\n<li>또 Traverse를 할 때 최악의 경우에는  <code class=\"language-text\">O(n)</code>의 시간복잡도를 보인다.</li>\n</ul>\n</li>\n<li><strong>Tree</strong>\n<ul>\n<li>연결리스트의 단점을 개선하기 위해 나온 것으로 연결리스트가 아닌 Tree 구조를 이용해 데이터를 저장한다.</li>\n<li>단, Tree에서도 <strong>데이터가 편향되게 들어오면</strong>  <code class=\"language-text\">O(n)</code>의 시간복잡도를 가질 수 있으니 Red-black Tree와 같은 <strong>Balanced Binary Tree를 사용함</strong>으로써 <code class=\"language-text\">O(logn)</code>의 연산을 보장시킨다.</li>\n<li>하지만 적은 데이터 수에서 RB Tree를 유지하는데 드는 메모리 사용량이 연결리스트보다 크니, 적은 수의 데이터보다는 <strong>어느정도 데이터가 들어왔을때  연결리스트에서 트리로 전환한다.</strong></li>\n<li>Java 8에서부터는 데이터가 8개가 넘어가면 트리로 전환하고, 6개가 되면 다시 연결리스트로 전환한다. 두개의 차이가 2가 나는 이유는 데이터의 잦은 삽입,삭제로 1개단위로 전환하게 되면 오버헤드가 더 크기 때문에 일정 수준을 유지하는것이다.</li>\n<li>AVL 트리도 균형이진트리인데 사용하지 않는 이유는, 일반적으로 hashtable 같은 경우 데이터의 조회만 intensive하게 일어나지 않기 때문에, <strong>AVL 트리를 사용하면 rotation과 같은 balance를 유지하는데 드는 오버헤드가 너무 크다.</strong></li>\n<li>이에 반해 RB 트리는 조금 더 느슨하게 균형을 유지함으로써 조회,삽입,삭제에 <strong>평균적으로 좋은</strong> 퍼포먼스를 보여주기 때문에 hashtable의 내부 자료구조로 사용되는 것이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"장점과-단점-1\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90-1\" aria-label=\"장점과 단점 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점과 단점</h3>\n<p>분리연결법은 load factor에 크게 민감하게 반응하지 않아도 된다. 일반적으로 개방주소법에서 load factor가 커지면 성능이 기하급수적으로 나빠지는것에 비해서\n분리연결법은 조금 linear한 나쁜 성능을 보여준다.</p>\n<p>또 개방주소법에서는 hash table의 resize가 필연적으로 일어나게 되는데, 이것은 <code class=\"language-text\">O(m) , (m은 key의  개수)</code>의 시간복잡도를 요구하니 꽤 치명적이다.\n하지만 분리연결법에서는 하나의 버킷에 대해 지속적으로 사용하기 때문에 테이블의 확장이 <strong>개방주소법보다는 더디게</strong> 일어나는 편이다.</p>\n<p>다만 일반적으로 개방주소법에서 버킷들의 캐시 효율이 좋은 반면 분리연결법은 링크드리스트나 트리를 이용하기에 캐시의 효율이 좋지 않다.</p>\n<h2 id=\"해시-테이블-자체의-단점\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EC%B2%B4%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"해시 테이블 자체의 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시 테이블 자체의 단점</h2>\n<p>데이터가 pseudo-random 위치에 저장되기 때문에, <strong>데이터를 정렬된 순서로 접근하는 것에 있어서 엄청난 비용이 발생한다</strong>. Self-balancing binary tree와 같은 자료구조에서는 <code class=\"language-text\">O(logn)</code>의 조회를 보장해 조금 느리고 구현이 더 복잡하지만 데이터는 정렬되어 있다.</p>\n<p>또 데이터를 loop하면서 traverse하는 능력도 떨어지는데, <strong>데이터가 흩뿌려질(산재된) 확률이 높은 해쉬테이블의 특성상</strong> <strong>빈 슬롯도 모조리 체크</strong>해가면서 순회해야 하기 때문이다.</p>\n<p>일반적으로 해시 테이블은 지역참조성에 취약한데, 해시 테이블의 조회 자체가 <strong>버킷들을 건너띄면서 확인하는 방식이기 때문이다.</strong> 그렇기에 프로세스가 계속해서 <strong>캐시 미스를 발생시키고 이는 오버헤드로 이어진다.</strong> 데이터가 적고 type이 간단한(Integer…) 경우에는 배열을 이용한 자료구조가 더 나은 성능을 보일 수 있다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#hash-funciton\">Hash funciton</a></p>\n</li>\n<li>\n<p><a href=\"#open-addressing\">Open Addressing</a></p>\n<ul>\n<li><a href=\"#%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90\">장점과 단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#seperate-chaining\">Seperate Chaining</a></p>\n<ul>\n<li><a href=\"#%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90-1\">장점과 단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EC%B2%B4%EC%9D%98-%EB%8B%A8%EC%A0%90\">해시 테이블 자체의 단점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 10, 2022","title":"Hash Table에 대해서 완전 자세하게 알아보자.","categories":"자료구조","author":"weasel","emoji":"📓"},"fields":{"slug":"/hash-table/"}},"prev":{"id":"e48d5d5a-bf06-58d2-8af3-e6be8b866fd0","html":"<p>운영체제의 핵심 부분인 하나인 메모리 관리에 대해서 적겠다.</p>\n<p>대략 3편으로 구성되며 페이징,가상메모리,페이지 교체 알고리즘 순이다.</p>\n<h2 id=\"mmu\" style=\"position:relative;\"><a href=\"#mmu\" aria-label=\"mmu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MMU</h2>\n<p>CPU는 프로세스를 구동할 때 PC를 참조해서 다음 명령어를 메모리에서 가져온다. 명령어를 참고해 필요한 데이터가 있으면 메모리에서 가져오는데 이때 주소체계가 서로 다르다.</p>\n<p>아래의 그림처럼 base와 limit 레지스터 안에 있는 값들을 조합해서 CPU가 사용하는 주소(<strong>논리 주소</strong>)와 실제 메모리 주소(<strong>물리 주소</strong>)를 구할 수 있다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 698px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABm0lEQVQ4y5VT2W6DMBDM//9QFVVVlV5JlFZV3xoREsDmChQKNuBAYKp1DoX0tjRi2cXD7Hg9SNMUnLtwbAsmE1h6gOPYMJmC5TeYz19hLBawLAumacK27WO8Wq1gGAaWy6UGYwyDzWaDoiggpYAsGmQSOs5EjTRXeE9TCCE0siyDlBJ5nmtQ7hAfagN8Wt0x8jwXk+kMV1fXuLsfw/cD/LYGXdfhFLTquoaqFBh3cf8wwcXFELd3D7Adpuvb7Vajbft7CT2FB0KS7tgOkiQBWULvVVWhLMvP/XRdX+FXRXqSAiIgf4Mg0KSFlDrn+z4Y47p2TvqtQjrJOI41AZlPm9fhGlEUYTZ7xGh0gyRJfyY8L9abeqfI8zVhU9c6Tz+Io+j4/a8KC1noeSOF5GHTNFBKIVpHOjceTzEcXiIMw7+1TP4Rwc5DCZdzyH3bRE6tcs57nv9ISGNDm/NcQJQV3ulZlJD7Q/j3KdPkc8fG3ItxGyiMQ4Ubr8IiFnrw27bV+LNCukYuY7DCNzyHEi+hwJMvwFO5J+xfhFPCD7eM7DDg7OotAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"base_limit\"\n        title=\"base_limit\"\n        src=\"/static/53293237460e0580fd3e06096cae4618/487bb/base_limit.png\"\n        srcset=\"/static/53293237460e0580fd3e06096cae4618/e9ff0/base_limit.png 180w,\n/static/53293237460e0580fd3e06096cae4618/f21e7/base_limit.png 360w,\n/static/53293237460e0580fd3e06096cae4618/487bb/base_limit.png 698w\"\n        sizes=\"(max-width: 698px) 100vw, 698px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그러면 왜 두 주소를 구분하였을까?</p>\n<p><strong>가장 큰 이유는 보안이다.</strong> Limit 레지스터를 둠으로써, P1이 P2의 메모리 영역을 참조하는 Memory Illegal Access를 방지하는 Protection의 기능을 수행한다.</p>\n<p>MMU는 Memory-Management Unit의 약자로 위에서 말한 <strong>논리주소를 물리주소로 대응</strong>시켜주는 HW 장치이다.</p>\n<p>MMU 방식에서는 <strong>relocation 레지스터</strong>가 존재하는데, 프로세스가 메모리 주소를 만들때마다 relocation 레지스터 안의 값이 더해지고 이를 통해서 메모리에 접근할 수 있게 된다.</p>\n<blockquote>\n<p>base 레지스터와 역할이 동일하다고 생각하면 된다.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABW0lEQVQ4y6WT246CQAyGef+XWq+MMSGREC84JAh4ADkLCojQzd/NsCOL64VNyDB0+rX9Oyj0gV0uF9rv93Q+n+l4PFIURaQMw0CvnsfjQbfbjZqmGVdY3/e85nlOrutSEAQMDsOQFDjmYLDr9UpJkpBhGBwAwBToed4IRKWKCBYm7wFEW6vViispy/Lp7CxQOJFVwNAq9mgzTVPabDZkWeZY4f1+HzUEEK0+AYui4AoOhwNDlsslbbdbDhDCx3HM76fTiRZfCwYhGeIwEN/3f4HIsF6vSdM0yvOCLMvig/iOd3y3bXucpK7rDHYch/2qqpJpmj9TBrCqKj6ADDBMs+s6quuaW0d10BOP6AgGTf9U+N9QRKA8BNmyLJvXcHpdxAo9AYW20Asavr02c3+ADEfrnuuxLFOfAKJCJH0JnGtf3svA3W7HGgrw2wqxyndU9uE+onJIg4G1bUvfQ0rofzCBvQ0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mmu\"\n        title=\"mmu\"\n        src=\"/static/a464cc4a555c8d81e7c9044675a0c804/37523/mmu.png\"\n        srcset=\"/static/a464cc4a555c8d81e7c9044675a0c804/e9ff0/mmu.png 180w,\n/static/a464cc4a555c8d81e7c9044675a0c804/f21e7/mmu.png 360w,\n/static/a464cc4a555c8d81e7c9044675a0c804/37523/mmu.png 720w,\n/static/a464cc4a555c8d81e7c9044675a0c804/f1901/mmu.png 942w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"연속적인-할당contiguous-allocation\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D%EC%A0%81%EC%9D%B8-%ED%95%A0%EB%8B%B9contiguous-allocation\" aria-label=\"연속적인 할당contiguous allocation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속적인 할당(Contiguous Allocation)</h2>\n<p>메모리에 프로그램을 연속적으로 할당하는 방법이다. 간단하게 말해서 아래에서부터 차례차례 채워가는 방식. 메모리를 연속적으로 사용하기 때문에 간단한 MMU만으로 구현할 수 있다.</p>\n<p>일반적으로 커널은 낮은 메모리주소에 배치되고, 유저 프로세스는 높아지는 메모리 주소를 가진다.</p>\n<p>또 커널을 제외한 메모리 영역을 하나로 보는 방식과 여러개의 파티션으로 보는 방식이 있다.</p>\n<p>여러개의 파티션으로 할당하는 방법에서는 다수의 고정된 크기의 파티션으로 나누어져 있고, 2개 이상의 파티션에 할당할때는 합병(merge)해서 할당한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiUlEQVQoz42R2ZKiUBBE+f/fmumZMUJlAgVFEFlEmu3ilU2Ey5loZnvtiqi3zIo6mZrj+nx527De7Pj6tmajm2x1k2/ftxi7I39nnudPrabUhOs6rFY/OBwO6FsdwzAwzT3r9RrbdhCiQqmZz4w2TRN1XVMKQSne8QKbLI+Q8k5dS8Krix+eGF7tYngOD4TM6J93lFIo9ULWOY+mYBx7tH9IQC4i4tQir1yUGlHzi7S0ycSJpssWnZAht9SivHt80A1Ds3jS4kjblWiFkDRdT9sNpGVILhyEvDBNL9quw7AMzOOe9yxZDkaJy9ZaESX28kbbP9ifNtiXn7S9QNvZPkGc0j9HKnmjrFxkHdD2krwslgy9s4cfRrR9gx96BMFHDGdkLSmqFMff4V9NHk35H1kpKEREVp4Qd49JDTRtw97acbAt4iRedK53xjqY2I7NOI1U9wrd0NlZBmmefrSsUPPvBnOREMQn0iJYMhzHgeDmECUOdSv+aGIuV5tchAvyc2gXT5ye6XrJL9elWmhPvz4wAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"multiple\"\n        title=\"multiple\"\n        src=\"/static/daa64d9681c0e3b5e19c2c0a0bb87311/37523/multiple.png\"\n        srcset=\"/static/daa64d9681c0e3b5e19c2c0a0bb87311/e9ff0/multiple.png 180w,\n/static/daa64d9681c0e3b5e19c2c0a0bb87311/f21e7/multiple.png 360w,\n/static/daa64d9681c0e3b5e19c2c0a0bb87311/37523/multiple.png 720w,\n/static/daa64d9681c0e3b5e19c2c0a0bb87311/302a4/multiple.png 1080w,\n/static/daa64d9681c0e3b5e19c2c0a0bb87311/cdef6/multiple.png 1163w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그런데 그림에서 마지막 단계를 잘보면 P10과 P2 사이의 빈 공간이 보인다.\n이것을 <strong>Hole</strong>이라고 하는데, 단순히 말해서 할당가능한 메모리의 영역이다.</p>\n<p>이 Hole은 크기가 커서 프로세스를 할당받을 정도가 되면 문제가 되지 않지만, 그 크기가 작을때는 <strong>파편화</strong> 문제가 생길 수 있다.</p>\n<h2 id=\"파편화-fragmentation\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8E%B8%ED%99%94-fragmentation\" aria-label=\"파편화 fragmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파편화 (Fragmentation)</h2>\n<p>파편화 혹은 단편화는 메모리 내에서 할당가능한 영역이 존재하지만, 할당이 불가능한 상태를 의미한다. 두가지 종류가 있다.</p>\n<ul>\n<li><strong>내부 파편화</strong>\n<ul>\n<li>\n<p>할당을 하는 단위가 존재할때 생긴다.</p>\n</li>\n<li>\n<p>프로그램이 <strong>필요한 사이즈보다 더 큰 메모리가 할당</strong>되면서 <strong>파티션 내부적</strong>으로 <strong>메모리 공간이 낭비</strong>되는 상황</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 380px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 109.44444444444446%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD5ElEQVQ4y52VfUyVVRzHjzPBP8KARlr/9LLVbG01wkGgVquJLE3MLNcq2ly8ielwpU6trbW5IhWbreCCttYUWHWRF0nuBYLLa/ImIslSiAuXO2wC3tfnwn3u/bTneS6XV/ujZ/vunPM953ye3znnd3YE//Pz+/1L+sLtkdC16jnZWsTp1hJygypWvVOtxUHvdFsJOc3nKe6sDkI1zQGO2yZZdS4ZUfQK4kIi4sKmgBIRxa8hipNmvaLNiJ82En0+TZ3sWwo4Yb/Lo0XvIcq2E1r6JstL3yCs7B2erExl3W/7ib+cTWjpDu4r3cHKizsRv27lJf2B+cC5S56w3SWyZBeicguiPBlRvg1RkRzQdkTlTkT567P+xUTW6T9aAJxFCofTyaFzn5Ne8AlZhYfYE1BmoMwoPBj09p49zId52XxV8s38PZwHnJxk+Onn8N4fiRS5BiliNZ7wh5AeiEIKj8KjlIoXsRrpwUeYCgljMGkLXjVEXxAaBNonJrA8vAaEQBYCvxBMh6zA8sRjDDz7DKNrn1J9n6JlQh03GB83Hzh3D+0T41gjItWBM1Kg7pAQnCtDcKwKm9enaCgmekGEc4BOm43ryduwxsUysmE9I+sTsCTEM/pCHKNximJVT9XGDYw8H01fehryvZbsdHs4+EMzad83kZmvKUMpdc1kFTSTqQu085vYo2tm97cmvvy5fUEezkKFzSnx1hcGXj1cTdJRA5uOVLP1MyO7jteSmltD6qlaNh81kHikmqRjBl78+DJ7z5jueR2F3ekmI9fIuzl1pHxdx/uKcmpJyTGSkmNg9wmj2lb8D07U8fbxGo6dbcQluXF7PEiSxNT01GyESh529f2NeczNgMWG+baLlq6/MDR2U9/Wxy9VJrr7LZjHXAyM2hmwOrjaN0D/8Bi9N/6kqdlER2c7Xq9XA7pcDloqPqX70j66LmWr6qjYR3tZFn/oM2jTp9NZuT/Qd4DO8iyuGE7i9SlnIiP7vMiyPBuh3TaOtTwK6gX+OgGKfhf46gWyKRS/aYXmzahWMFQVq50yvsV76LBPYq16HBoF/oYQqF+G3BSOu20tzisxODoSNL9hOTSEqj8zV7+M168BF52yEqG5NBJqBNMGTR6jYMqgSQrUvUqfUSBXC26VxywCBvPQ43Fzs/NHhru+w9yVh7k7D0uPjtFrBVh6CrD26rD2FjLcnYe5K5+hzjMM9ui16zYDmwtcKp/sLh93Jj3YnD5u33Hxz7gL/+KkY6lHQKgh+2T8Pi/4ZbzTEv3917nWe5VbN2/Q1mqipaUBt8uhLdHn1cbPjXARMGDe6+FZ+DD915x/AWmzg8onJNYUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/4d25a9bbdf14f1297b598c1f475a84f6/3f520/1.png\"\n        srcset=\"/static/4d25a9bbdf14f1297b598c1f475a84f6/e9ff0/1.png 180w,\n/static/4d25a9bbdf14f1297b598c1f475a84f6/f21e7/1.png 360w,\n/static/4d25a9bbdf14f1297b598c1f475a84f6/3f520/1.png 380w\"\n        sizes=\"(max-width: 380px) 100vw, 380px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ul>\n</li>\n<li><strong>외부 파편화</strong>\n<ul>\n<li>\n<p>남아있는 메모리가 흩어져 있어서 <strong>총 메모리 양은 할당할 수 있을 정도인데 실제론 할당할 수 없을때</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 380px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACaklEQVQ4y42T20tUURSHN/jUvxP0EJmXShsHRBSCsuzFl7IXg3DQsSh8EIsIghQTgop6M5wu44zM0SJpbPCSppaZlzMXx3Gam3rOOJdzvpgzOSRJzIZv77Vg8WOvtX9bWD8OcPxdK1XDFsxOKzWOdk472ih908qEPEduZXUNHZ1ilihzdSLeViHsdYiRRoTzPMJei7BVY1sZN4oyWhZdL1Jw6GEXfc0mBq410H+1jsdX6hhoqae32czyjMco0jTNECxGVGxXnAIhDLSSIyBKCnliyGYU6ZlM/ixCVCx1WlkvO8lqjYmfOcxm1kxnWa4sZ9P9qVC4L/Y/DMFgPE4KUIHkH/bjJa+fDb8PJREran45UeGVA+wk9ojHFBKxXYN4TEXZVpHcc7z4ME8olW85uZdC2Uuj/kUuV5Ip0pn8w4nVcQubI0fZcJXhl87glyoJuk7gdxwjGnDz4+kTPDctJFfmuPvqKw13HDT1SFzodtHY7eJSj8S5LgfueTnf8uZoBQwL0k6BIglUl0BzCNI2wa8tF7RcJiMEY4ODWJ5/obrDSX2XRNO9MS72jFF7W8J8awTnxAIB3xpiZXYIefoR6zP9yNO9yNN9Rrw22YvPu4DnwX0m21qJL07R/myK0us2TFZ7geoOO+U3bLgml3MGQ4Qju/mBHjLk1+9neTk6hS+xY+RL8hbuxQ0834N8/pYnF7sXA4RjeR0RCPiIRraIRsIFYtEwkXAIrz+AnklBJm2Yu6hX3v8JyaSKqqooioKi7JLNZg/eXNfRNJ2sph1KwYe5LZ1OEwwGDUKhTbxemVQq9c/vONzMB439G90vz+rZV6N5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/e6c3534022ed6a8e9e75a1e42a4d30ac/3f520/2.png\"\n        srcset=\"/static/e6c3534022ed6a8e9e75a1e42a4d30ac/e9ff0/2.png 180w,\n/static/e6c3534022ed6a8e9e75a1e42a4d30ac/f21e7/2.png 360w,\n/static/e6c3534022ed6a8e9e75a1e42a4d30ac/3f520/2.png 380w\"\n        sizes=\"(max-width: 380px) 100vw, 380px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>내부 파편화와는 다르게 할당을 하는 단위가 존재해도 생기고, 존재하지 않아도 생길 수 있다.</p>\n<ul>\n<li>존재할때는 왜 생길까?\n<ul>\n<li>B프로세스의 다음 메모리 공간을 보자.<br>\n원래는 프로세스가 들어갈 자리인데도 그 프로세스가 끝나고 D가 끝나지 않았다면 C는 들어가지 못한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>즉, 사용가능한 메모리 영역은 있는데, <strong>연속적이지 않은것이다.</strong></p>\n</li>\n<li>\n<p><strong>압축</strong>(compaction) 기법을 통해서 해결 할 수 있는데, <strong>오버헤드가 크다.</strong> (JVM GC의 mark-and-compaction 생각해보자.)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"세그멘테이션-segmentation\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-segmentation\" aria-label=\"세그멘테이션 segmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그멘테이션 (Segmentation)</h2>\n<p>페이징 방법에서는 가상 메모리를 서로 <strong>같은</strong> 크기로 분할했지만, 세그먼테이션 방법에서는 서로 크기가 다른 논리적 단위인 세그먼트로 분할한다.</p>\n<p>세그먼트들의 크기가 각각 다르기 때문에(code를 위한것,데이터를 위한것…) 필요할때마다 빈 공간을 찾아서 해결한다.</p>\n<p>프로세스가 딱 필요한 만큼만 메모리를 배정해주기 때문에 내부파편화 문제는 없지만, <strong>외부 파편화 문제는 존재한다.</strong></p>\n<ul>\n<li>아래 그림을 보자. (a)번 상황에서 Segement 1이 빠지고 S7이 들어오면, S7이 더 작기 때문에 공간에는 맞지만 S2와 S7 사이에 빈공간이 생긴다.<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 602px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB4UlEQVQozz2T167CMBBE8/8fxAMIIUAIiQeq6BC4lCTUhBK6mKuzKIlk7F2vZ2fGxgnDUNvt1sbr9dLpdLL1brfT+/2W53maTCY2Ho+HfN/XeDy2+H6/a7PZaDqd2iB2giBQs9nUbDbT7XYzsHa7rfl8bg1YZzIZ5fN5Xa9X9Xo9ZbNZVSoVQabVaqlQKCiXy+lwOMjhB6AoiuwAM0xgGsexHVoul8aU/GKxUK1WU7fbtRpm4lKppOPxKAfKg8HADgG83+81HA61Wq0MgHg0GhnQ8/lUp9NRsVhUuVw2RkgHrFqt6nK5/ABd1zUAGFGE3PV6nTZgH0AawBRG+Jj4jS2Qot48hDYgJGgACzwFgBifkktJAFAEIA1gR84AOUBxwohOyMH08/lsMZLIIanf76cSeQkoIsctGyCmI4cNrp2OMEqeATGvAB/xkMbso4gLBJSbTwEBgwUsYZAA4BEFxPV63WpoAGCj0TBfIZPUYxuvxKGIDjzY7/drIMR4yxfH13Sf73aL0/jzfqf1AH8+HzmLv4U8z5fvByabt7Tb7rRee5aPwsiY43XgB/K9wGTG8c3qN5utouikMIx0vz/k4IXrzn5jOjOg+fxP06mrYxjZ34/BDTNQhJfkmMn91i9j+A9nsXKkCM571AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/b1dbd33cde81c96667abffe610fab2d9/32056/3.png\"\n        srcset=\"/static/b1dbd33cde81c96667abffe610fab2d9/e9ff0/3.png 180w,\n/static/b1dbd33cde81c96667abffe610fab2d9/f21e7/3.png 360w,\n/static/b1dbd33cde81c96667abffe610fab2d9/32056/3.png 602w\"\n        sizes=\"(max-width: 602px) 100vw, 602px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></li>\n<li>비슷한 상황이 S4가 나가고 S5가 들어오는 상황에서도 생기고 3과 6의 상황에서도 생긴다.</li>\n</ul>\n<p>이런 빈 공간이 생기기 때문에 <strong>세그멘테이션은 외부파편화 문제</strong>가 여전히 존재한다.</p>\n<h2 id=\"페이징-paging\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-paging\" aria-label=\"페이징 paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 (Paging)</h2>\n<p><strong>논리적 메모리 주소 공간이 물리적인 메모리 공간에서 비연속적으로 배치하게끔 허용</strong>하는 기법을 의미한다.</p>\n<p>물리메모리를 고정된 사이즈의 <strong>프레임(Frame)</strong> 이라는 크기로 나누고, 동일한 사이즈로 논리메모리를 <strong>페이지(Page)</strong> 로 나눈다.</p>\n<p>즉 , 프로세스가 일정량의 페이지를 요구하면, 같은 양의 충분한 프레임을 찾아서 매치시켜준다. 그렇기 때문에 허용가능한 프레임을 추적해야한다.</p>\n<p>또 페이지와 매치되는 프레임을 찾기 위해 <strong>페이지 테이블</strong>을 관리해야 한다.</p>\n<p>하지만 외부 파편화 문제는 해결할 수 있지만(비연속적으로 배치하니) <strong>내부 파편화 문제는 여전히 존재한다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACqElEQVQoz3WT22/iRhTG8zf3vQ/7UqnaSiut2j7sQzfKUtQbDQlRkna33e2WBCUGG0IABwjGFzw2l0C4GBtj/yqbbPvUI535zoxmPp35vpk927bRNA2r0cCQygwUBUuWMSsV7H4f4bjYtsBxHFzXYfiUydxxxL8ohI3neewBBGufSalE+/SUai5Hs1Dg/uyMSdNmuoDpA4zH4Pu7DEP+N/aiOE4L+6JE5eQ3rn4tUC6cUyuc42k6ERBHMfNHCAIIfFgsdoeXS7CNLa4ZMJ0lK/GuQ4iwL8rI55eUTz4gn11wc1okMKyUcBsFzOYhQbjB32yYzTds4w1BGOILQeAKwqSxOGZvvYrYPi6xy3Wk6zuUaxVZuqNaauCZJv2JhTkcoOom5khgDAVdy8YaCwxhoJs9rARHBnFCODC2zK054kpG+qvK9R9XlD9UqL6vsNT7NEWHjqnT6HW5M/q0DY1m/x5V11CNPi1d4942aZh3xHGUXDmGKET8/pZaJov03T7yQYZGJovf6xESE2w81kGAJWZYbtKZwHQE89WCMApY+Wtm8+CTKTsVxd9Fqvk8lVwOJX/EbT6P1+t/kphwA/461T2NONq5HUWwCWC9fjIlfnJZFC9Qjgtc/fwLlaNj6kfHTFoG42lEt+PQbA4olTp0uwNubzVMc5ISjkYrLi9vGI/n/z2bOIoYvXtL6+CA+v4+ajZL502GhaqxDmHozpCkKo1GG13v0Ww2UNUWy9UixWLxI7PZdEeYDGG4xVY79JQ6bUmhV01QZjmepJsMQ8e0zLTWdQNJKqe/5XE05GH6gOu6rDxvR9hqDxm7gr52T7vdon6jUKvJKLUq0nWJ0sc/Ofwpy+GPGd6d5Mi9ecXrr5/z/Tcv+eHFc1599SXffvGMl59/xvvDA/4Br3Bn0n0sxVkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/da1e41f06c9203707421d30c09cc51a1/37523/4.png\"\n        srcset=\"/static/da1e41f06c9203707421d30c09cc51a1/e9ff0/4.png 180w,\n/static/da1e41f06c9203707421d30c09cc51a1/f21e7/4.png 360w,\n/static/da1e41f06c9203707421d30c09cc51a1/37523/4.png 720w,\n/static/da1e41f06c9203707421d30c09cc51a1/bf433/4.png 971w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 그림처럼 프로세스의 메모리주소를 <strong>같은 크기의 페이지</strong>로 나누고 물리 메모리의 <strong>프레임</strong>과 대응시킨다.</p>\n<p>이 대응이라는 것은 논리주소를 단순히 구성할 순 없고, 일반적으로 <code class=\"language-text\">2^m</code>바이트의 논리 메모리 사이즈와 페이지 사이즈가 <code class=\"language-text\">2^n</code>바이트일때, 아래와 같이 m 비트를 (m-n)비트,n비트로 구성한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABp0lEQVQoz12Si27aQBBF+f9/qlqhlNKC38bGdngZCiYBigs23vWuT2RHKCEjrbQzo3vn7KMnRMXhmNMfJoytOX+sJbafMhwneN4E27YxLRvX9RgbJo5lYzkextjEGBlYlo1hWKzSNdfrlR6A0g00kkbXaC3RSiJlhdaKpmm6pZSiqkS311ojZd1Ku7xWinv0LpecTVYycArMsGDklziR4OVYEU0DbMvB9yZM/IAwnHakYRDiOi5xnBBFcdf3/YD1evNOmOdn4mTGcrlit91heT5D0+TXaIQdBDiez3QaMV3McYIQ0/UYjsZYptUNcGyX/JzjeR69FvlrbLwJSf+JbRgR/+gzN+1uUPjtO7PhbxY/BwRPA9I0JUkS4jj+OPL9Hu7Gsq6RWUqznqGOO+r1DPn6l+J6ol4l1NslKkvRp+wB4u7R+1xo43Yruek9ggPi3zOCV6pmT1GskJwQlwWi3lKqHeXt2mnaR7rrHw0b0DSI/Ix8yZCnA3L2jNhniEYh/5+RqwXyeEAo2f2CzzAPhg+NuoaihPIG57zFfq9LCcfTR/7FrDV8A2k+pWerzZ9qAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/a4841b9d90ed38f138412d95f98dc2ee/6af66/5.png\"\n        srcset=\"/static/a4841b9d90ed38f138412d95f98dc2ee/e9ff0/5.png 180w,\n/static/a4841b9d90ed38f138412d95f98dc2ee/f21e7/5.png 360w,\n/static/a4841b9d90ed38f138412d95f98dc2ee/6af66/5.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>페이지 오프셋은 <code class=\"language-text\">2^n</code>바이트의 페이지 중에서 현재 몇번째 바이트를 지시하는지 알려주고, m-n비트의 페이지 넘버는 페이지 테이블 내에서 몇번째 프레임을 가리키는데 사용된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABxklEQVQ4y5VT23KbMBD1/39QOn1qp2ndJ2dMihMC2CBwQmKwwUjczOV0dhMxEPelO3NG0kp7OHthMQwD/hdkTdOgrmtem7oZ/Qva9H3P+Lyfnqcgv1IKVVUxYZ7nvF4RErRNg7VNVV4ul9FPSsuyfCf8eDk+PB6P46Umjg8HFKpA13Vo25ZRFAWTkq9QavzAgqRbTzaECNix3W7hOi6nQYjjGKZpQkqJ0+nEqaZpynd91zEhpUsrE2ZZhm/fb7G6W8P3BdbGPeI4YWUUuFrdYbN5QFkUrIoIlZS810aKR0IpFczNAzxfsIr9fo/dbocoimDbNgzDgOM4fEcfoHKQOiLuPhTq1GdN0cUduhZhkuFWpHAPZ1SFGmtHqVEwgRTqM8VpjhlhWVVwrEfYzzG++jn+vKSolMR5Mha623TWUzBLeUqYnc8Q3g7e2wk39gH3+wQYevhCwLIseJ7HpSCjGfxnDWcKVQlcWsRVjxsvh3V8L7xUilNcLpcMCqY0acSo81cpkyUqw4+nFX67BlKpYAWviJIUU6OGEIGOCcMQQRDM3iz0QKu6xE93jS+bX3h82cJ/FTBDG/abgPnswoq8kej6r+pG/AVx1esFOXKkYwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/786432a0051aae7f662255f805a5729f/37523/6.png\"\n        srcset=\"/static/786432a0051aae7f662255f805a5729f/e9ff0/6.png 180w,\n/static/786432a0051aae7f662255f805a5729f/f21e7/6.png 360w,\n/static/786432a0051aae7f662255f805a5729f/37523/6.png 720w,\n/static/786432a0051aae7f662255f805a5729f/7de01/6.png 794w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이러한 페이징 방식에서 논리주소 변환은 위의 구조를 가진다.<br>\n잘보면 offset인 d는 주소 변환에는 안쓰이고 바로 물리주소에 대응시켜버린다.<br>\n반대로 p인 페이지 넘버는 page table내부에서 frame number와 매치시키기 위해서 사용되는데 p→f 의 역할을 하드웨어의 지원을 받아서 수행된다.</p>\n<h3 id=\"페이지-테이블\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94\" aria-label=\"페이지 테이블 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 테이블</h3>\n<p>페이지 번호와 프레임 넘버를 매치시켜주는 구조를 페이지 테이블(Page Table)이라고 하는데 , <strong>메모리 안에 저장된다.</strong></p>\n<p>그렇기때문에 실제로 어떠한 메모리에 접근할때는 <strong>두 번의 메모리 접근</strong>이 필요하다.</p>\n<ol>\n<li>메모리에 있는 페이지 테이블 접근</li>\n<li>변환된 물리적 주소에 가서 메모리 접근</li>\n</ol>\n<p>이 메모리 접근은 꽤 비용이 큰 작업이기 때문에 <strong>TLB</strong>라는 새로운 하드웨어 캐시가 쓰인다.</p>\n<h3 id=\"tlb\" style=\"position:relative;\"><a href=\"#tlb\" aria-label=\"tlb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TLB</h3>\n<p>TLB는 Associative Memory라고도 불리는 하드웨어 캐시인데, 논리주소를 물리주소로 변환할때 메모리접근을 줄이기 위해서 사용된다.</p>\n<p>페이지테이블과 유사하게 페이지 번호와 프레임 번호가 대응되게 기록되어 있다.<br>\n다만, <strong>모든 페이지 번호가 TLB 안에 있는 것은 아니다.</strong></p>\n<p>물론 이 레코드들을 다 순차적으로 읽는것은 아니고, <strong>하드웨어의 지원을 받아 병렬적으로 읽기 때문에 매우 빠르다.</strong></p>\n<blockquote>\n<p>이에 관해서 좋은 답변이 있어서 공유한다. <a href=\"https://cs.stackexchange.com/questions/119744/%3Ehow-does-a-tlb-lookup-compare-all-keys-simultaneously\">How does a TLB lookup compare all keys simultaneously?</a></p>\n</blockquote>\n<blockquote>\n<p>요악하자면 단일 CPU 안에서라도 파이프라이닝 기법을 이용해서 병렬적으로 읽는다는 것. (컴퓨터구조 수업을 참고하자.)</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 435px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkklEQVQoz1WPbW/aQBCE+f//ox/7oaqiNgoRtCppJdoSB0KTKA5gbIhxjH1+u/PZvieyY0V0pdFqd3ZHMwP6MsZwWvbKYzJdcGe7aF3TNFCWFVVtsNce1tLG+rfiKLL//ganYlVdk2YReRGTZkeCo0+chN0s0pBjdCCXb1w7t8iKmKyIyIq00xlgzLugVIpIrFHSoZAOqtwi1RvSfE0snpDltuO6fXtXOEi5JhK7zv0A0zps3gVF7qIJUMZHNc+oak+pd+SFQ5Ks0NpDtaj3qMZHcUDjI1Kfqm76yH1+qUuS0EY/TVFbC7X5i1p8p7TGFL+HpL++Ul6PUC2Wk/5mhnb+EIt97/BiiLm4hC/n6PmC7NMHpDVCbmYo7wbpL5GxTZasiCMblW8owgfk820nKNcz5NUZ2eePNFXNgDTFRBEkKTJJSBwLfT+hmY/h7gdmPkJfX1JMz0mvztCzYQduv3V8dTOmfPyJ8B56hyeRy6rCj3eEiceLcAlit+uhcDkEK/b7R8LI6Xan/EviEoiAujG8AsZxWzbwNLfIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/1cce148d06dadcc98f64f766b8f297d8/330eb/7.png\"\n        srcset=\"/static/1cce148d06dadcc98f64f766b8f297d8/e9ff0/7.png 180w,\n/static/1cce148d06dadcc98f64f766b8f297d8/f21e7/7.png 360w,\n/static/1cce148d06dadcc98f64f766b8f297d8/330eb/7.png 435w\"\n        sizes=\"(max-width: 435px) 100vw, 435px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>TLB가 도입되면서 (p,d)의 논리주소를 물리적 주소로 변환하는 방법이 변했다.</p>\n<ol>\n<li><strong>TLB를 먼저 확인</strong>해서 p에 해당하는 프레임 번호가 있는지 찾는다.\n<ol>\n<li>있다면, <strong>프레임 넘버 f와 오프셋 d를 가지고 바로 메모리에 접근한다.</strong></li>\n<li>없다면 2번으로 간다.</li>\n</ol>\n</li>\n<li><strong>메모리</strong>에 있는 <strong>페이지 테이블을 확인</strong>한다.</li>\n<li>페이지 테이블에 적힌 <strong>프레임 넘버 f와 오프셋 d를 가지고 메모리에 접근한다.</strong></li>\n<li><strong>가장 최근에 사용된 (p,d)→(f,d) 를 TLB에 저장한다.</strong></li>\n</ol>\n<p>1,4번 때문에 TLB는 논리적→물리적 주소 변환에서 <strong>캐시 역할</strong>을 수행한다고 볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 672px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.44444444444443%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACbElEQVQ4y42Ui27aMBSG+/4vs6nbpKpq1fVCS6eNNgmES4FCIEAuQBJCSGKSb7KhbF1baZaOnIv1neP/P/ZRHMf48zlRFLFYLJhOphRFwXa7RQjxbsh/ZVmq+Hcc9fp9riu31BsmZsOkVnvg6alLEAQqyXsx9+cqqQSmWU6SpirSPN8BT8/OedB02p0Ov2o19HqdPBcqY/FOFWEYqiqhRBv5XI5WXI1jHu0lR2PbpmE26T8PVHZn5pAma567T6zCQM0izw4yyKrCIEBIYFmgT5bcOIKKu0VzYo7kArlYjmSzod1q8bPZ5bvW5s7sq9n2l68qlHK86KeAs4yKI9Bnq9fANE25q9xwUmtx0vU51gZ8a7s0rBl2q8lkMEBiVlGkth0FSx5Hc26cXAG1t8AMQ9P4cm9w3Bjzudblkz7EeLZJnSnL6RTbnmBZFoZRp9NsUht6VD4CbtIUezymava4ao04rTW5bI2wvN2WkyyjWr2nen/P0LKIo5AfvYmCvQtcr9ckSaKey61gFYYH3eS7dFX2qjRHuS9Nsfcauh8AZah22X+LViuMkYc2jRgvVkq//wYme6AoSjKxaxHX8zhvT/ja8Wm5EXEYIMQfoHFwOX/r8mazwXddxo06lq6RbTZ4nsdZY8hpb45uOYTLhVr/ApTNfOVsufYKHv4GvoTIc5qaRkvXqBsG09mM657Dt7ZD3fYpRa5gqoiyZOAGPNoLFX0vfA2UI16vua1WOb+4wDRN1knC3Sjg3Irp+LGqqijKw1kuhKDTNDF1HZFlb4FSw7nv47ru/rxCZ2jz2HlmNHUOhingfutC3Uw7zX8DMRps0mGweUoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/933f463afc5e7f327eec24db9e5f669c/30d16/8.png\"\n        srcset=\"/static/933f463afc5e7f327eec24db9e5f669c/e9ff0/8.png 180w,\n/static/933f463afc5e7f327eec24db9e5f669c/f21e7/8.png 360w,\n/static/933f463afc5e7f327eec24db9e5f669c/30d16/8.png 672w\"\n        sizes=\"(max-width: 672px) 100vw, 672px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>💡 다만 일반적인 CPU 캐시(L1,L2…)와는 목적 자체가 다르다. TLB는 주소 변환 속도 향상을 위한것이어서 MMU에 의한 주소변환시에 생기고 , CPU 캐시는 데이터를 가져올때 메인 메모리 접근을 줄이기 위하여 메인 메모리 접근시점에 참조된다.\n물론 둘 다 메인 메모리 접근을 줄이기 위함이라는 점은 비슷하다.</p>\n</blockquote>\n<blockquote>\n<p>A cache stores a memory location temporarily while a TLB is like a cache that stores address translation (virtual to physical address)</p>\n</blockquote>\n<p><strong>단 이 TLB도 컨텍스트 스위칭이 일어날때 비워진다.</strong></p>\n<p>그 이유는 새로운 프로세스가 CPU를 할당받게 되면, 다른 메모리 주소공간을 참조할것이기 때문이다.<br>\n이때문에 컨텍스트 스위칭 직후 TLB 미스가 연속적으로 생긴다.</p>\n<h3 id=\"페이지-사이즈\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%82%AC%EC%9D%B4%EC%A6%88\" aria-label=\"페이지 사이즈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 사이즈</h3>\n<p>페이지의 크기에 대해서도 얘기해보자.<br>\n페이지의 크기를 정하면, 페이지 테이블의 크기도 결정되므로 적절한 페이지 크기 선정이 중요하다.</p>\n<p>여기서 말하는 <strong>적절한</strong>의 기준이 뭘까?</p>\n<blockquote>\n<p>만약 모든 프로세스가 4K만 요구하는데 페이지 사이즈가 8K면?</p>\n</blockquote>\n<blockquote>\n<p>모든 페이지에 4K만큼의 내부 파편화가 생기는 것이다.</p>\n</blockquote>\n<ul>\n<li>만약 페이지 사이즈가 크다면?\n<ul>\n<li>페이지 테이블의 크기는 줄어든다.</li>\n<li>한 개의 페이지 테이블안에 들어있는 데이터가 많으니 <strong>공간 지역성</strong>을 잘 만족한다.</li>\n<li>한 번에 많은 양의 데이터를 디스크에서 가져오니 <strong>I/O 작업이 줄어든다.</strong></li>\n<li><strong>내부 파편화</strong> 문제가 증가한다.</li>\n<li>필요하지 않은 데이터가 메모리에 올라올 수 있다.</li>\n</ul>\n</li>\n<li>만약 페이지 사이즈를 작다면?\n<ul>\n<li>내부 파편화 문제가 감소한다.</li>\n<li>필요한 데이터만 메모리에 가져올 수 있다.</li>\n<li><strong>공간 지역성</strong>을 지키기 어려워 페이지 폴트 발생 확률이 늘어난다.</li>\n<li>페이지 테이블 내의 엔트리가 많아지니 페이지 테이블의 크기가 커진다. <strong>오버헤드가 발생한다.</strong></li>\n</ul>\n</li>\n</ul>\n<p>따라서 여러가지 트레이드 오프를 고려해서 페이지의 크기를 정하는 것이 중요한데,<br>\n일반적으로 메모리 크기도 커지고, 프로세스 크기도 커져서 페이지 사이즈의 크기도 커지고 있다.</p>\n<p>리눅스 16.04 기준 아래와 같은 명령어로 페이지 사이즈를 알 수 있는데 4096으로 4K다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">$ getconf PAGESIZE\n<span class=\"token operator\">></span> <span class=\"token number\">4096</span></code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#mmu\">MMU</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%97%B0%EC%86%8D%EC%A0%81%EC%9D%B8-%ED%95%A0%EB%8B%B9contiguous-allocation\">연속적인 할당(Contiguous Allocation)</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8C%8C%ED%8E%B8%ED%99%94-fragmentation\">파편화 (Fragmentation)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-segmentation\">세그멘테이션 (Segmentation)</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-paging\">페이징 (Paging)</a></p>\n<ul>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94\">페이지 테이블</a></li>\n<li><a href=\"#tlb\">TLB</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%82%AC%EC%9D%B4%EC%A6%88\">페이지 사이즈</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 17, 2022","title":"운영체제의 메모리 훔쳐보기 1편 - 페이징(Paging)","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/paging/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/jvm-change-in-java8/","nextSlug":"/hash-table/","prevSlug":"/paging/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}