{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/mutex-and-semaphore/",
    "result": {"data":{"cur":{"id":"95b5f682-4b6d-53b8-b194-e0e45169e5dd","html":"<blockquote>\n<p>난 운영체제가 제일 재밌고 좋다. 최고👍</p>\n</blockquote>\n<p>세마포어와 뮤텍스를 본격적으로 얘기하기에 앞서서 두 방법이 나오게 된 문제상황인 <strong>Race Condition</strong>과 <strong>Critical-Section</strong>을 먼저 소개한다.</p>\n<h2 id=\"race-condition\" style=\"position:relative;\"><a href=\"#race-condition\" aria-label=\"race condition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Race condition</h2>\n<p><strong>두 개 이상의 프로세스가 공유 데이터에 대해서 동시에 접근하고 조작하려하는 상황</strong>을 의미한다. 즉 Race라는 뜻 그대로 하나의 자원을 놓고 서로 경쟁하려는 상태이다.</p>\n<p>이 공유된 데이터의 마지막 값은 어느 프로세스가 마지막으로 끝내는지에 따라 달려있다. 만약 interleaved execution(서로 번갈가면서 명령어 수행시) 데이터의 무결성이 침해받는다. → <strong>불확실성</strong></p>\n<p>이것을 예방하기 위해서, 동시에 진행되는 프로세스는 반드시 동기화가 되어야 한다.</p>\n<h2 id=\"critical-section\" style=\"position:relative;\"><a href=\"#critical-section\" aria-label=\"critical section permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Critical-Section</h2>\n<p>이러한 문제를 <strong>임계구역</strong>(Critical-Section) 문제라고 한다. 임계구역이란 동일한 자원에 대해서 접근하는 영역을 의미한다.\n해결하기 위해서는, 한 프로세스가 <strong>임계구역에 진입해 작업을 진행할때</strong>, <strong>다른 프로세스들은 임계구역에 진입하는 것을 허락하지 않는것이다.</strong></p>\n<p>동기화를 해결하는 방법은 세가지 필수적인 조건을 맞춰야 한다.</p>\n<ol>\n<li><strong>상호배제(Mutual Exclusion)</strong>\n<ul>\n<li>어떠한 프로세스 혹은 스레드가 <strong>임계구역에서 작업을 진행하면</strong>, 다른 프로세스 혹은 스레드는 <strong>임계구역에 진입할 수 없다.</strong></li>\n</ul>\n</li>\n<li><strong>진행(Progess)</strong>\n<ul>\n<li>무기한으로 연기되는것을 막기 위해서 필요하다.</li>\n<li>만약, 다른 프로세스가 임계구역에서 작업을 하고 있지 않다면, <strong>다른 진입을 원하는 프로세스의 진입은 지체되어서는 안된다.</strong></li>\n</ul>\n</li>\n<li><strong>한계가 있는 대기 (Bounded Waiting)</strong>\n<ul>\n<li>과도한 방지를 막기 위해서 필요하다.</li>\n<li>프로세스가 임계구역에 들어가기 위해서 요청하고 <strong>대기하는 시간은 한정</strong>되어 있어야 한다. <strong>즉, 무기한적으로 대기되는것을 막기 위해서 필요하다.</strong></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"문제에-대한-개괄적인-해결방식\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%9C%EA%B4%84%EC%A0%81%EC%9D%B8-%ED%95%B4%EA%B2%B0%EB%B0%A9%EC%8B%9D\" aria-label=\"문제에 대한 개괄적인 해결방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제에 대한 개괄적인 해결방식</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB0ElEQVQoz32S6W7bMBCE/f4PFSC/WhRw6/po0LhVJVsUScmxLZ8Sr68gnbhummaBARfc5XD2GGh9pCwdorJIaclzy3J58eOplMUYg7U2IfrOeaKFEHhtg6ZZURQlQihKodIpZcNyKZL/9LRmWQqU0kipqOuGw+FwJXyNwYU3XBO6vsd5j3WO3hiMsfQRveHc9en+PRtE1S/KYynWOrZtS7trCcHjvXtGSN9GUmN6+r5P5Z/PZ7quS773PhKGay8SofPs9y0/szVlZckXhqU406xW7HY7hKiYzWYJRVEwmUwYjUbkeU5d15eSr4Tep9KinX4J2g8j2s/fOXz8glF1Uth1F2VRVVR3Op3SRxH7/f4NQmOTL3XHPDvy8HhEqA2lFOlRKaqkaDweJ1Xz+Zwsy5hOpwyHwzdKtg7vPN9+PDB6/EqhF1QbidwofPBpSO8OJU74ljA2/XA4kmU5VSU5Hk8pHmNRfYz/b2X+WZt4ujjRm4WNO2xdJAypJXGSf968rNvtYtcdRQF5ERACtAalA0qCUg1a36H1PavmnkVxh9KfWK0cVQVCBDYbrqQRg83aJ8IsC0gZMOYZPWmaxmyxdosxO7pujzEnbMoh5Vn7N+FvF3qePy3S2L4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/e34592d878891622f468691992212a08/37523/1.png\"\n        srcset=\"/static/e34592d878891622f468691992212a08/e9ff0/1.png 180w,\n/static/e34592d878891622f468691992212a08/f21e7/1.png 360w,\n/static/e34592d878891622f468691992212a08/37523/1.png 720w,\n/static/e34592d878891622f468691992212a08/ee455/1.png 863w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>두 개의 프로세스만 있다고 가정했을때, 임계구역에 진입가능했는지 체크하고, 임계구역을 빠져나올때는 진입가능성을 열어준다.\n이 때 프로세스들은 동기화를 위한 데이터를 공유해야 한다.</p>\n<h2 id=\"뮤텍스\" style=\"position:relative;\"><a href=\"#%EB%AE%A4%ED%85%8D%EC%8A%A4\" aria-label=\"뮤텍스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>뮤텍스</h2>\n<p>CS를 가진 스레드 혹은 프로세스들의 실행시간(Running Time)이 서로 겹치지 않고 각각 단독으로 실행될 수 있게끔 하는 기술이다.<br>\n일반적으로 한 프로세스에 의해 소유될 수 있는 <strong>Key 객체</strong>를 기반으로 작동되며, <strong>이 객체를 소유한 스레드 혹은 프로세스만이 공유자원에 접근할 수 있다.</strong></p>\n<p>뮤텍스를 구현하는 방식에는 세가지 정도가 있는데, 모두 각각의 장단점이 존재한다.</p>\n<h3 id=\"swap-turn\" style=\"position:relative;\"><a href=\"#swap-turn\" aria-label=\"swap turn permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swap turn</h3>\n<ul>\n<li>\n<p>첫번째 해결방식, <strong>Swap turn</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// P0</span>\n<span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>turn <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">/* My turn? */</span>\ncritical section\nturn <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* Now it’s your turn */</span>\nremainder section\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>\n\n<span class=\"token comment\">// P1</span>\n<span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>turn <span class=\"token operator\">!=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">/* My turn? */</span>\ncritical section\nturn <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* Now it’s your turn */</span>\nremainder section\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span></code></pre></div>\n<ul>\n<li>공유 변수 <code class=\"language-text\">turn</code> 을 두고, 서로 입장 가능한지 while로 체크한다.</li>\n<li><strong>상호배제는 만족하지만, 진행도는 만족하지 못한다.</strong></li>\n<li>두 프로세스는 무조건 <strong>in-turn 방식</strong>(왔다갔다)으로만 진입할 수 있다.\n<ul>\n<li>만약 P0→P1 순서대로 들어갔다고 해보자. 이때 P1이 추가적인 진입을 원하더라도 P0의 차례이기 때문에 P1은 진입 할 수 없고, 진행도를 만족하지 못한다.</li>\n</ul>\n</li>\n<li>즉, P1이 CS에 더 자주 접근해야하는 시스템이라고 해보자. 그럴때는 P0에 의존적이다. 두번 연속으로 CS 진입이 불가능하기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"dekkers-algorithm\" style=\"position:relative;\"><a href=\"#dekkers-algorithm\" aria-label=\"dekkers algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dekker’s Algorithm</h3>\n<ul>\n<li>\n<p>두번째 해결방식,<strong>데커 알고리즘</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">boolean flag<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n초기에는 flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>flag<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>flase <span class=\"token comment\">// 아무도 CS안에 있지 않다.</span>\n<span class=\"token comment\">// Pi</span>\n<span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\nflag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* Pretend I am in */</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">/* Is he also in? then wait*/</span>\ncritical section\nflag <span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* I am out now*/</span>\nremainder section\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>만약 <code class=\"language-text\">flag[i]==true</code> 이면, Pi는 CS에 진입할 수 있다.</li>\n<li>첫번째 Swap turn 방식의 문제점인, 연속적인 진입이 불가능한 점을 해결한다.</li>\n<li><strong>상호배제는 만족하지만, 진행도는 만족하지 못한다.</strong></li>\n<li>만약 <code class=\"language-text\">flag[i]=true</code> 일때 컨텍스트 스위칭이 일어나면, Pj가 생각하기에 Pi가 들어가있다고 생각할것이다. 실제로는 그렇지 않은데.\n<ul>\n<li>그러면 둘다 CS에 진입하지 못하고 기다려야 한다. 다음 컨텍스트 스위칭이 일어날때(선점식일때)까지 기다려야 한다.</li>\n<li><code class=\"language-text\">flag[i]=true</code> 로 바꾸는 저 부분이 유저 코드이기 때문에 중간에 인터럽트의 방해를 받을 수 있는 <strong>non-atomic</strong>이기 때문이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"petersons-algorithm\" style=\"position:relative;\"><a href=\"#petersons-algorithm\" aria-label=\"petersons algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Peterson’s algorithm</h3>\n<ul>\n<li>\n<p>세번째 해결방식 (피터슨 알고리즘)</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\nflag <span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* My intention is to enter …. */</span>\nturn <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* Set to his turn */</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>flag <span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> and turn <span class=\"token operator\">==</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">/* wait only if …*/</span>\ncritical section\nflag <span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\nremainder section\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>1번과 2번의 공유 변수를 조합한 방식이다.</li>\n<li><code class=\"language-text\">flag[j]</code> 변수를 활용해서, swap-turn은 해결했다. 또 <code class=\"language-text\">turn</code> 문제를 이용해서 <strong>무조건 둘 중 하나는 CS에 들어갈 수 있음을 보장한다.</strong></li>\n<li>상호배제,진행도,한정된 대기시간이라는 두 프로세스간의 해결책에서의 조건을 모두 만족한다.</li>\n<li>여러 프로세스로 확장가능하다. 하지만, while loop에서 CPU는 계속 체크해줘야 하는 <strong>busy waiting 문제가 여전히 남아있다. CPU cycle을 낭비하고 있는것이다.</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"hw-지원\" style=\"position:relative;\"><a href=\"#hw-%EC%A7%80%EC%9B%90\" aria-label=\"hw 지원 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HW 지원</h3>\n<p>이렇게 해결책에도 여전히 문제점이 남아있기 때문에, 많은 시스템들은 하드웨어의 지원을 받는다.</p>\n<ul>\n<li>I/O가 없을때 CS 진입 후 선점적인 스케쥴링을 방지.</li>\n<li>유니프로세서 시스템에선 인터럽트를 꺼버린다. 왜냐면 timeout이 있기 때문에. 하지만 대부분의 멀티프로세서 관점에서는 불리하다.</li>\n<li>현대의 대부분의 시스템들은 <strong>원자적인(atomic) 하드웨어 명령어</strong>를 지원받는다.\n<ul>\n<li>\n<p>TAS(test and set)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC+0lEQVQ4y32T228bVRDG/S8jIKGNikJKGxFD4rRBNKngqQ+gBgiFJ0BqhXCIa68ve0myvuz6st71ei9ee9d27Nj7Q+s8YJDKSJ/Od+ac+eZcZlL+YAC+D7YNfQdcFwyDZc+ma1oMBgMMo4tt9/E9n17Pwbbr9KwCnU4eXT8nCDQSi+OY1CgMmQcBnq5hqVW8Vhu/3qBXb6DrLSRJQRRlNL2JcnlJtdagWhURpd9xHBnLEplM7H8EEzJfLAjCENv18IcjvOEQx/cZR2MaWpN2p8toNKLd6eB6PrWqhiTXMAybKLrB94c4rrcSTS2XC4iX/J/dzGbEa3uGwd0zqOo1Vs/CtExMy7oTXA+czmIG4fTu+Gv+hM9md3y5hNvFu5OnXO8Cz8/jBwL99muu898xdXPM+jlGTg7Xe7tat/sXGGaWrpVdzaNxielNZYXZXGQUFgmjAamrqw0EYROh8hETbQdK91gUN6G4gZX/kGJpk0JhA0XZoiBskMt9QLlyjyBIE8dPmc8PgSOs3kPKlT+SK3+J1tjF9w6oNx5xnrvPX2+3qOm76K3PEApb/Prbe4zHR3heBqOzhyRtI8ufoKqfcnFxH8NI4zhpRDGbfMoTDGMP1/0CrfGIN6/fp6ruoKo7XF1tA8e47j5BkCEMD+kauytU1W0ulQdojYfAMxxnj4r4ZyJ4xHJ5AjxfZRcKD9D1XXz/CZObb1jGz4GviZdfMZ8/o22eoGrH1FrHVK6PqTVPULQXCFIGRcmSCqPHzGcZHOcxwXCPKPqcMEwzCtM43j495wDb2cf1k/EA087gDjJ4gwP63iF+cMAoekq1/jHF0htSpfIpxdIpBeElQvEl+cK3iNIZsvIKWflphbL4imL5ZyriL0jyGbL8I4pyhih9T7lyiiT9QPb8BZqm/rsOFwswTRfPC2m1rBXvdGx03aBW1SmVZLrd/srfbJpE0S1x/J86TDpgHbNZ0koulmWu4HkOrtvHtnt0Om0cx2Y6HTOZRNzeJh20WIuP+RsMd+3AQY22YAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/b98a69e1d99ba00cf8c45e516717a33c/37523/2.png\"\n        srcset=\"/static/b98a69e1d99ba00cf8c45e516717a33c/e9ff0/2.png 180w,\n/static/b98a69e1d99ba00cf8c45e516717a33c/f21e7/2.png 360w,\n/static/b98a69e1d99ba00cf8c45e516717a33c/37523/2.png 720w,\n/static/b98a69e1d99ba00cf8c45e516717a33c/774b6/2.png 738w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>CAS(compare and swap)</p>\n<ul>\n<li>\n<p>원자적으로 두 변수를 바꾼다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3klEQVQoz4WTeW+bQBDF/f2/Vf5olSh2D2MbzBFYHA5jF2PAB8fyq3YT0jhR2yeN9pjZp5k3s5M8z4miiDDcEIYhtu1griys9RrfD3AcB9f1GDEMA3+D8k2klMheotaqqjAMA8NYYFlrAiFomobz+ayDRzJ13m5TROCztkwWC4Pj8ah9k8vloonKstKB/4OKP5YnbH+PK3bY/o5HI6Gsry+EivlwOLBNt6RpSrpNgF4VoE1lXldHdruUNI3I84z9LiOKU/K8oOsHejlKMTC51aDHcX6RpJIogqLQt2zCK9NpxpevIXPjhOfl7Pd7Tqf6naYvkkxGbVQmCtEzPDwMzKYDrjMQioGVCcsl3N113N9LZjNIkhcaKQdtI/HkrXOKWBWbZnTfFrRLh3Y2p3cF12bgcmmoTx3pds96HeD7sZbofYd1hh/HIUkGTKvHcXuWK0nbdnRdS9ePuo7xkrquybJM2+cMX9eiOCBEwPPzhjiJESKkadpX/+3M2baNaZpYlqUb+4lQzVzbtjeP1ODHccxms8HzXH7++K7vFHzf12ULIQiC4A/hxx8w6qEzPlYYiyWe94T7JHiYzpnP52+kZVnqjhdFQdd1n0u+3UN17piZBx6XB/zoRHWW//yGvwEQSpfZ0JlYhwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/b3a0f263463a0498a2491fa71f69ca14/37523/3.png\"\n        srcset=\"/static/b3a0f263463a0498a2491fa71f69ca14/e9ff0/3.png 180w,\n/static/b3a0f263463a0498a2491fa71f69ca14/f21e7/3.png 360w,\n/static/b3a0f263463a0498a2491fa71f69ca14/37523/3.png 720w,\n/static/b3a0f263463a0498a2491fa71f69ca14/35751/3.png 873w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>key=true일때 lock이 false면, 진입해버린다. key=true인데 lock이 true면 계속 기다린다.</p>\n</li>\n<li>\n<p>이때 key는 lock과 달리 지역변수라 컨텍스트스위칭에 안전하다.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"세마포어\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4\" aria-label=\"세마포어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세마포어</h2>\n<p>뮤텍스와 비슷하게 동기화 기법이지만, 뮤텍스는 동시접근을 막으려는 측면이 강하고,<br>\n세마포어는 <strong>접근 순서 동기화</strong>에 조금 더 관련이 있다.</p>\n<p>근본적으로 <code class=\"language-text\">wait()</code> 와 <code class=\"language-text\">signal()</code> 을 이용해서 제어를 하는 방식으로 세마포어를 여러개를 둠으로써 CS에 접근 가능한 task의 개수를 조절한다.<br>\n개수가 1개이면 binary semaphore로 mutex 처럼 작동을 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">P</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token comment\">// atmoic 해야함</span>\nfunc <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">while</span> S<span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span> <span class=\"token keyword\">do</span> nothing<span class=\"token punctuation\">;</span>\n\tS<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token comment\">// atomic 해야함</span>\nfunc <span class=\"token punctuation\">{</span>\n\tS<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA8klEQVQY05WR22rDMBBE/f+/1ZeGUpK3ErepSUh8kyU5sZXo4uoUiVL6kFI6y8LA7g4zbDEMgrZtEKIjeE9CjJH/IqaKkaIs32mFQY0Bt3wNI3jvsdZhrcU5l9vefnBr807iy7IkxYxiVJ7deuJ1PSP3F5jOfISA0pqmaWnbjkEIhBioTzV9L6jrmv3+QNN2nE4158vl22mxGIdYVXSrA/NmB1UFzjEZg1YaqRTjeEZJlfk0z7/HTpFn43ja1Dw8HthWkmPf0QvJ1VzRWmenSVAOA1Iq5tnkw3udHZbbLZv1M2/lC8HfcNYSfPj7CXfEksNPbRnPk3oxbngAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/d253d94bae58c4ff2c38529d9f7293bb/37523/4.png\"\n        srcset=\"/static/d253d94bae58c4ff2c38529d9f7293bb/e9ff0/4.png 180w,\n/static/d253d94bae58c4ff2c38529d9f7293bb/f21e7/4.png 360w,\n/static/d253d94bae58c4ff2c38529d9f7293bb/37523/4.png 720w,\n/static/d253d94bae58c4ff2c38529d9f7293bb/baaa6/4.png 813w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이렇게 구현하면 세마포어를 이용한 뮤텍스가 된다.물론 busy waiting 문제가 여전히 발생을 한다.<br>\n즉, <strong>특정 프로세스가 CS를 많이 차지하면 다른 프로세스는 P에서 계속 기다려야 한다.</strong></p>\n<p>이런 방식은 여전히 싱글프로세서 시스템에서 자원의 낭비라는 관점에서 치명적이다.</p>\n<h3 id=\"blockwakeup-방식\" style=\"position:relative;\"><a href=\"#blockwakeup-%EB%B0%A9%EC%8B%9D\" aria-label=\"blockwakeup 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Block/Wakeup 방식</h3>\n<p>Block/Wakeup 방식은 busy waiting의 방식처럼 계속 기다리는 것이 아니라,<br>\n기다려야 할때만 대기줄에 줄만 세워놓고 block을 당하게 한다. 그 후 자리가 생기면, 즉 순서가 돌아오면 block 당한것들부터 차례로 깨운다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* semaphore */</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">process</span> <span class=\"token operator\">*</span>L<span class=\"token punctuation\">;</span> <span class=\"token comment\">/*process wait queue*/</span>\n<span class=\"token punctuation\">}</span> semaphore<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tS<span class=\"token punctuation\">.</span>value<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">.</span>value<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\tadd this into S<span class=\"token punctuation\">.</span>L\n\t\t<span class=\"token function\">block</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tS<span class=\"token punctuation\">.</span>value<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> S<span class=\"token punctuation\">.</span>value<span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n\t\tremove P from S<span class=\"token punctuation\">.</span>L\n\t\t<span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런식으로 세마포어에 링크드 리스트를 구현해서 세마포어를 완성한다.<br>\nprocess wait queue는 링크드 리스트로 프로세스의 PCB에 대한 정보를 가지고 있다.</p>\n<ul>\n<li><code class=\"language-text\">block()</code> : 커널이 현재 프로세스를 중지시키고, 그 프로세스의 PCB를 세마포어 안에 있는 대기 큐에 넣는다.</li>\n<li><code class=\"language-text\">wakeup(p)</code> : block되었던 프로세스 P의 작업을 다시 하게 한다.</li>\n</ul>\n<p>이 때 <strong><code class=\"language-text\">S.value</code> 의 절댓값은 현재 block 되어 있는 프로세스의 개수와 동일하다.</strong></p>\n<p>이전의 busy waiting과 block wakeup 방식을 비교해보자.</p>\n<ul>\n<li>CS 파트가 작으면\n<ul>\n<li>기다리는데 드는 시간보다, <strong>block-wakeup하는데 드는 오버헤드가 더 클 수 있음.</strong></li>\n</ul>\n</li>\n<li>CS 파트가 길면\n<ul>\n<li>busy waiting이 길어지기 때문에 <strong>block-wakeup이 더 좋을수 있다.</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"임계영역이-유저-공유-데이터에서만-생길까\" style=\"position:relative;\"><a href=\"#%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD%EC%9D%B4-%EC%9C%A0%EC%A0%80-%EA%B3%B5%EC%9C%A0-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90%EC%84%9C%EB%A7%8C-%EC%83%9D%EA%B8%B8%EA%B9%8C\" aria-label=\"임계영역이 유저 공유 데이터에서만 생길까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>임계영역이 유저 공유 데이터에서만 생길까?</h3>\n<ol>\n<li>\n<p><strong>인터럽트 핸들러와 커널</strong></p>\n<p><code class=\"language-text\">count</code> 라는 커널 변수가 있다고 해보자. count 의 값을 올리는 과정은 load하고,increase하고,store를 하는 것인데,</p>\n<p>중간에 인터럽트가 와서 인터럽트 핸들러 내에서 count 값을 올리면, 그 뒤의 count 결과는 보장할 수 없다.</p>\n</li>\n<li>\n<p><strong>커널이 시스템 콜을 수행중일때, 컨텍스트 스위칭이 일어나면</strong></p>\n<p>두 프로세스간은 공유되는 데이터가 없다하더라도, 시스템 콜을 수행할때 커널 데이터는 공유될 수 있다.</p>\n<p>아래와 같은 상황일때 count의 값을 보장 할 수 있는가?</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+ElEQVQoz5WS607bQBCF8/5PVBFouQpKArQVlDaB2IkTJ3bs+Bp717v2V+2SAELtjx7paGbk2dmzZ9zruo62bVG6RXWg2w6DNC+ZLlZMZj6eH1KUFeW2YlvVNhaGZYVsFGbGnj1zOC8rJs6cYDKhLreYkVI2xEnGMoiJNinRJiOKUzZpbuu1YZzavv0wAztQNIoiyyH0aYWwH/YN/wOrsKxqm0RJzm8vYLXe4LgLKiGtUt22tF1nY5TmhFGC686Z+yHOPMBbrvHDmCBKXhSGcUqjNH4Q8zie4q0iRg8jvKeJuRItG9pGoRvFcjRh7ng40wWj5xnuIsDxjM9Lxu7i7cnvkWYpjz++0xSFkQdKgdZ0WpN4C5J1TFpsrZd/ffI+MZs2mM1mXA+G9rl7tjvThdJIpRGysdS63Z3tbI9VWBuv3m1pnyulqGqxo7S2dLtLP6p6H3vLMLaGf8R8FTG8H3P38xnn1xO3V3cIKf+53ZdoPeyQQlLVNUIIaquopqpeajOkCUKkv3ztMZRS2l6tNW37xtelZFVDUgjCZEuc1SSlIN1Ksm1DVAjiQrBOK+K8ZpPX5JWy9ce/tec+DBh/u2R4dsj1SZ/r0z4350cMTvt8PT5gcNJneHrIzdkRdxefuTo+4Pb8yNaXXz5xe/GZ6cMQ536Aez/gD+yxl6oNNLNUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/72e7a7593800021049865c3eace7b54b/37523/5.png\"\n        srcset=\"/static/72e7a7593800021049865c3eace7b54b/e9ff0/5.png 180w,\n/static/72e7a7593800021049865c3eace7b54b/f21e7/5.png 360w,\n/static/72e7a7593800021049865c3eace7b54b/37523/5.png 720w,\n/static/72e7a7593800021049865c3eace7b54b/0eb6d/5.png 913w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>이 문제에서 중요한 점은 프로세스간의 데이터 공유가 아니더라도 임계영역문제가 커널 단에서 분명히 발생할 수 있다는 점이다.</strong></p>\n<p>유닉스에서는 이를 방지하기 위해서 <strong>커널이 작업을 수행하고 있다면(시스템 콜 처리) 선점식 스케쥴링이 일어나지 않는다.</strong></p>\n</li>\n<li>\n<p><strong>멀티프로세서 시스템</strong></p>\n<ul>\n<li>만약 두개의 CPU에서 한쪽은 count를 내리고, 한쪽은 카운트를 내린다고 해보자. 어느 값을 저장해야 하는가?\n<ul>\n<li>각각의 CPU 이기 때문에 인터럽트로 통제할 수 없다.</li>\n</ul>\n</li>\n<li>이럴때는 커널 자체가 하나의 큰 CS가 된다\n<ul>\n<li>커널 자체 접근을 한 CPU만 할 수 있게 하거나</li>\n<li>커널내의 공유 변수들을 따로 세마포어로 둔다. 그러면, 큰 CS가 여러개의 나뉘어진 CS가 된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"이진-세마포어-vs-카운팅-세마포어-비교\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-vs-%EC%B9%B4%EC%9A%B4%ED%8C%85-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-%EB%B9%84%EA%B5%90\" aria-label=\"이진 세마포어 vs 카운팅 세마포어 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이진 세마포어 vs 카운팅 세마포어 비교</h3>\n<ul>\n<li>이진 세마포어\n<ul>\n<li>정수값이 0과 1를 오가는 세마포어다. lock과 비슷하게 0은 사용중이고 1은 자유로운 상태이다.</li>\n<li>같은 시간 안에 오직 한개의 프로세스나 스레드가 CS에 접근하는 것을 허용한다.</li>\n<li>CS안에 두개의 프로세스나 스레드가 동시접근이 불가능하기 때문에 상호배제는 만족한다.</li>\n<li>단지 정수적인 lock에 불과하니, 제한된 대기를 보장할수는 없다.즉, 기아가 발생할 수 있다.</li>\n</ul>\n</li>\n<li>카운팅 세마포어\n<ul>\n<li>카운터라는 여러개의 값을 가질 수 있는 세마포어다.</li>\n<li>값의 범위는 0에서부터 N까지며, N은 CS로 입장을 허용하는 프로세스 혹은 스레드의 개수이다.</li>\n<li>한번에 둘 이상이 CS에 접근가능하기 때문에 상호배제를 보장하지는 않는다.</li>\n<li>기아현상을 피하기 위해서 큐를 구성하고 있는데, 이 큐가 있기 때문에 언젠가는 접근할 수 있다. 즉 제한된 대기 상태를 보장한다.</li>\n<li>특정하고 1보다 큰 개수의 한정된 자원을 배분할때 사용 될 수 있다.\n<ul>\n<li>쓰레드 풀 (Thread Pool)</li>\n<li><a href=\"https://www.holaxprogramming.com/2013/01/10/devops-how-to-manage-dbcp/\">DBCP(Database Connection Pool)의 사례</a></li>\n<li><a href=\"https://linked2ev.github.io/spring/2019/08/14/Spring-3-%EC%BB%A4%EB%84%A5%EC%85%98-%ED%92%80%EC%9D%B4%EB%9E%80/\">스프링에서의 사례</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"세마포어와-뮤텍스-차이점은\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80\" aria-label=\"세마포어와 뮤텍스 차이점은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세마포어와 뮤텍스 차이점은?</h2>\n<ul>\n<li>세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.</li>\n<li>예를 들어 Casting을 한다고 보면 (뮤텍스)세마포어 –> 가능하지만 (세마포어)뮤텍스 –> 불가능하다.</li>\n<li>세마포어는 <strong>소유할 수 없</strong>는 반면 뮤텍스는 <strong>소유할 수 있</strong>고 소유자가 이에 책임을 진다.</li>\n<li>뮤텍스는 <strong>1개만</strong> 동기화가 되지만 세마포어는 <strong>하나 이상</strong>을 동기화 할 수 있다.  → 즉 임계영역에 접근가능한 수가 원천적으로 1개이냐 , 그 이상이냐의 차이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">변기가 하나뿐인 화장실에서는\n앞의 사람이 볼일을 마치고 나가야 다음 사람이 들어갈 수 있다.\n이렇게 한번에 오직 하나만 처리할 수 있는 대상에 사용하는 것이 뮤텍스이다.\n\n변기가 세개인 화장실에서는 동시에 세 사람이 볼일을 볼 수 있고\n이 세 사람 중 아무나 한명이 나오면 다음 사람이 볼일을 볼 수 있다.\n이렇게 동시에 제한된 수의 여러 처리가 가능하면 세마포어이다.\n\n만약 변기 세개짜리 화장실의 각 변기에 대해 뮤텍스를 사용한다면\n대기중인 사람은 각 변기 앞에 줄을 서는 것이고\n이렇게 되면 옆 칸이 비어도 들어가지 못하게 된다.\n\n만약 변기 세개를 묶어서 뮤텍스를 사용한다면\n변기 수에 관계없이 무조건 한명만 사용할 수 있게 된다.\n\n이 예에서 변기는 동기화 대상, 사람은 그 동기화 대상에 접근하는 쓰레드를 나타낸다.\n\n뮤텍스와 세마포어의 목적은 특정 동기화 대상이 이미 특정 쓰레드에 의해 사용중일 경우\n다른 쓰레드가 해당 동기화 대상에 접근하는 것을 제한하는 것으로 동일하지만\n관리하는 동기화 대상이 몇개 인가에 따라 차이가 생기게 되는 것이다.</code></pre></div>\n<h3 id=\"뮤텍스-vs-이진-세마포어\" style=\"position:relative;\"><a href=\"#%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%9D%B4%EC%A7%84-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4\" aria-label=\"뮤텍스 vs 이진 세마포어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>뮤텍스 vs 이진 세마포어</h3>\n<ul>\n<li><strong>뮤텍스</strong>\n<ul>\n<li>근본적으로 <strong>공유하는 자원에 대한 보호</strong>의 목적으로 쓰인다.</li>\n<li>뮤텍스는 <strong>lock을 잠근 task가 보유</strong>하는 관점이다.</li>\n<li>그렇기에 오직 <strong>그 task만이 해제</strong>할 수 있다. lock을 보유하지 않은 task가 접근할시 에러가 발생한다.</li>\n<li>일반적으로 이진 세마포어보다 더 가볍고 단순하기에 CS에 대한 보호의 용도로 더 많이 사용된다.</li>\n</ul>\n</li>\n<li><strong>이진 세마포어</strong>\n<ul>\n<li><strong>신호를 주는(Signalling) 메커니즘</strong>에 더 가깝다. “나는 끝났으니, 이제 너의 작업을 해도 된다”</li>\n<li>wait를 <strong>호출한 프로세스나 스레드가 아니여도 해제</strong>할 수 있다.</li>\n<li>물론 이것을 이용해서도 공유 자원을 보호하는데 사용할수는 있지만, <strong>task의 순서 동기화</strong>의 측면이 더 강하다.</li>\n<li>일반적으로 뮤텍스에 비해 오버헤드가 크다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"스핀락과-busy-waiting의-사용처\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%95%80%EB%9D%BD%EA%B3%BC-busy-waiting%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%B2%98\" aria-label=\"스핀락과 busy waiting의 사용처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스핀락과 busy waiting의 사용처</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">do</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\tCS\n\t<span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span>\n\nfunc <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>availbale<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">//busy waiting}</span>\n\t<span class=\"token punctuation\">}</span>\n\tavailable<span class=\"token operator\">=</span>false<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 방식은 <code class=\"language-text\">available</code> 이라는 변수를 둠으로써 락이 걸려있지 않다면 가져온뒤 CS로 진입하고 그렇지 않으면 계속 시도하는 방식을 쓰고 있다.</p>\n<p>이럴때 acquire과 release는 atomic해야한다. 이런 방식의 가장 큰 문제점은 busy waiting을 해야한다는 점이다. 한 프로세스가 CS에 접근하고 다른 프로세스가 acquire 함수를 호출하면, 계속 acquire 안에서 계속적으로 루프를 돌아야 한다. 이런 방식의 구현을 스핀락(spinlock)이라고 하는데 다른 프로레스가 락이 풀리기를 기다리면서 계속 “돌고있기” 때문이다.</p>\n<p>이러한 연속적인 루프는 싱글프로세서 시스템에서 명백한 문제인데, busy waiting 방식에서 다른 CPU가 더 잘 사용할 수 있는 자원을 대기하는데만 사용하고 있기 때문이다. <strong>내가 기다리고 있다는 건 다시 말하면 나혼자만 CPU를 할당받고, 다른 프로세스(락을 풀어줄수 있는)는 돌아가고 있지 않기 때문에 기다릴 이유가 없는것이다.</strong></p>\n<p>그러면 스핀락을 사용하는 busy-waiting 방식은 전혀 쓸모가 없는것일까?<br>\n<strong>그렇지 않다.</strong><br>\n이에 관해서 Operating System Concepts(공룡책)의 설명을 보자.</p>\n<blockquote>\n<p>Spinlocks do have an advantage, however, in that no context switch is required when a process must wait on a lock, and a\ncontext switch may take considerable time. In certain circumstances on multicore systems, spinlocks are in fact the preferable choice for locking. If a lock is\nto be held for a short duration, one thread can “spin” on one processing core while another thread performs its critical section on another core. On modern multicore computing systems, spinlocks are widely used in many operating systems.</p>\n</blockquote>\n<p>야매로 번역을 해보자면,</p>\n<blockquote>\n<p>하지만, <strong>스핀락도 장점이 있다.</strong> 락이 빨리 풀릴거라고 예상되는 시스템에서 스핀락은 아주 유용하다.<br>\n<strong>컨텍스트 스위칭을 하는 비용보다 스핀락으로 busy waiting을 하는게 더 이득일 수 있기 때문이다.</strong><br>\n이러한 장점때문에 멀티프로세서 시스템에서 한 쓰레드는 락에 대해서 계속 스핀하고, 다른 쓰레드는 다른 프로세서에서 임계영역에 대한 접근을 할 수 있다.</p>\n</blockquote>\n<p>이게 무슨말이냐면, 원래 락이 빨리 풀리는 시스템에서는, <strong>다른 프로세서에 있는 스레드가 락을 해제한다면, 내 프로세서에서는 컨텍스트 스위칭을 할 필요없이 바로 스핀락 하다가 들어가버리면 되기 때문이다.</strong></p>\n<p>만약, 내가 지금 <strong>spin 한다고 해서 바로 컨텍스트 스위칭을 해버린다면, 다른 프로세서가 락을 풀어도 내 프로세서는 다시 프로세스로 스케쥴링될때까지 기다리고, 컨텍스트 스위칭을 한 후  접근해야하기 때문이다.</strong><br>\n즉, 원래 락이 빨리 풀리는 시스템에선 컨텍스트 스위칭의 비용이 spin lock의 대기시간의 비용보다 더 비쌀수 있기 때문이다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#race-condition\">Race condition</a></p>\n</li>\n<li>\n<p><a href=\"#critical-section\">Critical-Section</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%AC%B8%EC%A0%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%9C%EA%B4%84%EC%A0%81%EC%9D%B8-%ED%95%B4%EA%B2%B0%EB%B0%A9%EC%8B%9D\">문제에 대한 개괄적인 해결방식</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%AE%A4%ED%85%8D%EC%8A%A4\">뮤텍스</a></p>\n<ul>\n<li><a href=\"#swap-turn\">Swap turn</a></li>\n<li><a href=\"#dekkers-algorithm\">Dekker’s Algorithm</a></li>\n<li><a href=\"#petersons-algorithm\">Peterson’s algorithm</a></li>\n<li><a href=\"#hw-%EC%A7%80%EC%9B%90\">HW 지원</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4\">세마포어</a></p>\n<ul>\n<li><a href=\"#blockwakeup-%EB%B0%A9%EC%8B%9D\">Block/Wakeup 방식</a></li>\n<li><a href=\"#%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD%EC%9D%B4-%EC%9C%A0%EC%A0%80-%EA%B3%B5%EC%9C%A0-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90%EC%84%9C%EB%A7%8C-%EC%83%9D%EA%B8%B8%EA%B9%8C\">임계영역이 유저 공유 데이터에서만 생길까?</a></li>\n<li><a href=\"#%EC%9D%B4%EC%A7%84-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-vs-%EC%B9%B4%EC%9A%B4%ED%8C%85-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-%EB%B9%84%EA%B5%90\">이진 세마포어 vs 카운팅 세마포어 비교</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80\">세마포어와 뮤텍스 차이점은?</a></p>\n<ul>\n<li><a href=\"#%EB%AE%A4%ED%85%8D%EC%8A%A4-vs-%EC%9D%B4%EC%A7%84-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4\">뮤텍스 vs 이진 세마포어</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%ED%95%80%EB%9D%BD%EA%B3%BC-busy-waiting%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%B2%98\">스핀락과 busy waiting의 사용처</a></p>\n</li>\n</ul>\n</div>","excerpt":"난 운영체제가 제일 재밌고 좋다. 최고👍 세마포어와 뮤텍스를 본격적으로 얘기하기에 앞서서 두 방법이 나오게 된 문제상황인 Race Condition과 Critical-Section을 먼저 소개한다. Race condition 두 개 이상의 프로세스가 공유 데이터에 대해서 동시에 접근하고 조작하려하는 상황을 의미한다. 즉 Race라는 뜻 그대로 하나의 자원을 놓고 서로 경쟁하려는 상태이다. 이 공유된 데이터의 마지막 값은 어느 프로세스가 마지막으로 끝내는지에 따라 달려있다. 만약 interleaved execution(서로 번갈가면서 명령어 수행시) 데이터의 무결성이 침해받는다. → 불확실성 이것을 예방하기 위해서, 동시에 진행되는 프로세스는 반드시 동기화가 되어야 한다. Critical-Section 이러한 문제를 임계구역(Critical-Section) 문제라고 한다. 임계구역이란 동일한 자원에 대해서 접근하는 영역을 의미한다.\n해결하기 위해서는, 한 프로세스가 임계구역에 진입해…","frontmatter":{"date":"February 05, 2022","title":"Mutex와 Semaphore","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/mutex-and-semaphore/"}},"next":{"id":"8dc426c1-6ea9-5b2f-9546-c7694d04fcb3","html":"<h2 id=\"tcp\" style=\"position:relative;\"><a href=\"#tcp\" aria-label=\"tcp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP</h2>\n<p><strong>신뢰성 있는 데이터 전송</strong>을 지원하는 <strong>연결 지향형 전송계층</strong> 프로토콜로 <strong>3 way handshake로 연결을 수립</strong>하고 , <strong>4 way handshake로 연결을 해제</strong>한다.</p>\n<ul>\n<li>\n<p><strong>혼잡 제어, 흐름 제어, 오류 제어</strong>등을 통해 <strong>신뢰성을 보장</strong>하지만 이것때문에 UDP와 비교해서 속도가 느리다.</p>\n</li>\n<li>\n<p>또 <strong>SEQ 넘버</strong>와 <strong>ACK 넘버</strong>를 통해서 데이터 흐름 속에서 <strong>데이터들의 순서를 파악</strong>할 수 있기 때문에 신뢰성이 높아진다.</p>\n</li>\n<li>\n<p>인터넷은 신뢰성을 갖추지 못하기 때문에 <strong>종단간의 신뢰성 있는 Byte Stream</strong>을 전송하도록 설계되었다.</p>\n</li>\n<li>\n<p>연결을 유지하며 <strong>1:1 통신</strong>을 한다. 그렇기에 브로드캐스팅과 같은 시스템에선 적합하지 않다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 513px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACHElEQVQoz12SiY6jMAyGef8HW61GI/Wm3Dc0QGkLtJ2WQr9dZ6azR5DlYMW/P8cxAM7nC8fjidOp5XYfJETX9ZRVTZpmNM1Bx57AND15jJM2HXs+dfy1DPkN4pStZWPZDn6UkBQ74jTDCyOCOCHOCm1BkpKrkrysCfNSi32Lfu0N2WRZhrlZs1zMWZtbVmuTHz/ftBfS46EhjkJcx6YqFV3bUlcV0zT9IyifFnyMI7nas3Iz3KJj4Sne1iHroMaKG7L6QtMPXO9PhvHJ+CX0v6Am3O8bnDBlvg1ZuylzM8D0M5xIYYUFSytiZgbftrQj3CgjyXckacZtGL7vT0SNuq51y7ZtEYUhQeDjeS6u65BlKUrtsC1Lx3zfI4pCoiiiKArSvKC7XLler7Rt+0lYVZX+OZ/P9H1P23aEYchms8F1Xe1t28bzPMqyou06uq6j7zvyvODycWOxmGNZ1qvlvT5wOBw4nU44jsNsNmM+n7NYLEjTVHeQJIn2n2K9BtgpxantKEul84dhwIjjWCcLiYitViuWyyXv7++66uPx4H6/s9vtaJpGm3Q1jqOmNS1b55mmqQsaSinEgiDA930tJoTS4na71dchJoQv2jzP9dNRZUWhKo7HI9KpdGhIxdvtpoNyWIYkCUIh+7Is9RCEVihlGAIgdyiCH/cHfy9DepdE8SIqJkki8KKWoYioELzOCIgUe07Tn4f9+9n8Apapf/QQHrtLAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP Header\"\n        title=\"TCP Header\"\n        src=\"/static/953498754a2a0c8bd1a6bf477a853ae6/267f6/1.png\"\n        srcset=\"/static/953498754a2a0c8bd1a6bf477a853ae6/e9ff0/1.png 180w,\n/static/953498754a2a0c8bd1a6bf477a853ae6/f21e7/1.png 360w,\n/static/953498754a2a0c8bd1a6bf477a853ae6/267f6/1.png 513w\"\n        sizes=\"(max-width: 513px) 100vw, 513px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>TCP Header</p>\n</li>\n</ul>\n<h3 id=\"tcp-연결-과정\" style=\"position:relative;\"><a href=\"#tcp-%EC%97%B0%EA%B2%B0-%EA%B3%BC%EC%A0%95\" aria-label=\"tcp 연결 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 연결 과정</h3>\n<p>TCP는 통신을 시작하기전에 연결 수립이 필수적이다. 이것을 통해서 상대방과의 세션을 수립하여 통신의 정확성을 획득할 수 있다.</p>\n<p>클라이언트는 서버에 접속을 요청하고 서버는 요청을 수락하는 ack와 flag가 설정된 패킷을 클라이언트에게 발송한다.</p>\n<ol>\n<li>클라이언트가 서버에 접속을 요청하는 SYN(a)이 설정된 패킷을 보낸다. 이때 클라이언트는 <code class=\"language-text\">SYN_SENT</code></li>\n<li>서버가 클라이언트의 요청인 SYN(a)를 받고 클라이언트에게 요청을 수락한다는 ACK(a+1)과 SYN(b)이 설정된 패킷을 보낸다. 서버는 <code class=\"language-text\">SYN_RCVD</code> 상태</li>\n<li>클라이언트는 서버의 수락 요청에 대한 응답인 ACK(a+1)과 SYN(b) 패킷을 받고, ACK(b+1)을 서버로 보내면 연결이 성립된다. 클라이언트는 <code class=\"language-text\">ESTABLISHED</code> 상태가 되고, 서버는 ACK을 받으면 <code class=\"language-text\">ESTABLISHED</code> 상태가 된다.</li>\n</ol>\n<p>이 과정에서 SYN이나 ACK가 dropped 된다면, 재전송(retransmission)이 일어난다. 만약 3번 과정에 ACK가 drop된다면 그 다음에 데이터를 보낼때 ACK도 같이 담아서 보내면서(piggy-backing) 연결을 수립한다.</p>\n<h3 id=\"2-way-handshake으로-부족한가\" style=\"position:relative;\"><a href=\"#2-way-handshake%EC%9C%BC%EB%A1%9C-%EB%B6%80%EC%A1%B1%ED%95%9C%EA%B0%80\" aria-label=\"2 way handshake으로 부족한가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2 way handshake으로 부족한가?</h3>\n<p>부족하다. TCP는 양방향성 connection이기 때문에, 양쪽의 통신 수립이 필수적이다. 클라이언트와 서버가 있다고 했을때, 클라이언트가 서버에게 SYN을 보내고, 서버가 ACK와 SYN만 보낸다고 하면, 서버 입장에선 제대로 연결되었는지 확인이 불가능하다. 서버의 ACK와 SYN에 대한 클라이언트의 응답인 ACK가 필요하니 3 way handshaking을 해야한다.</p>\n<blockquote>\n<p>💡 초기에 클라이언트에서 보내는 SYN 넘버는 ISN이라는 난수를 생성한다. 그 이유는 이전의 seq와 순차적인 정보를 전송하면, 서버가 판단하기에 이전 연결에서 보내는 정보라고 인식 할 수 있기 때문이다.</p>\n</blockquote>\n<blockquote>\n<p>💡 SYN flooding attack 이라는 공격이 있는데, 간단히 서버에 대해서 SYN 패킷만 무수히 보내는 것을 의미한다. 이것이 왜 유용하냐면, SYN 패킷을 보내면, 서버는 연결을 수립하는 과정이라고 생각해서 SYN/ACK 패킷을 보내고 ACK를 기다리는 half-open 상태에 돌입한다. 이 상태에서 서버는 클라이언트에 대한 정보를 가지고 있어야 하기때문에, 접속자(혹은 접속을 시도하려는) 사람의 정보를 저장하는 Backlog Queue가 꽉 차게 되고(정상적으로 연결이 수립되면 삭제하지만 그렇지 않으니) Backlog Queue가 꽉 차게 되어서 다른 연결 요청 정보 저장이 불가능해서 정상 Client들이 연결을 수립할 수 없게 된다.</p>\n</blockquote>\n<blockquote>\n<p>해결 방법으로는 Backlog Queue를 늘리는 것이 있지만 임시적인 해결책이다. 또 한가지 방법 중 하나는 방화벽에서 동일 클라이언트 IP에 대한 SYN 임계치를 설정해두는 방법이다.</p>\n</blockquote>\n<h3 id=\"tcp-연결-해제-과정\" style=\"position:relative;\"><a href=\"#tcp-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C-%EA%B3%BC%EC%A0%95\" aria-label=\"tcp 연결 해제 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 연결 해제 과정</h3>\n<p>4 way handshake를 통해 TCP는 연결을 해제한다.</p>\n<ol>\n<li>클라이언트가 서버에게 연결을 종료하겠다는 FIN 패킷을 보낸다.</li>\n<li>서버는 클라이언트의 요청에 대한 응답으로 ACK 패킷을 보낸다.</li>\n<li>서버는 자신의 통신이 끝날때까지 기다린다 . <code class=\"language-text\">CLOSE_WAIT</code> 단계다. → Socket Hang UP 에러 발생가능</li>\n<li>처리해야할 통신이 모두 끝났다면 FIN 패킷을 보낸다.</li>\n<li>클라이언트가 FIN에 대한 응답으로 ACK 패킷을 보낸다.</li>\n<li>클라이언트의 ACK 패킷을 받은 서버는 소켓을 닫는다.</li>\n<li>클라이언트가 서버로부터 앚기 받지 않은 데이터가 있을 수 있으니 기다리는 과정을 거친다. <code class=\"language-text\">TIME_WAIT</code> 단계다.</li>\n</ol>\n<blockquote>\n<p>💡 [에러 발생]\n클라이언트에서 FIN 패킷 전송 후 ACK 패킷을 기다리는 FIN_WAIT1과 서버의 ACK 패킷을 받은 후 FIN 패킷을 기다리는 FIN_WAIT2 에러 발생으로 인해 Time out이 되면 스스로 연결을 종료한다.\n그러나, CLOSE_WAIT은 Application이 close()를 적절하게 처리하지 못하면 CLOSE_WAIT 상태로 계속 기다리게 되어 Socket Hang Up 에러가 발생할 수 있다.</p>\n</blockquote>\n<h3 id=\"tcp-상태-다이어그램\" style=\"position:relative;\"><a href=\"#tcp-%EC%83%81%ED%83%9C-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8\" aria-label=\"tcp 상태 다이어그램 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 상태 다이어그램</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 101.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAACJElEQVQ4y22UVw4CMQxEc/97UD7gENyAPxAICZbe29KL0bM0yJRIUbKJPTMum2Rf4/l8vvf3+922260Nh0Pr9Xp2PB5ttVpZnud2u938nnm5XOx8PrtPikACw2Gz2dh6vbbD4eBnrIvFwp0ZrBA8Hg//Zg/JX0CcUQYoE3aMtRfpdDq10+n0joZ9ElCcGoAA3O12rd/vO5EAUYbKH0D7MxQGBrvdziaTiecRcAHKTt/KZUKFAAgDJePx2MNhkhsN9oPBwNrttoPjqxxfr1ebz+eWuJjNZg6y3+9tuVx6RTGEYDQaWafT8TMm9yjBh6JRKCLgnGjegITEQTRiogoAFOCEQkjIKxFwxko7feSQHMSBOhRjCCiAkEKICICw+e5hrzI5xAhjAGJOyVer1bJms2mNRuMjp7HdNJMOUUOfAajWAZgwqCQKyavuYnvFkdQ/qNMgZ1SMQqFczuSWsLmDjCpDpOltgwPJp10UMknHmT1OkYgoKB73FIMi4cvKXSJUgFQxVVXsqMGY9TtMUkEa8EcEwB4yzgDiFBURFoYoIi1M3QMuYtpO/j8hwxhfEMDoOZqbaFRlhNAF+BKBejYRtxobBr11KJB6FS2Sca83ESIAvSixn3DIssyrq39USlCB2vgi6R1Qgch5igbxSQKEIsEOAXtI+OafJgV6zlAHGf7pX6NqTwoqlYoVCgUrlUpWrVZdCcogrtfrVi6XfRaLRavVavYCDkkC0QwH7JEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/14d915aaafcbca805f0c03c7697ec75e/c5bb3/10.png\"\n        srcset=\"/static/14d915aaafcbca805f0c03c7697ec75e/e9ff0/10.png 180w,\n/static/14d915aaafcbca805f0c03c7697ec75e/f21e7/10.png 360w,\n/static/14d915aaafcbca805f0c03c7697ec75e/c5bb3/10.png 680w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>CLOSED, LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSING, CLOSE-WAIT, LAST-ACK 등 상태가 존재한다.</li>\n<li>CLOSED : 연결이 존재하지 않을 때</li>\n<li>LISTEN : 서버에서 SYN이 오는 것을 기다리는 상태.</li>\n<li>SYN-SENT: SYN을 보내고 ACK을 기다리는 상태(클라이언트)</li>\n<li>SYN-RCVD: SYN을 받고 SYN+ACK을 보낸상태(서버)</li>\n<li>ESTABLISHED: ACK을 받게 되면 서버 클라이언트 각각 이 상태로 들어섬</li>\n<li>FIN-WAIT-1: FIN을 클라이언트 쪽에서 보냈을 떄 ACK을 기다리는 상태</li>\n<li>FIN-WAIT-2: 첫번째 FIN에 대한 ACK을 받고 다음 FIN이 날라 올 때까지 기다리는 상태</li>\n<li>CLOSE-WAIT: 첫번째 FIN을 받고 ACK을 보낸 뒤 보낼 데이터들을 보내고 ACK을 받는 상태</li>\n<li>LAST-ACK: 전송이 완료되고 서버쪽에서는 FIN을 보내고 ACK을 기다리는 상태</li>\n<li>TIME-WAIT: FIN이 오고 ACK을 보내준 뒤 일정 시간동안 기다림</li>\n<li>CLOSING: 클라이언트 쪽은 TIME-WAIT이 종료 된 후, 서버쪽은 ACK이 도착한 후 종료된 상태를 의미한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABMUlEQVQoz3WRXU+lMBRF+f9/z4zOg6LOABdooV9QoLRdpvca44y6k52+9Oycs3ZljKauX5ilJntPdAvJe9Q0EY4DUqIoxIhzjs/KOf/zFlVt2/D4WCOEhpxI50k+T6wQBGOI1hKVwg8jo5xYlgU5jsQQPsI+uwohsK4r1liIkXQc5G2je37BTxPJOaKUrL3k4fcTD/f3iKEE7nynahwG/jQtshs4m4ZT6+tWqmk4tL6eX1Ac245S6oYB8GbCyZ7l3U50mP4vVeEiZ8Xcj8RyinXkfUeNgvN9+MYw0zQdl67DGEvwDicuOHm5BhevSlJJKWnbjmnW18HCsGy1SEmwlrQsJGvx/YDWhpQSx779fLIQI3d3v5hne4P834dcWo6RY914ql+p65p98+QUvxRSSnkDnUYcwMJ/QLQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/7b08b665fced5355c0a253de440d426a/37523/2.png\"\n        srcset=\"/static/7b08b665fced5355c0a253de440d426a/e9ff0/2.png 180w,\n/static/7b08b665fced5355c0a253de440d426a/f21e7/2.png 360w,\n/static/7b08b665fced5355c0a253de440d426a/37523/2.png 720w,\n/static/7b08b665fced5355c0a253de440d426a/302a4/2.png 1080w,\n/static/7b08b665fced5355c0a253de440d426a/229ad/2.png 1356w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"tcp의-신뢰성을-위한-방법들\" style=\"position:relative;\"><a href=\"#tcp%EC%9D%98-%EC%8B%A0%EB%A2%B0%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95%EB%93%A4\" aria-label=\"tcp의 신뢰성을 위한 방법들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP의 신뢰성을 위한 방법들</h2>\n<h3 id=\"흐름-제어\" style=\"position:relative;\"><a href=\"#%ED%9D%90%EB%A6%84-%EC%A0%9C%EC%96%B4\" aria-label=\"흐름 제어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>흐름 제어</h3>\n<p><strong>송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법이다.</strong></p>\n<p>수신측이 너무 지나치게 많은 패킷을 받지 않도록 조절하는것이 목적이고, 기본적인 개념은 수신측이 송신측에게 자신의 상태를 피드백한다는 것이다.</p>\n<ul>\n<li>\n<p>수신측이 송신측보다 데이터 속도가 빠르면 문제 없지만, 느릴때 문제가 생김.</p>\n</li>\n<li>\n<p>수신측의 제한된 저장용량를 초과한 이후,즉 버퍼 오버 플로우 후에 도착하는 데이터는 손실될 가능성이 있으며, 손실되면 불필요한 응답과 데이터 전송이 빈번하게 오고감.</p>\n</li>\n<li>\n<p>이를 해결하기 위해서 송신 측의 데이터 전송량을 수신측에 따라서 조절해야한다.</p>\n</li>\n<li>\n<p>해결 방법</p>\n<ul>\n<li><strong>Stop and Wait</strong> : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법. 그렇기에 비효율적이다.\n<ul>\n<li>Timeout을 설정하고, 그 Timeout 안에 ACK를 받지 못하면 실패한것으로 간주, 같은 프레임을 재전송한다.</li>\n<li>만약 이 Timeout이 너무 짧으면, ACK와 상관없이 계속 다시 보낼것이다.</li>\n</ul>\n</li>\n<li><strong>Sliding Window</strong> : Stop and wait의 비효율성을 개선한 기법으로, 수신측에서 설정한 window 크기 만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게하는 방식이다.  (윈도우 크기 = 가장 최근 ACK로 응답한 프레임 수 - 이전에 ACK 프레임을 보낸 프레임 수)\n<ul>\n<li>\n<p>3 way handshaking을 할 때 송신측이 수신측의 window size에 맞게 자신의 window size를 조절한다. TCP 헤더안에 있으니..</p>\n</li>\n<li>\n<p>수신측에서 설정한 윈도우 크기만큼의 세그먼트를 확인 응답없이 보낼 수 있게 하여 동적으로 흐름을 제어하는 방식.</p>\n</li>\n<li>\n<p>송신측이 ACK 를 수신하지 않았더라도 여러개의 패킷들을 보낼 수 있다. (window size만큼 한번에 보내는방식)</p>\n</li>\n<li>\n<p>0,1,2,3,4,5,6가 윈도우 사이즈에 맞을때, 0,1을 보내면 윈도우는 2,3,4,5,6 으로 변한다.</p>\n</li>\n<li>\n<p>ACK를 받게 된다면, 0,1이 정상적으로 수신되었음을 알게되고 윈도우는 옆으로 두칸 이동해(slide) 2,3,4,5,6,7,8로 변한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACkUlEQVQoz4WQ22sTCRSH5y+1CGq9LGotLagPrs+7srAVFi9tbdKmKKu1mUw0tMlOJzGXSeaeuSepaSYsug+rlsLulsy3OC7I7st+cOBwzseB8xPSNCWdpXxGURRkWc7609NTZrOUbP+f4ouOJElomvbVT1ME/mEGXL9zl+Vv75LOZvwfn05OmLu2wPcr9/81F9zxiIJWZ1tTWKmVEJt1/GjAYHzEaDzmw4ffOTk+5vjjR/7640/afp+C3mCrK7NSFal0WgTxkOjtmPFkgtCxLb558Zi53QecKT5ktfYKVTNRuj1UTSeIQhLb5q2uM00SSorMxZ3HnC0+Ym73IYWDfdpdnYNOF820EJLpr/zckFmU8lwt5diq17D8ECOI6PsBQRQRhxG+63E0neL5IYV6lRtSnmviBi9adUwvQPMC/HiAcDieUGo3WSjnuVzOMS+ukVP26fsxRt8limMGrkdgWUymCbbjstNucLWcy/zL4jrPGjK2F+L4AYIbhiitDnekAhdK65wrrvLd6+d0NANV13F9H81yaPX0LKNOT0NutblZ2sz888VVfqy8pN0zvrwcDIaouslPe0Xmi2tcKT1hSczT0A1M2yGMY4aeR2TbJEmCqhuohsUPlR0u7K5m/i1xi6ZuYrsewvBoguH5NE2T25VnXCxvsChton/OJIyJh0N+8zzeOU52UHdcnCDiQNdYerXNpfIGN6VClns4GCLEo0PahonT99hu1JiX1lmQcuxpXXq2TRhFHHoesWUzSRJ6poVq2Zm/dlDhvLTGsrRJtdfDcF0Ey/PZb7yh3urwUv6FRTHHUinPvWqR50qV0WBIf3SIHoS8e/+eRkel1mzxpq3ytLrHgrjBspjn3t4uYlPhb9dw4YUey658AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/a7fa182ff65a69990bb3a15d30f0c098/37523/3.png\"\n        srcset=\"/static/a7fa182ff65a69990bb3a15d30f0c098/e9ff0/3.png 180w,\n/static/a7fa182ff65a69990bb3a15d30f0c098/f21e7/3.png 360w,\n/static/a7fa182ff65a69990bb3a15d30f0c098/37523/3.png 720w,\n/static/a7fa182ff65a69990bb3a15d30f0c098/a0209/3.png 725w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"혼잡-제어\" style=\"position:relative;\"><a href=\"#%ED%98%BC%EC%9E%A1-%EC%A0%9C%EC%96%B4\" aria-label=\"혼잡 제어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>혼잡 제어</h3>\n<p>송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법.</p>\n<ul>\n<li>\n<p>송신측이 네트워크를 통해서 데이터를 전달할때, 라우터가 만약 <strong>데이터가 너무 몰려서(혼잡할때) 모든 데이터를 처리할 수 없게 되고</strong>,</p>\n</li>\n<li>\n<p>송신 측은 다시 데이터를 보내고, 혼잡을 가중시켜서 <strong>오버플로우나 데이터 손실</strong>을 일으키게 된다.</p>\n</li>\n<li>\n<p>그 과정에서 혼잡을 피하기 위해서 <strong>강제로 송신측의 데이터 전송속도를 줄이는데</strong>, 이것을 혼잡제어라 한다.</p>\n</li>\n<li>\n<p>해결방법</p>\n<ul>\n<li><strong>AIMD (Additive Increase / Multiplicative Decrease)</strong>\n<ul>\n<li>\n<p>처음에는 패킷을 하나씩 보내고, <strong>문제없이 도착하면 window size를 1씩 증가</strong>시켜가며(additive increase) 전송하는 방법</p>\n</li>\n<li>\n<p>만약 <strong>패킷 전송에 실패하거나 일정 시간(timeout)을 넘으면, window size를 절반으로 감소</strong>시킨다.</p>\n</li>\n<li>\n<p>이 방식은 fair 한데, 여러 개의 호스트가 네트워크름 공유할때, 처음 보내는 쪽이 1부터 보내기에 불리하지만 나중에는 평형한 상태를 맞추기 때문.</p>\n</li>\n<li>\n<p>하지만 초기에 1씩 보내기때문에 <strong>높은 대역폭을 충분히 사용하지 못하고</strong> , 혼잡상황을 <strong>미리 감지 못해 혼잡이 일어나야지만 대역폭을 줄이는 방식</strong>.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 571px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABS0lEQVQoz4VSa2/DIAzM//+HzYc066Q90oeSAMG8fJOBZmnaaUiWrcOcz8YNjyMQI7xSsNMEeA8mWg3/xOJhLcAMHA5oEAImrXG5XuG8hxyu9lfMe5xr1PdogigjglYKzrlNAme/t0yziTOeUnnXdWje2xbkPaK07WjVYgLj5hKwU3F1CTaW2KWqLKWi9nhEM5xOGM5nfA8DBlMU6sCYfSFVgbFUAsGEMKSCn6kUtKEqFMKPrkOq1QdloaM8LAkXSviyKRPOgUGRsyrBdS02eYaLG8JT2+I2jtDThE9FmALWccsDaU+UUFUpXvBc0FWcNy1/dkfMSkHNMwz9fsp9ZuJ94ofPesrZzlB+ucw1wREBuzV5dZ7wO7EQ5qUEEEKA1jqvDhE9mLUWxpgnfL03BkuMZQ95WUpF5qxyb9KWEL71fS7Gr/JCQKwt/wBHqV6ZrwSuSAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/181e79cc6fd911904f2e6f2182b505dc/17d73/4.png\"\n        srcset=\"/static/181e79cc6fd911904f2e6f2182b505dc/e9ff0/4.png 180w,\n/static/181e79cc6fd911904f2e6f2182b505dc/f21e7/4.png 360w,\n/static/181e79cc6fd911904f2e6f2182b505dc/17d73/4.png 571w\"\n        sizes=\"(max-width: 571px) 100vw, 571px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ul>\n</li>\n<li><strong>Slow Start</strong>\n<ul>\n<li>\n<p>AIMD 방식이 전송 속도를 올리는데 있어서 오래걸리는 단점(1씩 증가하기 때문에)이 있기에 이것을 개선하는 방식.</p>\n</li>\n<li>\n<p>AIMD와 마찬가지로 1개의 패킷을 보내면서 시작하지만, <strong>문제없이 도착하면 window size를 2배로 늘려준다.</strong></p>\n</li>\n<li>\n<p>혼잡현상이 발생하면, window size를 1로 떨어트림.</p>\n</li>\n<li>\n<p>처음에는 네트워크에서 혼잡을 유발하는 window size를 알 수 없지만, 한번 혼잡현상이 발생하면 <strong>최대 수용량에 대한 유추</strong>가 가능해지기에, 그 window size의 <strong>절반까지는 이전처럼 2배</strong>로 증가하되, <strong>그 이후부터는 완만하게 1씩 증가시키는 방식</strong>을 택함.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABOUlEQVQ4y32T3a6CMBCE+/7PRngAbpALEiQq8iMoIHvyNRmznKBNNgzTdnZ32gYzs2maLMsyO51O1nUdlG3bZt/Gr7nwfr9tGAa73+/W931cDOcDzvO/RKPg+Xy2y+Vi8zzbuq62LMsuXq+XjeMYE/OVoEQ9DgAEy7KMi0ngxeAQJBEDTgJeSMIB8Hw+Y7ts9BkJeD8QPPJUVgQyqyoJyjfmaNP7xxrvLTZRkDoIVJDnudV1HTd7Dx+PRwxvATfCz/uKPy2rFWXxlYjT0D+VSWx3KCIwnzvIl9CJg48O6ZuXQcoI0AJ+gNkElrgq4p+2NU8If66NBPGQxQgLX69Xu91usXqwv/xqv21bq6pqL6hT48UURREPCgwHTpLE0jSNif6/FIQpaOeh94EFhHjapLqmaXZP7+hi/wGkevyCQ2w6eQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/b5a0f766ca5141b8507f01d57bef6c5a/37523/5.png\"\n        srcset=\"/static/b5a0f766ca5141b8507f01d57bef6c5a/e9ff0/5.png 180w,\n/static/b5a0f766ca5141b8507f01d57bef6c5a/f21e7/5.png 360w,\n/static/b5a0f766ca5141b8507f01d57bef6c5a/37523/5.png 720w,\n/static/b5a0f766ca5141b8507f01d57bef6c5a/84cc5/5.png 898w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>임계값(ssthresh)단계에서 부터는 <strong>혼잡회피</strong>(Congestion Avoidance)를 사용한다.</p>\n</li>\n</ul>\n</li>\n<li><strong>혼잡 회피 (Congestion Avoidance)</strong>\n<ul>\n<li>window size가 임계값에 도달한 이후부터는 조만간 혼잡이 발생해 데이터 손실 발생 확률이 커지기 때문에 조심스럽게 접근한다.</li>\n<li>window size를 linear하게 1씩 증가시키는 방법을 사용.</li>\n<li>만약 혼잡이 발생했을 경우에, window size를 1로 줄이고, 임계값을 손실 발생했을때의 window size(W)의 절반인 W/2로 줄임.</li>\n</ul>\n</li>\n<li><strong>Fast Retransmit (빠른 재전송)</strong>\n<ul>\n<li>수신측은 순서대로 잘 도착한 마지막 패킷의 다음 번호를 ACK로 보내기 때문에, <strong>중간에 손실이 있을시에는 중복된 ACK</strong>를 받게 된다.</li>\n<li>이것을 감지하면, 문제가 되는 순번의 패킷을(<strong>SR</strong>) 재전송 해줄수 있다.(혹은 문제 지점부터 싹 다시보내거나,<strong>GBN</strong>)</li>\n<li><strong>3 ACK Duplicated</strong>, 즉 송신 측이 <strong>3번 이상 중복</strong>된 승인 번호를 받으면 혼잡이라고 인식한다.</li>\n<li>이때는 <strong>설정된 타임아웃이 지나지 않아도</strong> 해당 패킷을 재전송할 수 있다. (GBN or SR)</li>\n<li>이 방법으로 설정한 타임아웃 시간이 지나서야 대처하는 <strong>기존의 방법보다 낭비되는 시간을 줄일 수 있다.</strong></li>\n</ul>\n</li>\n<li><strong>Fast Recovery</strong> (빠른 회복)\n<ul>\n<li>TCP Tahoe : 초기 버전으로 타임아웃이 되거나 3 dup ack가 발생시 W를 1로 줄이고 slow start로 들어간다.</li>\n<li>TCP Reno : 개선 버전이다. Tahoe가 무조건 W를 1로 줄이기에 대역폭을 온전히 사용 못할 수 있다. 그렇기에 <strong>3 Dup ACK는 조금 덜한 혼잡이라고 본다.</strong>\n<ul>\n<li>3 Dup ACK : 현재 W의 절반으로 W를 줄이고, 1씩 linear하게 증가시킨다. 이때 임계점을 현재 W의 절반으로 설정한다.</li>\n<li>Timeout : Tahoe와 마찬가지로 W를 1로 줄이고 slow start 한다. 임계점을 수정하지 않는다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"오류-제어\" style=\"position:relative;\"><a href=\"#%EC%98%A4%EB%A5%98-%EC%A0%9C%EC%96%B4\" aria-label=\"오류 제어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>오류 제어</h3>\n<p>기본적으로 TCP는 ARQ(Automatic Repeat Request), <strong>재전송 기반 오류제어</strong>를 사용한다. 뭔가 오류가 생기면, 송신측이 수신측에게 해당 데이터를 다시 전송하는 방법이다.</p>\n<p>그렇지만 이 재전송이라는 작업 자체가 했던 일을 다시 해야하는 비효율적인 방법이기 때문에, 이 재전송 과정을 최대한 줄일 수 있는 방법을 사용한다.</p>\n<p><strong>오류가 발생했다는것은 어떻게 알까?</strong></p>\n<ul>\n<li>NACK(부정 응답) : 더 명확해보이지만, 수신측에서 ACK/NACK를 선택하는 추가적인 과정이 필요하다.</li>\n<li>ACK가 오지 않음 : 수신측이 아예 데이터를 받지 못해 ACK를 못 보내거나, 수신 측이 제대로 응답했지만 ACK가 유실(lose)되는 경우</li>\n<li>중복된 ACK\n<ul>\n<li>\n<p>송신측이 SEQ 2를 가지는 데이터를 이미 보냈는데도, 수신 측에서 이번엔 2번을 보내달라고 하면 문제가 생겼음을 알 수 있다.</p>\n</li>\n<li>\n<p>중복된 ACK 한 두번으로는 판단하지 않고, 3번 정도 받았을때 오류로 판단. 그 이유는 TCP가 중복된 ACK를 받앗을때 패킷 로스인지, 세그먼트들의 순서가 reordering 되는건지 명확히 알 수 없기 때문에 3번까지 보는것. 순서가 뒤집히는 이유는 TCP 아래 계층에서 라우팅 하는 단계에서 다른 경로를 택할수도 있기 때문.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEElEQVQoz32Sy03EUAxFj/Py/xANhP8CFkhIg1iwASqgByqgFjqhCZZUQStIIMeOEp4mY+lKdmJf+9oPZjsFnoCedTsDHoHr6YPEGTnQADVIgJMAVQZBotxF0MkiFvbbAFTKX1qfAigFgtYmllOsNDL7An4N8gbDK5R348DkiZFWLkJRAle6FmXNdhG+O+knyAsMH9D+QP0NB1qTQiXQutRD4EZ3KfPEe6Vr905xD0c6pUAhkCa218wP08ckEjuF+Zcbmypzsma+2Sg9cbJE7H/upZNvhItOrRfFMlKxwm4h+VyBQeOL8WUI9GKJG+DYuytBtkCo/Qh+9XiQf/4WeACegVsnk+kd7ihuuhVCHfUPpiwPGu3xgg8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/1ae8dfe469955be626d9d833c383aa80/6af66/6.png\"\n        srcset=\"/static/1ae8dfe469955be626d9d833c383aa80/e9ff0/6.png 180w,\n/static/1ae8dfe469955be626d9d833c383aa80/f21e7/6.png 360w,\n/static/1ae8dfe469955be626d9d833c383aa80/6af66/6.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ul>\n</li>\n<li><a href=\"https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/\">해결 방법</a>\n<ul>\n<li>Stop and wait : 흐름 제어때도 나왔엇지만, 제대로 받았다는 응답이 올때까지 대기하고 그 다음 데이터를 보내는 방식.\n<ul>\n<li>\n<p>아주 기본적으로 오류 제어가 가능하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 120%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAAEPElEQVQ4y4VVbUscVxR+7p0Zd3Vf3N3UrHHNatJYNWlppCURRNTahn4t5IOQkn5JG1JB0hQhKZQoBJovxZImqaCiICkkLOtLpKxkV2Zd3cUJtuAL6GxcHcEfEDFf2uiUMzNr12SlFy535r6ce87zPOdc4L9WD+AzAK0ACrKTDofDGOOyjHQ6DVVVMT8/T1PM2vIhgAsAGgE05NhDIYAggHcExozd1EVRNBZ1XTfGmupqvNFsAI4CCAAoPrDCAJfVndYoCZyTRSG7p9Tvz+4FZ6aTEuf0X4Q8zQXAzhgTGCByxpw11dVegmBwcPDzX+/do5AKPmlpsdE6dTokmgadLI9BN3kjCKZDwePHMTw8jMnJSYyMjLi7u7uLrNBtRgSMURQE1QlyPp+HzizYLS0tBm5ra2snlpaWajVNO7m1tfXuyspKzerqasDaLwicFzKghAFH8nlItxwNBoMUivTV5cvOTCbzNJPJLCeTyb9SqdSfsiyvRCKRAUsJ4nfXr5MHgoX5W+2IFbaBu8/jYbu7u3Zd1+3T09NFiUSiMJ1O21VVLaivr889d6hBDzOpFzhjBKQw0N+P3t5ehEIhjI+P45eeHuO/rKzMOMBNiRFB7rykEMgWY/TtLg8E6AL70NDQuXA4fIpwbWhokHiOVhnADvPQldWcwLkxcevmTTudGRsbO9fX1/cREVd39qyPM+a2LnVYgvYepkPR5XKh6/ZtdHV1YXFxEcvLy5BlGfF4HOFwGKOjo0a0dpstK/iDsqFZKx2clQD/+epVg5Tv29vF9fX1bzOZzF1FUe4sLCzckWX57tTUVHtzUxOlnOR2uyl8Ww6ZyE30UiMnz5yheCXqay9e/LipaQPK3Nxvs7OzD2VZHohGoz98eekS+cHq6uoIP+ktDP1mufH+xFiJDjD94kVJn5srXIvHkXn+HMqjR5h+9gx/RCKYmJhAW1ubWRkKjMIk5hosY2a18DsAt15aKr0C7K9u3Dj1dzj8zSZQ+LK5+cjLysrAyrVrtiFNE54+fix0dnbmhnfAYDmADxhQbTDFuTDt94Po1F+/FnWA61VVXAeK/6FvKnpFRfuSyWcw9ya3APicnLu4CbITDgdhyT9OpSRd13nt+fP7oDNLixaneUkh2RAhTBIE8ZjXK75/+jRtFENPnnzR39fXQkSVBwKUUQVWDme78zBhS9wSdUVFBR4+eICenp7sOs9WbnodmCluKl8n/7d8VQSDxoSqqq5EIuFVFMW9t7fnUlW1eGFx0XGrowOd9++jq6MDVpb48hmkmuYJlpcbGvz6yhWntrExtbGxsakoSlpRFHVmZmYrGo3+bunU5vV4JMaYeFguHwNQkg3vvaoqrmmaZ2dnx5dMJr2hUMgbi8V8kUjE1dTY+Gb5ylttjIdGtJ6A2poaaJqG7e1tpJJJegYQi8UQiUTwaWureav5nuyT8i8i/kEjJwSK5wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/d56b1d2af5a3dbf6de16fd6ecc8c5243/6af66/7.png\"\n        srcset=\"/static/d56b1d2af5a3dbf6de16fd6ecc8c5243/e9ff0/7.png 180w,\n/static/d56b1d2af5a3dbf6de16fd6ecc8c5243/f21e7/7.png 360w,\n/static/d56b1d2af5a3dbf6de16fd6ecc8c5243/6af66/7.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>하지만 흐름 제어에 sliding window 방법을 사용하다면 데이터를 연속적으로 보내기 위함인데, 이런 방식으로 오류 제어를 사용하면, 그 이점을 잃는다.</p>\n</li>\n</ul>\n</li>\n<li><strong>Go Back N (GBN)</strong>\n<ul>\n<li>\n<p>데이터를 <strong>연속적</strong>으로 보내다가, <strong>어느 데이터부터 오류가 발생했는지 검사</strong>하는 방식.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 133.33333333333331%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFF0lEQVRIx5VVb0wTZxx+rn+uPdr7VwRtKozWjYLAWCJbZkSnzAQXTRazbF/clxljtsws8+OW+cEok1iJftGMGROIjI2FxgU0gEANRyCBpkVWikv4I51FF6eJdahAte/yXu/YoW7J3uSXe++995577vc8v98LALUAtgN4F4AF/2+wAN4DsBVADYA36WIhgBIAnud38zyvXs+ePcvU19ejsbERgUDAuIUBsBbAawB8APL1By4AZgCc9lV1yLKsXk+dOoUjR46gpaUFe/bseRlTEwCbccENQATgBCBoc9HhcFCKbDAYfLupqcl1+/Zt1NbWMi8BtGvvrgxKm9cW6dVBw+VySQCsHR0dXxw/fvx1+qIgCJL+XAsY3l3FUDAwVEHdbrfKMBKJfNLV1eWn4GvWrOENe3WgSgCSEVDSFOYM9EWNIdvb2/t5Q0NDOZ3n5uY6tec6oF0TVTQCyivZNZlACKHBEEJosi0tLS01J0+epC5wer1e2ePxyDabTTAwfQHQ1dTUpE7WrVuHeDyO9vZ2RKNRDCoKfrl0Cc3NzRgYGEAwGEQ4HKZbzbIsW7U/22gEZLQvqaOmpga/3bhR3tPT887ExMSWRCJRPT4+vm1gYGDr3Nxc9cTERPWv4+PVHR0dqmAej8eiibNKFC/LsrzdbqceZPv7+3++fPnyn7FY7Obk5GRCUZREd3d34vr164mrV68m+vr6fm9tba2iqVEUhVkFaM5S3GDXKJds3kzzZyKEWAkhrBY2Gnfv3mVTqZS+hr179xp9mLXQgexC3opqDKMrbXmQFQc/dXWhvqEBBw8exPfnz+PRo0c4evSoWklURM0dWUBitWIbsDbDMM5BgC8G+FybzSlynIi8PKo+19zW9vE3x469StPxxqZNVmXfPuYzSWJgNusdwmwwObAZWDsPOBKAgzAMTxjGqUZ+Pk8Ay83+/k9bA4FSKoLI85KmqG4Zyu4Vo7CqW/T61SvFAQg/ulziB4Al09t7gAQCJQRgiSTRDzoI4PwWELYAdg9QxgESp6OZqbGlbOXs2rGDrfD7c4rLyji2uJgucj+0t39Zd+aMWsvbi4pcnQUFQrCoyPmX2y0Ss5kjQMn7gPiRsVK06kAymcTo6Cgi0Si+u3gRjc3NeDA/T1mrymq+tWnBaVGxYmyqEsuyroWFBQooEEKKCCEFhJDCkZGRQkVRCtva2tz37t3zzMzOrk/eurWeEJKNZ8/Wf7hzJ/Wux2QyZXPodDpRUVGROzU1heXl5a+XlpZIJpN5kkql0teuXUuHw+F0KBR6GovFng4PD6enp6fThJD08vIySafTf4yNjdHmbJcliV/5X1EUafth4/H4V7FYjIyOji4MDw8vRqPRxVgstnhjcnKJzkOh0GIkElns6+t7oijKs8HBwXlCCFXaIoriP6VntVppJ7E/fPgw7/79+5Wzs7NlTx4/Ls1kMqWpVKosmUz679y5s3FmZqZ8bGysPBwOl0/G4xVDQ0OlWl7tJpNpVS3n5+Tk6J3aajj9aAlibm7OQa8jIyOgXenChQsIhUIYGhqCz+ejOnDPNwfVh7IsC36/XygoKJC8Xq9YVVVFleM6OzsP1dXVqbaprKwUfD6fsHv3bvbw4cNmjaF1VaUYGqzRCoLWsW1Xrlw5dPr06TI1+bKs/4leCHRe+kKD/beTnDIIBoNvnThxgp65rM1mW1VRAHIAlD8PKP4X4Llz57B//371XhAE41ls1zrgBr2W/wYX1/Gyu6WsjgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/fd76c98eb405aa86b06b058d9687e54d/6af66/8.png\"\n        srcset=\"/static/fd76c98eb405aa86b06b058d9687e54d/e9ff0/8.png 180w,\n/static/fd76c98eb405aa86b06b058d9687e54d/f21e7/8.png 360w,\n/static/fd76c98eb405aa86b06b058d9687e54d/6af66/8.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>데이터를 연속적으로 보낸 후 한개의 ACK 혹은 NACK(오류 제어에선 설명의 간단함을 위해서 NACK로 사용)만으로 오류 파악이 가능하니, 슬라이딩 윈도우와 찰떡 (sliding window가 네트워크 대역폭의 이용률을 높이기 위해서 다른 프레임을 보내기전에 ACK를 요구하지 않는데 )</p>\n</li>\n<li>\n<p>만약 4번 데이터에서 에러를 감지하면, 수신측은 4번 데이터 이후 받은 모든 데이터를 폐기후 송신측에 알리는 방식이다.</p>\n<blockquote>\n<p>왜 데이터들을 다 폐기할까?</p>\n</blockquote>\n<blockquote>\n<p>수신자의 버퍼관리가 간단하다. 결국에 수신자도 상위 계층에 데이터를 전달하는 입장인데, 순서가 잘못 넘어온 데이터에 대해서(n+1만 오고, n은 오지 않음) 버퍼링을 할 필요가 없기 때문이다.</p>\n</blockquote>\n</li>\n<li>\n<p>송신측은 5번까지 이미 전송을 했지만, 4번 데이터에서 에러가 났다는것을 알았기에 4번으로 되돌아가서(Go Back) 다시 전송해야 한다.</p>\n</li>\n<li>\n<p>ACK이 누적적(cumulative)이다.</p>\n</li>\n<li>\n<p>SR에 비해서 구현이 간단하지만, GBN의 특성상 같은 데이터가 계속 오갈 수 있으니 대역폭을 효율적으로 사용하지 못한다.</p>\n</li>\n<li>\n<p>또 SR에 비해서 버퍼사이즈를 크게 잡을 수 있는데 시퀀스 넘버가 n비트일때 <code class=\"language-text\">2^n-1</code>개의 window 사이즈를 가질 수 있다. 왜 1을 빼냐면,</p>\n</li>\n</ul>\n</li>\n<li><strong>Selective Repeat (SR)</strong>\n<ul>\n<li>\n<p><strong>오류가 난 데이터만</strong> <strong>선택적인 재전송</strong>을 의미한다. GBN이 stop and wait에 비하면 효율적이지만, 에러가 발생하면 그 이후 정상적으로 받은 데이터를 모두 폐기처분하니, 재전송해야하는 비효율이 아직 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 153.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAYAAADnTu3OAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGeElEQVRIx3VWbWxT5xV+ju3rj9jX38QhWVPclQQWUKtuYlvYplWsVG2nIrUVICoBZrAJjR9TpK4wTQWGUCYSZSAxijQFMRBOGholdj5sYxu7xrFjO76245AoMCPB8iM/2NYAmwQsvtN7fR0M217p6L733nOf8/E+55wLAt4jop8AeIcANeRFADRqNc6fP4+nT59ieXkZ5XJZkpqlBfBTAt4koq0EfA9E5CCiV4hoFRGxe7y6erUE2NjYKH114sQJ6ujoQH9/Pza3t9cCMjULAWuI6BtEZJYAANiISE1EeiLSKBgwQG1tbVVAHDp0CKIoYrVsrCry4lhA0k7BXhA1EJFJBjTKexPP80amePXq1TfPf/55PQNcv369cgWQqDZ0fcXnijf1RMQTkaFG9KvsdhMA1cjIyKGTJ09uZB+aTCZzrZ5SoWCoVgCGFUAADtkrXvaQib6xsZEHoM4Jwl6fz9fCQltlt/Oynr7qBIDXABhrk2smQMHyV5NLo73ioXp8fPyXnZ2dG9jeZrMZaqNREOkArAfA1wJaqhuNRiMlXxaWYqX7ypVNPT09DhZWa2urxel0mnVaLTNmUlQ8/P+AO3fuxOTkJC5fvixdmXg8Hly8eBEBv196PjIyIuk2v/SSihkEsO5FQCn+ewsLuNDbi1wu96PR0dGPC4XC9lKptD2TyewMh0I7bt++vSOTyexIpVLbv+jvr2cpeMXpVFHlhA21gN9UqVTWVXY7qxQuHA73jo+Pl2ZmZgqzs7PFG7HYzLVr12by+XyRXUOhUNHtdm+cn5+XUiNTpkIb2eeX6wDTX1Uq6dlelwuvv/EGjh49ikuXLknE3r17NyKRCP7Q04Njx46hq6sLR44cAccxTkO3AogKbexyDowg0kOj4UGke2ftWuXbra2qf549S7XhLFe8ql11K4AiEd4DHCKR4QkR/zER/zbH6V/nOCNsNnZY2j8PDPys47PPWhkJrE6n5gcWi7JFqVRCqZQwrICUR8nqRSK0APV/JDL8iUgvEvEMXBKHgxcB7utI5MBX3d0MkPsWz7MGYJQPshIRsPbZKcuVAiKTrFAVU4fNJpXe3/3+/WJXV6sIqEWLZcWgn4g/S6T9MdBmBYzWKqACMMvA2ECkWE3E6YlUaGhgVFBf/vLLg590drLWo603Gs0HiAwfEelDREaRSPeAaN1mgP9hLbH1ejmncoXIQtL9gwf633/6qe7A+++rt777rtbW0mLWOBwmKcxKyP9dyxs3bMDp06fxu+PHceHCBYyNjSEajSKbzSKRSGBgYAButxtX3G509/TgVx0dkvE1gFLHmgtgUNQAWvfv368YHh5mH60ZHh4eCgQCI8lk0jM9Pe1NJpPeUCjkjUaj3kwmMzQ6OhrxeDy/YIAffvABpyDiX6yUNovZ3MQUBEH4/q1bt4YzmcxgPp8fLBQKg+l0ejAWiw3mcrnBVCp1NZvN+kql0idPnjyptGuOe0ZsVWWOWMfGxjgGWC6Xf/v48WMxk8ncz+VyS4lEYimfzy9dv359aXZ2dmlqaurrxcXFf4miWNqzZw/jqbJOp7M+5yERrWtoaGhkky0QCPwmGAyKOUH4x82bNx8yEQThUTwefxiLxR76/f6leDz+OBgMzv3t/n1u165dMBgMuudGAICGOp2ODRlFX1+f4d/LyzZRFC2PHj2ylstl68LCAn/37l1rNpu1M4lEIna/z2etzikiqntxprBaNnEcZ5YZX1VQszSEw+HmZDKpYGOU9cVz586hs7Pzf9ey3C3M1TcMYHN7O7f1rbdU3920iSnVeTyeX586dYqVHt/U1GRrbm7WO51OrZa1d7nRrwAeO35cIva2bdsYDxVer5cRGvfu3SO510lG9u3bp9iyZYuqvb1d5XA4eIvFYrJaLGbeYGCE/s5zHVuj0VjOnDkjtftYLCb1wO7ubgwNDSGTyWBiYgJerxd9fX0S+bu7unD48GGpJzJjao6zrZwyKy/WIH0+37fn5uYK09PTQjAYFAKBgHRNJBJCLpcTCoWCJOFwWIhGo7mJiYmpQCDwl3A4fJKxr6mp6bmZ0nrw4MHXFhcX99y5c8clCILrxo0brmKx6GL3pVLJNT8/75qbnXWl0+nq+72Tk5M/T6fT7GdHZTabn/HQaDQa2F8WmxEzMzPsVKVw4/E4isUiCoUCslNTSKVS8Pv90ihgtc72vb29sFqt7FdEyyj4HyJ4pBLfSDVHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/6b0a57c890dd50ed0bc71f39ea3826c8/6af66/9.png\"\n        srcset=\"/static/6b0a57c890dd50ed0bc71f39ea3826c8/e9ff0/9.png 180w,\n/static/6b0a57c890dd50ed0bc71f39ea3826c8/f21e7/9.png 360w,\n/static/6b0a57c890dd50ed0bc71f39ea3826c8/6af66/9.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>문제가 있는 데이터만 재전송하니 효율적이고 만능처럼 보이지만, 버퍼에 데이터들이 연속적이지 않다는 문제점이 있다.</p>\n</li>\n<li>\n<p>위 예시에서 데이터는 <code class=\"language-text\">0,1,2,3,5</code> 가 들어있다가 4를 재전송 받게 되면, <code class=\"language-text\">0,1,2,3,5,4</code> 의 데이터가 들어있다.</p>\n</li>\n<li>\n<p>기존의 버퍼 안에서 데이터를 정렬할 수 없으니, <strong>별도의 버퍼</strong>를 두어서 그 안에서 재정렬을 해줘야 한다.</p>\n</li>\n<li>\n<p>GBN에 비해서 재전송이 적다는 점에서 효율적이지만, 추가적인 로직이 필요해서 복잡하고, 별도의 버퍼를 관리하는데 드는 비용이 있다.</p>\n</li>\n<li>\n<p>ACK이 각각(individual)이다. (사진상으로는 안그런것처럼 보이지만)</p>\n</li>\n<li>\n<p>시퀀스 넘버가 n비트 일때 <code class=\"language-text\">2^(n/2)</code>개 이하의 window size로 제한되어 있다. 만약 <code class=\"language-text\">2^(n/2)</code>이라고 해보자. 그럼 뒤의 절반이 왔을때, 나머지 앞 절반이 안오면 뒤의 절반을 추가 버퍼에 가지고 있을텐데, 안 온 부분에 대해서</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"udp\" style=\"position:relative;\"><a href=\"#udp\" aria-label=\"udp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UDP</h2>\n<p><strong>비연결형</strong> 서비스를 지원하는 전송계층 프로토콜이다. 사전에 연결 설정을 하지 않은 <strong>데이터그램 방식</strong>으로 데이터를 전달한다.\n별도의 <strong>연결을 수립하지 않고</strong> 보내기 때문에, 각각의 패킷은 서로 다른 경로를 통해서 전송될 수 있고 각각은 독립적이고 그렇기에 패킷에 <strong>순서를 부여하진 않는다</strong>.</p>\n<p>실제로 UDP 헤더 부분을 보면 아래와 같이 받는 포트와 보내는 포트 정보, UDP 길이, checksum으로만 구성되어 있는 8Byte 구조이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAxklEQVQY031QywqEMAzs/3+XHgS96cmDq+AT7Cqira06y2QR9rBYCEkz08mkalkWbNuGfd/R9z3qukbbtmDfe495ntE0jeDDMKAsS+Gwp7XGcRySyTvPE8oYA+ecRJqmSJIEcRyj6zohG2uwrqvUWZYhCAJEUYQwDFFVFa7rAjWI8a4283XnvBNnnJznOcZxFIfE7G6lpkPijFf5ElfsW2sxTZMMVVz36XCdoigeOfdgHkV1NqjO/Bv8Ew7Ub/0Xv99RjDUFP+dVf1O7Fq+kAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/65aaeaa3dad7457ddaa7e1ec70cc801a/37523/11.png\"\n        srcset=\"/static/65aaeaa3dad7457ddaa7e1ec70cc801a/e9ff0/11.png 180w,\n/static/65aaeaa3dad7457ddaa7e1ec70cc801a/f21e7/11.png 360w,\n/static/65aaeaa3dad7457ddaa7e1ec70cc801a/37523/11.png 720w,\n/static/65aaeaa3dad7457ddaa7e1ec70cc801a/a0209/11.png 725w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>UDP는 TCP와 달리 흐름제어, 오류제어 , 손상된 세그먼트에 대한 <strong>재전송을 하지 않는다.</strong></li>\n<li>오직 Checksum 필드를 통해서 <strong>최소한의 오류만 검출</strong>하기 때문에 신뢰성이 TCP에 비해서 낮은 편이지만, 이 때문에 TCP에 비해서 <strong>속도가 빠르다.</strong></li>\n<li>그렇기에 신뢰성 보다는 <strong>연속성이 중요한 서비스</strong> , 예를 들어 실시간 서비스에서 자주 사용된다.</li>\n<li>TCP가 소켓을 open해서 통신하는 구조에 반해서 UDP는 오직 IP를 기반으로만 데이터를 전송한다.</li>\n<li>흐름제어가 없기 때문에, 패킷이 제대로 전송되었는지, 오류가 없는지는 확인할 수 없다.</li>\n</ul>\n<p>또 대표적으로 UDP를 사용하는 서비스가 DNS인데(모든 DNS가 UDP만 쓰는것은 아니다.) 아래 이유로 사용된다.</p>\n<ul>\n<li>3way handshake와 같은 연결 수립 과정이 없기 때문에, <strong>연결 설정에 드는 비용이 없어 빠르다</strong>.</li>\n<li>연결 상태를 유지하는 TCP의 특성상 버퍼에 대한 정보,혼잡제어 정보, seq,ack 번호와 같은 정보를 저장해야하기에  <strong>UDP가 더 많은 클라이언트를 수용할 수 있다.</strong></li>\n<li><strong>DNS의 레코드는 일반적으로 작아서</strong> UDP 세그먼트에 어울린다. (50-550 Byte)</li>\n<li>UDP가 신뢰성이 없긴 하지만, DNS가 더 상위계층(application layer)의 프로토콜이니 <strong>만약 응답이 오지 않는 경우에서는 다시 전송하도록 지시할 수 있다.</strong></li>\n</ul>\n<p>단, DNS의 응답의 크기가 512Byte 보다 크거나, zone transfer(DNS 레코드를 primary에서 secondary로 옮기는 작업)을 할때에는, 데이터의 정합성 검사를 위해서 TCP를 사용한다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#tcp\">TCP</a></p>\n<ul>\n<li><a href=\"#tcp-%EC%97%B0%EA%B2%B0-%EA%B3%BC%EC%A0%95\">TCP 연결 과정</a></li>\n<li><a href=\"#2-way-handshake%EC%9C%BC%EB%A1%9C-%EB%B6%80%EC%A1%B1%ED%95%9C%EA%B0%80\">2 way handshake으로 부족한가?</a></li>\n<li><a href=\"#tcp-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C-%EA%B3%BC%EC%A0%95\">TCP 연결 해제 과정</a></li>\n<li><a href=\"#tcp-%EC%83%81%ED%83%9C-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8\">TCP 상태 다이어그램</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#tcp%EC%9D%98-%EC%8B%A0%EB%A2%B0%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95%EB%93%A4\">TCP의 신뢰성을 위한 방법들</a></p>\n<ul>\n<li><a href=\"#%ED%9D%90%EB%A6%84-%EC%A0%9C%EC%96%B4\">흐름 제어</a></li>\n<li><a href=\"#%ED%98%BC%EC%9E%A1-%EC%A0%9C%EC%96%B4\">혼잡 제어</a></li>\n<li><a href=\"#%EC%98%A4%EB%A5%98-%EC%A0%9C%EC%96%B4\">오류 제어</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#udp\">UDP</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"February 05, 2022","title":"TCP와 UDP","categories":"네트워크","author":"weasel","emoji":"📓"},"fields":{"slug":"/tcp-and-udp/"}},"prev":{"id":"01585043-5594-5707-8533-9be6484f7713","html":"<h2 id=\"지역성\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EC%97%AD%EC%84%B1\" aria-label=\"지역성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>지역성</h2>\n<p>페이지 교체 알고리즘에 대해 언급하기 전에 먼저 <strong>지역성</strong>이라는 것에 대해서 알아야 한다.</p>\n<ul>\n<li><strong>시간 지역성</strong> (Temporal Locality ) : 현재 참조된 메모리가 <strong>가까운 미래내에 참조</strong>될 가능성이 높음\n<ul>\n<li>loop,subroutine,stack</li>\n</ul>\n</li>\n<li><strong>공간 지역성</strong> (Spatial Locality) : 하나의 메모리가 참조되면 <strong>주변의 메모리가 참조</strong>될 가능성이 높음\n<ul>\n<li>Array 순회, 명령어의 순차실행</li>\n</ul>\n</li>\n</ul>\n<p>프로그램의 메모리 참조는 고도의 지역성을 가진다. 임의의 시간 Δt 내에 프로그램의 <strong>일부분만을 집중적으로 참조</strong>한다는 것이다.<br>\n이러한 지역성이 있기 때문에 적절한 페이지 교체 알고리즘이 중요하다.</p>\n<p>왜 중요할까?<br>\n예를 들어서 주기적으로 두개의 페이지만 참조하는 로직이 있다고 해보자.<br>\n만약 그 두개의 페이지를 번갈아가면서 교체를 한다면, 페이지 폴트는 두 개의 페이지에 대해서 접근할때마다 계속 일어날 것이다.</p>\n<p>이게 왜 위험하냐면, <strong>불필요한 I/O 작업의 오버헤드도 있고, 그때마다 컨텍스트 스위칭</strong>이 계속 일어나기 때문이다.</p>\n<h2 id=\"페이지-교체-알고리즘\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"페이지 교체 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 교체 알고리즘</h2>\n<p>페이지 폴트가 났을때, 메모리에 빈공간이 있으면 올리면 되는 일이다. 물론 I/O가 들어가긴 하지만.\n근데 만약 <strong>모든 메모리가 사용중</strong>이라면 교체될 페이지를 골라야하는데, 이걸 잘 고르는게 성능에 큰 영향을 미친다.</p>\n<p>그러므로 원하는 것은 <strong>가장 낮은 페이지 폴트 확률</strong>이다. 모든 예시에서 <code class=\"language-text\">[1,2,3,4,1,2,5,1,2,3,4,5]</code> 의 순서로 페이지가 필요로 한다고 해보자.</p>\n<p>일반적으로 프레임의 개수가 많으면, 페이지 폴트의 빈도도 줄어든다.</p>\n<blockquote>\n<p>다만 정비례 하는것은 아니다. 이는 ‘벨라디의 모순’과 연관되어 있다.</p>\n</blockquote>\n<h3 id=\"fifo\" style=\"position:relative;\"><a href=\"#fifo\" aria-label=\"fifo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FIFO</h3>\n<ul>\n<li>단순하게 페이지 교체를 할 때 <strong>가장 오래된 페이지를 선택해 교체</strong>한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABwElEQVQoz42TCY/TMBCF8/9/F4uEQEgVaQv0gG1qO3HuHrns5EN2S3e3dCVGGtkazzzPe2MHy+WC+XzBdvuLzWbLZr0hzwuEEH5VSpGmKalOkVKRxAmDMYRh6H21WrFer5nNZmRZRhBFe8ReIIVCqZjNdutBdlGEktKD7IUgjhOkcnt5AxZC0vcD1lqMMTgLeMdOTUV91HS9ZRxH/semaSJwyX/dBWDCmJGi0tQHRdsNnqIxFqE0QqUkWYm1LzWvPbi/wZm1E3mpyUvBuek9oLOmaen6gWsaj2oDp4fTUOv0duDO2q7l3J4v3V+T3b6qj8RpgdI5MsnIy8MNzHfYth1t29J13e02J9npXHA8ZZ6yE/3S+eiH4Og3rq7r6YfhLeD7lGOqOqFpB4bBeKBIat+V0/CO8Avle1EdX2NHsiImK9yzMD5ux5Gu6y/e90x3A3nY4WvKRZWQVwpjp8dP5Or/DCVWiiRJ0VqT57n/EXV9QCmBVIK6rn0szQtsEsPuN5OOIYmZ5B4bPTNW5UuHriCKIhbzJeG3kJ+rlf8py+V3wnDuY7vnyNNsypLll898/fjEjzDk09MHTlV109AB/gGO+5zhUiAitwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/37523/1.png\"\n        srcset=\"/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/e9ff0/1.png 180w,\n/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/f21e7/1.png 360w,\n/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/37523/1.png 720w,\n/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/58213/1.png 902w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></li>\n<li>근데 프레임이 3개일때와 4개일때를 비교해보면, <strong>프레임이 늘었는데도 오히려 페이지 폴트가 증가했다. → 이것을 ‘벨라디의 모순’현상이라 한다.</strong></li>\n<li>즉 투입한 리소스와 효과가 비례하지 않음을 알 수 있고, 적절한 교체 알고리즘을 선택하는것이 중요함을 보인다.</li>\n</ul>\n<h3 id=\"optimal\" style=\"position:relative;\"><a href=\"#optimal\" aria-label=\"optimal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optimal</h3>\n<ul>\n<li>가장 오랫동안 사용되지 않을 (페이지 교체가 필요한 시점으로부터) 페이지를 선택한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABoElEQVQoz42Sy27bMBBF9f8fUqABumgW7b7rdhk4sBxHrmzrYVmi+BL1oE4hwg5qw4sMMLicAXln7gyjoizZ7/fkecFutyNJEqztGIYB51zwvu/pui7gPM8sdsV7i+4T1lqaRtC2Etm2F5Q0dYOUCu/9B+Ej0qhzjlkrvOvwRsMwsFxrVYbr3cMu/ie7nq8e9QthfQ6B14q5d4yT59wkuL4Lj4ztKCpBVbdIbW+I/B0GyfNCepGy2DhOnOod0zSEWCnN6/qNoqhQyqCVxk/+8QyXxr1omKfpo+o4jhTVG8YaFmVLThnFtkipZM2xKtjXBYU8814dOIoTq2zLOI2XpZQ5KHlTSZvzzQz97KlNy0k1lKqmtYqzFqR1Tm0kB1Ey+olICBG2qYRGSosQirZVjOOMkob9PiNND0HqZyzabDas1+9st79Yx1+J10/E8RNp+szf9HvIva6+EMffKPKf5PkPjtkzdftCbTRJdeDQlMhOX75N12Ht8oErrM2w9oQxJdaW2K7EuVNwKTOUKtC6DOh6RSkb/uxW/E5eqJQIW/4HhkoC0jDh6SkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/119b448614681a08121f38cfc6f5d979/37523/2.png\"\n        srcset=\"/static/119b448614681a08121f38cfc6f5d979/e9ff0/2.png 180w,\n/static/119b448614681a08121f38cfc6f5d979/f21e7/2.png 360w,\n/static/119b448614681a08121f38cfc6f5d979/37523/2.png 720w,\n/static/119b448614681a08121f38cfc6f5d979/71c8e/2.png 875w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></li>\n<li>가장 이상적인 알고리즘이기 때문에 가장 낮은 페이지 폴트를 보여준다.</li>\n<li>그렇지만, 다음에 무엇을 사용할지 알 수 없기 때문에 <strong>구현이 어렵고</strong> Optimal은 다른 알고리즘과의 성능비교의 기준으로 사용된다.</li>\n<li><strong>만약, 같은 행동을 반복하는 Bot의 형태고, 메모리 예측을 완벽하게 알 수 있다면 적용할 수 있다.</strong></li>\n</ul>\n<h3 id=\"lru\" style=\"position:relative;\"><a href=\"#lru\" aria-label=\"lru permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU</h3>\n<p>LRU는 <strong>Least Recently Used</strong>의 약자로 페이지 교체를 하는 시점에서<br>\n가장 덜 최근에 사용된것, 다시 말해 <strong>가장 오래전에 사용한 것</strong> 페이지를 선택해 교체하는 알고리즘이다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABPElEQVQoz32O2U6DUBRF+f/f8dlUq9FUwSrQwZYivUyX4VKg2DSpsAzO2sSd7IeTs/c6Rzs7H/JgWpiWxa1uMLy4RNd1HPeJZrcj3xSsAo/RwuTOmTMTDrpjcT65wXBsLmYGJ8aA6/kY21ugiTDFCyRxqhChJJQZVbMjT1KkL/HdCLVcEoY+/jpmv5U8H/ZEVUbelMwTj4dgQbItaLsOjT9qQo9qPaNuMqJohdpIgskVG2/6tu9eDu/BruNIHWg9tXfXtv2MerSJpyPirSSIHpFlhBAWReZ/cLp/rX2H2rdCsZyS3gwoVxZCedTuPYk/YdMUv4Bt/8AP0Od8DFzYZKNTto6JsMdUjkEsTIo6+wC2/Cft59Vepf9Eup6T1jny3iRRCXHuU9bFVykIAlzXpaoqlFKUZYkQgjzPeQUDwhDgw5w1kgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/38254e624e1790e808285a7052ea5bf0/37523/3.png\"\n        srcset=\"/static/38254e624e1790e808285a7052ea5bf0/e9ff0/3.png 180w,\n/static/38254e624e1790e808285a7052ea5bf0/f21e7/3.png 360w,\n/static/38254e624e1790e808285a7052ea5bf0/37523/3.png 720w,\n/static/38254e624e1790e808285a7052ea5bf0/90712/3.png 882w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>Optimal을 제외하고 굉장히 좋은 성능을 보이는데, 그 이유는 LRU가 <strong>Temporal Locality를 전제로 하고 있기 때문이다.</strong> <strong>최근에 사용된것은 다시 참조될 가능성이 크니,</strong> 반대로 가장 오래전에 사용한것을 지우면서 페이지 교체 자체를 줄이려는 것이다.\n<ul>\n<li>그런데 문제점은 <strong>LRU를 실제로 구현하는데에 있다.</strong>\n<ul>\n<li>예를 들어 모든 페이지에 참조된 시간을 적어놓는다면, 페이지 테이블에 추가적인 메모리가 들것이고 (min heap으로 컷해도 될듯) 참조될때마다 이것을 계속 수정하는 오버헤드가 있다.</li>\n<li>만약 Linear하게 가장 오래전에 사용된 것을 찾는다고 해보자.</li>\n<li>이때의 시간복잡도는 <code class=\"language-text\">n</code>개의 페이지에 대해서 <code class=\"language-text\">O(n)</code>인데, 이 N 값이 의미하는 것은 프로세스의 개수이고 보통 너무 크다는데 있다.</li>\n</ul>\n</li>\n<li><strong>그러므로 커널에 구현하기는 시간적/공간적 오버헤드가 너무 크다. 따라서 근사치 모델이 필요하다.</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lru-근사\" style=\"position:relative;\"><a href=\"#lru-%EA%B7%BC%EC%82%AC\" aria-label=\"lru 근사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU 근사</h3>\n<ul>\n<li>카운터 구현\n<ul>\n<li>메모리 참조가 일어날때마다 CPU counter를 올리고, 페이지 A가 참조되면 페이지에 카운터를 덮어씌운다.</li>\n<li>O(n)의 조회방식, 심지어 그때마다 메모리 액세스가 한번 더 일어남.</li>\n</ul>\n</li>\n<li>스택 구현\n<ul>\n<li>페이지 번호로 <a href=\"https://becomeweasel.me/array-and-linked-list/#doubly-linked-list\">Doubly Linked List</a> 형태로 스택을 구현한다.</li>\n<li>페이지 A가 참조되면, A를 헤드로 옮긴다.\n<ul>\n<li>이때 6번의 포인터 움직임이 필요하다.</li>\n</ul>\n</li>\n<li>찾는데 드는 오버헤드는 없지만, 매번의 페이지 참조마다 6번의 메모리 액세스가 있다.</li>\n<li><strong>교체가 일어나지 않아도 평소 오버헤드가 너무 크다.</strong></li>\n</ul>\n</li>\n<li><strong>두번째 기회 (Second Chance)</strong>\n<ul>\n<li>기본적으로 FIFO다.</li>\n<li>페이지를 <strong>원형의 큐</strong>로 구성한다.</li>\n<li>페이지 테이블 내의 모든 페이지의 Ref bit를 초기값 0으로 할당하고, 참조가 되면 1로 바꾼다.</li>\n<li>참조비트가 <strong>0인 페이지를 찾으면, 그 페이지를 교체</strong>한다.</li>\n<li><strong>만약 1이라면, 그 페이지는 0으로 바꾸고 한번 더 돈다. 한번의 기회를 더 주는것이다.</strong></li>\n<li>한번 더 돌았을때도, 0이면 교환한다.</li>\n<li>그런데 모든 <strong>bit가 1인 경우를 생각해보면, FIFO의 알고리즘처럼 동작한다.</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lfu\" style=\"position:relative;\"><a href=\"#lfu\" aria-label=\"lfu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LFU</h3>\n<ul>\n<li>전제는 <strong>많이 사용되는 페이지는 더 많이 사용될 것</strong>이라는 전제</li>\n<li>페이지에 참조된 횟수를 나타내는 카운터를 넣는다.</li>\n<li>가장 카운터가 적은 페이지를 교체한다.</li>\n<li>하지만 어떠한 페이지가 집중적으로 참조되다가 그 뒤에도 사용되지 않으면 어느정도까지 계속 머무르는 경향이 일어난다. 즉 전제와 어긋나게 된다.</li>\n</ul>\n<h3 id=\"mfu\" style=\"position:relative;\"><a href=\"#mfu\" aria-label=\"mfu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MFU</h3>\n<ul>\n<li>전제는 <strong>카운터가 작은 페이지는 이제 막 들어왔고, 사용되지 않았다</strong>는 전제.</li>\n<li>페이지에 참조된 횟수를 나타내는 카운터를 넣는다.</li>\n<li>가장 카운터가 큰 페이지를 교체한다.</li>\n<li><strong>Locality가 자주 변하는 시스템에서 유용하다.</strong></li>\n</ul>\n<h2 id=\"threshing\" style=\"position:relative;\"><a href=\"#threshing\" aria-label=\"threshing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Threshing</h2>\n<p>스레싱은 멀티프로그래밍 환경에서 페이지 폴트가 많이 일어나서 CPU 이용률이 급격하게 떨어지는 현상이다.</p>\n<p>더 최악인 점은 CPU 이용률이 떨어지니, 레디큐에 프로세스를 올리는 Long-term scheduler가 판단하기를\n”CPU 이용률을 높이기 위해 멀티프로그래밍 정도를 올려야 함”이라고 판단하고 레디큐에 더 많은 프로세스를 올리면서 페이지폴트는 더 늘어간다.</p>\n<ul>\n<li>여기서 멀티프로그래밍 정도가 느는것과 페이지폴트가 무슨상관일까?\n<ul>\n<li>새로운 프로세스가 올라오면, Short-term scheduler가 새로운 프로세스에 CPU를 할당할 것이고, 이때는 initial page fault가 생기기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<p>결국 Swap-in,Swap-out만을 하느라 바쁘고, 프로세스는 Block 되며, CPU는 대부분의 상황에서 <strong>IDLE</strong> 상태다.</p>\n<blockquote>\n<p>I/O 작업만 하니까..</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABS0lEQVQoz2WRa2/iMBRE+/9/1fKpW22Xso7ygDSJHeK8gDQkYUEUOKvrqqXSjjS6liwfzfU83G43ROfzmbZtGceRYRj+8ygeR6ZpYrNpsbZgnRvn7aZ1DGE9fAIvlwvGGIqiYL1eO8vZiq3F5DmZ1mRZRmYKjO1RUYkfN2RFz4e+ASWFAOu6pqoql1ZAuYC1Jgl8Fr9fUIs/7i61B1TcszQjv/wdP55rDsf3O7BpGtI0dbMsS6Iowvd9wigiVIro6Set1timYdt1vLyOxMVEnA+Eac9i2fEc7O7A/X7/tarneSRJ4tJKmqZtCVcrat+jenpktww5ZIZTmnDabDm9w/V6ZZjOd6BIEiqlHFRSypSVS2sJggDfU+TxCms0HP9yOx2FxHc5oFj+azabMZ/P3eM4jtE6I00Tl1Zareqaru/p3t64ftXw0e6n/wF+nwqm/nfotAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/fcbecb569fce34f2614a5907b36464b2/37523/4.png\"\n        srcset=\"/static/fcbecb569fce34f2614a5907b36464b2/e9ff0/4.png 180w,\n/static/fcbecb569fce34f2614a5907b36464b2/f21e7/4.png 360w,\n/static/fcbecb569fce34f2614a5907b36464b2/37523/4.png 720w,\n/static/fcbecb569fce34f2614a5907b36464b2/6029f/4.png 906w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 그림처럼 MPD를 계속 올리다보니 스레싱이 발생하고, 그러면 더 MPD를 올리게되고 페이지폴트는 더 자주일어나면서 CPU 이용률은 급감한다.</p>\n<p>결국에 자주 접근되는 페이지가 메모리에 올라와있지 않으면 이런 많은 페이지 폴트가 생기는데,<br>\n그렇기 때문에 각 프로세스가 필요로 하는 <strong>최소 프레임의 개수만큼은 보장</strong>을 해주어야 한다.</p>\n<h2 id=\"프리페이징prepaging\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%ED%8E%98%EC%9D%B4%EC%A7%95prepaging\" aria-label=\"프리페이징prepaging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리페이징(Prepaging)</h2>\n<p>프로세스가 시작될때는 항상 initial page fault가 난다. 아무것도 안올라와 있기 때문에..</p>\n<p>이것을 방지하기 위해서, 프로세스가 필요로 하는 페이지의 전부 혹은 일부를 참조되기전에 미리 메모리에 올리는것이다.</p>\n<p>물론, 페이지가 사용되지 않으면 낭비가 있다.</p>\n<h2 id=\"swap의-어떤-이점이-있는가\" style=\"position:relative;\"><a href=\"#swap%EC%9D%98-%EC%96%B4%EB%96%A4-%EC%9D%B4%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80\" aria-label=\"swap의 어떤 이점이 있는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swap의 어떤 이점이 있는가?</h2>\n<ul>\n<li>장점\n<ul>\n<li>가상 메모리를 만들고 유지하는데 도움이 된다. 그렇기에 더 많은 프로세스가 구동될 수 있다.</li>\n<li>실제 필요한 메모리용량만큼만 디스크에서 메모리로 올릴 수 있게 해주니, 물리메모리보다 더 큰 용량의 프로세스가 구동될 수 있다.</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li>디스크에 접근하는 I/O → 디스크가 입출력을 할때 기다리지 않고 컨텍스트 스위칭</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%A7%80%EC%97%AD%EC%84%B1\">지역성</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">페이지 교체 알고리즘</a></p>\n<ul>\n<li><a href=\"#fifo\">FIFO</a></li>\n<li><a href=\"#optimal\">Optimal</a></li>\n<li><a href=\"#lru\">LRU</a></li>\n<li><a href=\"#lru-%EA%B7%BC%EC%82%AC\">LRU 근사</a></li>\n<li><a href=\"#lfu\">LFU</a></li>\n<li><a href=\"#mfu\">MFU</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#threshing\">Threshing</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A6%AC%ED%8E%98%EC%9D%B4%EC%A7%95prepaging\">프리페이징(Prepaging)</a></p>\n</li>\n<li>\n<p><a href=\"#swap%EC%9D%98-%EC%96%B4%EB%96%A4-%EC%9D%B4%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80\">Swap의 어떤 이점이 있는가?</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"February 06, 2022","title":"운영체제의 메모리 훔쳐보기 3편 - 페이지 교체 알고리즘","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/page-replacement-algorithm/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/mutex-and-semaphore/","nextSlug":"/tcp-and-udp/","prevSlug":"/page-replacement-algorithm/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}