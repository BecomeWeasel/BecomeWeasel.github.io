{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/GIL/",
    "result": {"data":{"cur":{"id":"5a4dee1d-16e6-5c3a-ab6c-8868ee79a5f5","html":"<p><strong>GIL</strong>은 Global Interpreter Lock의 약자이다.</p>\n<p>Global이 붙으니 전역적이라는 의미이고, Lock을 사용하니 무언가를 제한한다는것은 알겠는데 Interpreter는 뭘까?\n인터프리터에 대해서 제한을 건다는 것이 어떤 의미일까?</p>\n<p>아래에서 쭉 알아보자.</p>\n<h2 id=\"interpreter\" style=\"position:relative;\"><a href=\"#interpreter\" aria-label=\"interpreter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interpreter</h2>\n<p>짧게 얘기하면 <strong>Python 인터프리터는 코드를 한 줄씩 읽으면서 실행</strong>하는 프로그램이다.</p>\n<blockquote>\n<p>이 방식때문에 인터프리터 언어가 느리단 얘기가 나오는 것이고, Java에서 이를 개선해서 등장한 방식이 JIT다.</p>\n</blockquote>\n<p>이 인터프리터의 구현체는 여러가지가 있는데 대표적인 구현체가 C로 구현한 것이고, 이를 <strong>CPython</strong>이라고 한다.</p>\n<p>이 글에서는 CPython 기준으로 설명할 것이다.</p>\n<blockquote>\n<p><a href=\"https://wiki.python.org/moin/GlobalInterpreterLock\">Python 위키</a> 항목을 읽어보면 <em><strong>Non-CPython implementations</strong></em>에 Jython, IronPython은 GIL이 없고, PyPy는 CPython과 비슷한 GIL을 가지고 있다. 또 Cython에는 CIL이 존재하지만, <code class=\"language-text\">with</code> 키워드를 이용하여 잠시동안 해제가 가능하다고 한다.</p>\n</blockquote>\n<p>대충 인터프리터가 어떤 의미인지는 알았으니 본론으로 들어가서 GIL에 대해서 알아보자.</p>\n<h2 id=\"gil\" style=\"position:relative;\"><a href=\"#gil\" aria-label=\"gil permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GIL</h2>\n<p><a href=\"https://wiki.python.org/moin/GlobalInterpreterLock\">Python 위키</a>를 계속 참고해보면, 이렇게 정의하고 있다.</p>\n<blockquote>\n<p>In CPython, the <strong>global interpreter lock</strong>, or <strong>GIL</strong>, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. The GIL prevents race conditions and ensures thread safety. A nice explanation of <a href=\"https://python.land/python-concurrency/the-python-gil\">how the Python GIL helps in these areas can be found here</a>. In short, this mutex is necessary mainly because CPython’s memory management is not thread-safe.</p>\n</blockquote>\n<p>중요한 부분 위주로 해석을 해보면,</p>\n<p>GIL은 CPython에서 객체들에 대한 접근을 보호하는 뮤텍스(Mutex)로써, 여러개의 쓰레드가 동시에 파이썬의 바이트코드를 실행하는 것을 방지하는 역할이라는 것이다.<br>\n따라서 GIL은 경쟁 상태에 진입하는 것을 막아주고, 쓰레드 안전성을 보장한다.<br>\n또 간단하게 말해서, <strong>CPython의 메모리 관리가 쓰레드-안전이 아니기 때문에</strong> 뮤텍스가 필요하다는 것이다.</p>\n<p>더 간단하게 말하면, <em>Python 인터프리터에 대해서 전역적으로 잠금</em>이 걸리기 때문에 <strong>한 시점에 오직 하나의 쓰레드만 인터프리터를 실행할 수 있다.</strong></p>\n<p>또 이어지는 설명에서 이렇게 설명을 한다.</p>\n<blockquote>\n<p>In hindsight, the GIL is not ideal, since it prevents multithreaded CPython programs from taking full advantage of multiprocessor systems in certain situations.</p>\n</blockquote>\n<p>해석해보자면 돌이켜보았을때 GIL은 멀티쓰레딩 CPython 프로그램이 특정 상황에서 <strong><em>멀티프로세서 시스템의 장점을 다 사용하지 못</em></strong> 하게끔 하기 때문에 GIL은 이상적이지 않다.</p>\n<blockquote>\n<p>여기서 말하는 멀티프로세서 시스템의 장점은 <strong>멀티 쓰레딩 동작을 할때 여러 개의 쓰레드가 각각의 프로세서 상에서 병렬적으로 실행됨</strong>을 의미한다.</p>\n</blockquote>\n<p>즉, <strong>GIL 때문에 CPython에서는 그러한 병렬적인 실행이 불가능하다는 것이다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB8ElEQVQ4y31TPW/UQBC9Bv4S/AcIFb8BUSJ+AmmCoKUIJZQkUHGKQEgIEqCAIwV0BO7OF1vx2V5/2/v50MydLZ8u8KQn7e7svJmdmR3VdY0oiuD7PqSUMMZAa83rpmmYbdv2e1r/i1VVYUSCDkBelvDOz1f0PHZ2ziEMQwRBwGcUmM6stVskkNaIHHvUDWxdI8syzpSglOI9kdb/A2mNtJR48mOCO++PcPfjWzz9eYqmLCGyHMY6zlykGTsMszPWolUabr0nGwsaqXDv5B2uHT7D9ZfPcf/DG2RxjEik0NYiSgSCcLkSMaYX1MagblV/3gvKtoVflfi+vMDp8gJBVXI22jooY0HVMQ5c5yFIQGqz/WSnFG6OD3Bl/xGu7j/G7aNXbAzjBGe//yARKRqpuH7U/SEpc5oOaliapjwJnOGvTODY93AcLHCWCRak6NpYzpJ4GZRx2xkaKfHg6wl2xge4NT7E3uQzG6tWolUKUmsUVY04jpEkSU8aJ5EV/PSNGpLg7rdPuPH6BT/94eTLKhqJKQ2lqfiSxybPc2ZRFBBCIC8rvrvR5Y05XMOsB5UiU+3o8mWgOg4Huxd03EnH7CZ+sfAwm82Y5DgEZTefzzGdTrkpXUAWJGfqTvcfuzU9i1iW5ZadHDs7/V86I9Jf/guSa978g3z/uwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/135772f5932488ef9186461afe7f1027/37523/example_gil.png\"\n        srcset=\"/static/135772f5932488ef9186461afe7f1027/e9ff0/example_gil.png 180w,\n/static/135772f5932488ef9186461afe7f1027/f21e7/example_gil.png 360w,\n/static/135772f5932488ef9186461afe7f1027/37523/example_gil.png 720w,\n/static/135772f5932488ef9186461afe7f1027/302a4/example_gil.png 1080w,\n/static/135772f5932488ef9186461afe7f1027/6be49/example_gil.png 1160w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"gil의-필요성\" style=\"position:relative;\"><a href=\"#gil%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"gil의 필요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GIL의 필요성</h3>\n<p>괜히 멀티쓰레딩만 방해하고, GIL은 대체 왜 있는걸까?</p>\n<p>이것에 대한 해답은 아까 말한 정의에 나와있다.</p>\n<p><strong><em>GIL is … mutext that protects access to Python Objects.</em></strong></p>\n<p>Python에서 모든 것은 객체로 존재하고, <a href=\"https://github.com/python/cpython/blob/main/Include/object.h\">CPython에서 각각의 객체들이 C 구조체를 통해 만들어진다는 것을 생각해보면,</a> 수 많은 객체에 대응되는 수 많은 구조체가 있음을 알 수 있다.</p>\n<p>그러면 자연스럽게 메모리 관리를 생각하게 된다.</p>\n<p>Python에서 메모리 관리는 참조 횟수(reference count)를 이용해 GC(Garbage Collection)를 수행하는데, 이 참조 횟수가 C 구조체 안에 적혀 있다.\nCPython의 소스코드를 확인해보면 이렇게 코드가 나와있다.</p>\n<blockquote>\n<p><a href=\"https://github.com/python/cpython/blob/main/Include/object.h\">https://github.com/python/cpython/blob/main/Include/object.h</a></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_object</span> <span class=\"token punctuation\">{</span>\n    _PyObject_HEAD_EXTRA\n    Py_ssize_t ob_refcnt<span class=\"token punctuation\">;</span>\n    PyTypeObject <span class=\"token operator\">*</span>ob_type<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> PyObject<span class=\"token punctuation\">;</span></code></pre></div>\n<p>잘 보면 PyObject 구조체 안에 참조 횟수를 <strong>직접 저장</strong>하고 있다.</p>\n<p>운영체제를 열심히 들으신 분이라면 바로 왜 위에서 언급한 <strong>경쟁 상태</strong>가 생길수 있는지 아실 것이다.</p>\n<p>만약 CPython의 의도와는 정반대로 여러개의 쓰레드가 동시에 Python 인터프리터를 실행한다면,<br>\n참조 횟수에 병렬 프로그래밍의 고질적 문제 중 하나인 <a href=\"https://becomeweasel.me/mutex-and-semaphore/#race-condition\"><strong>경쟁 상태</strong></a>가 발생하게 된다.</p>\n<p>단순히 여기서 그치는 것이 아니라 아까 Python GC의 원리가 참조 횟수에 기반을 둔다는 점을 다시 생각한다면,\n<strong>올바르지 않은(비정합적인)</strong> 참조 횟수를 기반으로 GC가 일어남으로써 <strong>GC가 의도한 바와는 다르게 동작할 수 있다는 것이다.</strong></p>\n<p>그렇다고 객체에 대해서 작업을 할때, 좀 더 좁게 말하자면 <strong><code class=\"language-text\">ob_refcnt</code>에 대한 작업을 수행할때마다</strong> 별도의 뮤텍스를 이용해서 Lock을 얻고 해제한다면 비효율적이고, 프로그래머가 일일이 제어하기에는 부담이 가는 작업이다.</p>\n<p>그렇기에 CPython에서는 <strong>한 쓰레드가 인터프리터를 실행 중일때는 다른 쓰레드가 실행하지 못하도록 인터프리터를 잠궈버렸다.</strong><br>\n이렇게 된다면, 객체의 참조 횟수에 대한 경쟁 상태 역시 고려할 필요가 없어진다.</p>\n<blockquote>\n<p>GIL을 선택한 이유에 대해서 조금 더 자세하게 알아보자면, 이 <a href=\"https://softwareengineering.stackexchange.com/questions/186889/why-was-python-written-with-the-gil\">링크</a>와 이 <a href=\"https://realpython.com/python-gil/\">링크</a>를 참조하면 된다.</p>\n</blockquote>\n<blockquote>\n<p>짧게 얘기하자면, Python을 처음 만들때는 쓰레드라는 개념이 인기 있기 전이였고, 그 후에 쓰레드가 등장했을때 가장 <strong>현실적이고 쉬운</strong> 방법이 GIL이였다.</p>\n</blockquote>\n<p>첨언하자면, 왜 GIL이 아닌 다른 해결책을 도입하지 않냐고 하자 Python의 개발자인 <a href=\"https://en.wikipedia.org/wiki/Guido_van_Rossum\"><strong>Guido van Rossum</strong></a>은 이렇게 말했다고 한다.</p>\n<blockquote>\n<p>”단일 쓰레드 프로그램에서(그리고 I/O 바운드 멀티 쓰레드 프로그램) 성능이 저하되지 않는 GIL 해결책을 가지고 오면, 그 해결책을 기쁘게 받아들이겠다.”</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#interpreter\">Interpreter</a></p>\n</li>\n<li>\n<p><a href=\"#gil\">GIL</a></p>\n<ul>\n<li><a href=\"#gil%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\">GIL의 필요성</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"GIL은 Global Interpreter Lock의 약자이다. Global이 붙으니 전역적이라는 의미이고, Lock을 사용하니 무언가를 제한한다는것은 알겠는데 Interpreter는 뭘까?\n인터프리터에 대해서 제한을 건다는 것이 어떤 의미일까? 아래에서 쭉 알아보자. Interpreter 짧게 얘기하면 Python 인터프리터는 코드를 한 줄씩 읽으면서 실행하는 프로그램이다. 이 방식때문에 인터프리터 언어가 느리단 얘기가 나오는 것이고, Java에서 이를 개선해서 등장한 방식이 JIT다. 이 인터프리터의 구현체는 여러가지가 있는데 대표적인 구현체가 C로 구현한 것이고, 이를 CPython이라고 한다. 이 글에서는 CPython 기준으로 설명할 것이다. Python 위키 항목을 읽어보면 Non-CPython implementations에 Jython, IronPython은 GIL이 없고, PyPy는 CPython과 비슷한 GIL을 가지고 있다. 또 Cython에는 CIL이 존재하지만…","frontmatter":{"date":"February 08, 2022","title":"GIL 훔쳐보기","categories":"Python","author":"weasel","emoji":"📓"},"fields":{"slug":"/GIL/"}},"next":{"id":"01585043-5594-5707-8533-9be6484f7713","html":"<p><a href=\"https://becomeweasel.me/virtual-memory/\">이전편 : 가상 메모리</a></p>\n<h2 id=\"지역성\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EC%97%AD%EC%84%B1\" aria-label=\"지역성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>지역성</h2>\n<p>페이지 교체 알고리즘에 대해 언급하기 전에 먼저 <strong>지역성</strong>이라는 것에 대해서 알아야 한다.</p>\n<ul>\n<li><strong>시간 지역성</strong> (Temporal Locality ) : 현재 참조된 메모리가 <strong>가까운 미래내에 참조</strong>될 가능성이 높음\n<ul>\n<li>loop,subroutine,stack</li>\n</ul>\n</li>\n<li><strong>공간 지역성</strong> (Spatial Locality) : 하나의 메모리가 참조되면 <strong>주변의 메모리가 참조</strong>될 가능성이 높음\n<ul>\n<li>Array 순회, 명령어의 순차실행</li>\n</ul>\n</li>\n</ul>\n<p>프로그램의 메모리 참조는 고도의 지역성을 가진다. 임의의 시간 Δt 내에 프로그램의 <strong>일부분만을 집중적으로 참조</strong>한다는 것이다.<br>\n이러한 지역성이 있기 때문에 적절한 페이지 교체 알고리즘이 중요하다.</p>\n<p>왜 중요할까?<br>\n예를 들어서 주기적으로 두개의 페이지만 참조하는 로직이 있다고 해보자.<br>\n만약 그 두개의 페이지를 번갈아가면서 교체를 한다면, 페이지 폴트는 두 개의 페이지에 대해서 접근할때마다 계속 일어날 것이다.</p>\n<p>이게 왜 위험하냐면, <strong>불필요한 I/O 작업의 오버헤드도 있고, 그때마다 컨텍스트 스위칭</strong>이 계속 일어나기 때문이다.</p>\n<h2 id=\"페이지-교체-알고리즘\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"페이지 교체 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 교체 알고리즘</h2>\n<p>페이지 폴트가 났을때, 메모리에 빈공간이 있으면 올리면 되는 일이다. 물론 I/O가 들어가긴 하지만.\n근데 만약 <strong>모든 메모리가 사용중</strong>이라면 교체될 페이지를 골라야하는데, 이걸 잘 고르는게 성능에 큰 영향을 미친다.</p>\n<p>그러므로 원하는 것은 <strong>가장 낮은 페이지 폴트 확률</strong>이다. 모든 예시에서 <code class=\"language-text\">[1,2,3,4,1,2,5,1,2,3,4,5]</code> 의 순서로 페이지가 필요로 한다고 해보자.</p>\n<p>일반적으로 프레임의 개수가 많으면, 페이지 폴트의 빈도도 줄어든다.</p>\n<blockquote>\n<p>다만 정비례 하는것은 아니다. 이는 ‘벨라디의 모순’과 연관되어 있다.</p>\n</blockquote>\n<h3 id=\"fifo\" style=\"position:relative;\"><a href=\"#fifo\" aria-label=\"fifo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FIFO</h3>\n<ul>\n<li>단순하게 페이지 교체를 할 때 <strong>가장 오래된 페이지를 선택해 교체</strong>한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABwElEQVQoz42TCY/TMBCF8/9/F4uEQEgVaQv0gG1qO3HuHrns5EN2S3e3dCVGGtkazzzPe2MHy+WC+XzBdvuLzWbLZr0hzwuEEH5VSpGmKalOkVKRxAmDMYRh6H21WrFer5nNZmRZRhBFe8ReIIVCqZjNdutBdlGEktKD7IUgjhOkcnt5AxZC0vcD1lqMMTgLeMdOTUV91HS9ZRxH/semaSJwyX/dBWDCmJGi0tQHRdsNnqIxFqE0QqUkWYm1LzWvPbi/wZm1E3mpyUvBuek9oLOmaen6gWsaj2oDp4fTUOv0duDO2q7l3J4v3V+T3b6qj8RpgdI5MsnIy8MNzHfYth1t29J13e02J9npXHA8ZZ6yE/3S+eiH4Og3rq7r6YfhLeD7lGOqOqFpB4bBeKBIat+V0/CO8Avle1EdX2NHsiImK9yzMD5ux5Gu6y/e90x3A3nY4WvKRZWQVwpjp8dP5Or/DCVWiiRJ0VqT57n/EXV9QCmBVIK6rn0szQtsEsPuN5OOIYmZ5B4bPTNW5UuHriCKIhbzJeG3kJ+rlf8py+V3wnDuY7vnyNNsypLll898/fjEjzDk09MHTlV109AB/gGO+5zhUiAitwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/37523/1.png\"\n        srcset=\"/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/e9ff0/1.png 180w,\n/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/f21e7/1.png 360w,\n/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/37523/1.png 720w,\n/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/58213/1.png 902w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></li>\n<li>근데 프레임이 3개일때와 4개일때를 비교해보면, <strong>프레임이 늘었는데도 오히려 페이지 폴트가 증가했다. → 이것을 ‘벨라디의 모순’현상이라 한다.</strong></li>\n<li>즉 투입한 리소스와 효과가 비례하지 않음을 알 수 있고, 적절한 교체 알고리즘을 선택하는것이 중요함을 보인다.</li>\n</ul>\n<h3 id=\"optimal\" style=\"position:relative;\"><a href=\"#optimal\" aria-label=\"optimal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optimal</h3>\n<ul>\n<li>가장 오랫동안 사용되지 않을 (페이지 교체가 필요한 시점으로부터) 페이지를 선택한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABoElEQVQoz42Sy27bMBBF9f8fUqABumgW7b7rdhk4sBxHrmzrYVmi+BL1oE4hwg5qw4sMMLicAXln7gyjoizZ7/fkecFutyNJEqztGIYB51zwvu/pui7gPM8sdsV7i+4T1lqaRtC2Etm2F5Q0dYOUCu/9B+Ej0qhzjlkrvOvwRsMwsFxrVYbr3cMu/ie7nq8e9QthfQ6B14q5d4yT59wkuL4Lj4ztKCpBVbdIbW+I/B0GyfNCepGy2DhOnOod0zSEWCnN6/qNoqhQyqCVxk/+8QyXxr1omKfpo+o4jhTVG8YaFmVLThnFtkipZM2xKtjXBYU8814dOIoTq2zLOI2XpZQ5KHlTSZvzzQz97KlNy0k1lKqmtYqzFqR1Tm0kB1Ey+olICBG2qYRGSosQirZVjOOMkob9PiNND0HqZyzabDas1+9st79Yx1+J10/E8RNp+szf9HvIva6+EMffKPKf5PkPjtkzdftCbTRJdeDQlMhOX75N12Ht8oErrM2w9oQxJdaW2K7EuVNwKTOUKtC6DOh6RSkb/uxW/E5eqJQIW/4HhkoC0jDh6SkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/119b448614681a08121f38cfc6f5d979/37523/2.png\"\n        srcset=\"/static/119b448614681a08121f38cfc6f5d979/e9ff0/2.png 180w,\n/static/119b448614681a08121f38cfc6f5d979/f21e7/2.png 360w,\n/static/119b448614681a08121f38cfc6f5d979/37523/2.png 720w,\n/static/119b448614681a08121f38cfc6f5d979/71c8e/2.png 875w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></li>\n<li>가장 이상적인 알고리즘이기 때문에 가장 낮은 페이지 폴트를 보여준다.</li>\n<li>그렇지만, 다음에 무엇을 사용할지 알 수 없기 때문에 <strong>구현이 어렵고</strong> Optimal은 다른 알고리즘과의 성능비교의 기준으로 사용된다.</li>\n<li><strong>만약, 같은 행동을 반복하는 Bot의 형태고, 메모리 예측을 완벽하게 알 수 있다면 적용할 수 있다.</strong></li>\n</ul>\n<h3 id=\"lru\" style=\"position:relative;\"><a href=\"#lru\" aria-label=\"lru permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU</h3>\n<p>LRU는 <strong>Least Recently Used</strong>의 약자로 페이지 교체를 하는 시점에서<br>\n가장 덜 최근에 사용된것, 다시 말해 <strong>가장 오래전에 사용한 것</strong> 페이지를 선택해 교체하는 알고리즘이다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABPElEQVQoz32O2U6DUBRF+f/f8dlUq9FUwSrQwZYivUyX4VKg2DSpsAzO2sSd7IeTs/c6Rzs7H/JgWpiWxa1uMLy4RNd1HPeJZrcj3xSsAo/RwuTOmTMTDrpjcT65wXBsLmYGJ8aA6/kY21ugiTDFCyRxqhChJJQZVbMjT1KkL/HdCLVcEoY+/jpmv5U8H/ZEVUbelMwTj4dgQbItaLsOjT9qQo9qPaNuMqJohdpIgskVG2/6tu9eDu/BruNIHWg9tXfXtv2MerSJpyPirSSIHpFlhBAWReZ/cLp/rX2H2rdCsZyS3gwoVxZCedTuPYk/YdMUv4Bt/8AP0Od8DFzYZKNTto6JsMdUjkEsTIo6+wC2/Cft59Vepf9Eup6T1jny3iRRCXHuU9bFVykIAlzXpaoqlFKUZYkQgjzPeQUDwhDgw5w1kgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/38254e624e1790e808285a7052ea5bf0/37523/3.png\"\n        srcset=\"/static/38254e624e1790e808285a7052ea5bf0/e9ff0/3.png 180w,\n/static/38254e624e1790e808285a7052ea5bf0/f21e7/3.png 360w,\n/static/38254e624e1790e808285a7052ea5bf0/37523/3.png 720w,\n/static/38254e624e1790e808285a7052ea5bf0/90712/3.png 882w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>Optimal을 제외하고 굉장히 좋은 성능을 보이는데, 그 이유는 LRU가 <strong>Temporal Locality를 전제로 하고 있기 때문이다.</strong> <strong>최근에 사용된것은 다시 참조될 가능성이 크니,</strong> 반대로 가장 오래전에 사용한것을 지우면서 페이지 교체 자체를 줄이려는 것이다.\n<ul>\n<li>그런데 문제점은 <strong>LRU를 실제로 구현하는데에 있다.</strong>\n<ul>\n<li>예를 들어 모든 페이지에 참조된 시간을 적어놓는다면, 페이지 테이블에 추가적인 메모리가 들것이고 (min heap으로 컷해도 될듯) 참조될때마다 이것을 계속 수정하는 오버헤드가 있다.</li>\n<li>만약 Linear하게 가장 오래전에 사용된 것을 찾는다고 해보자.</li>\n<li>이때의 시간복잡도는 <code class=\"language-text\">n</code>개의 페이지에 대해서 <code class=\"language-text\">O(n)</code>인데, 이 N 값이 의미하는 것은 프로세스의 개수이고 보통 너무 크다는데 있다.</li>\n</ul>\n</li>\n<li><strong>그러므로 커널에 구현하기는 시간적/공간적 오버헤드가 너무 크다. 따라서 근사치 모델이 필요하다.</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lru-근사\" style=\"position:relative;\"><a href=\"#lru-%EA%B7%BC%EC%82%AC\" aria-label=\"lru 근사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU 근사</h3>\n<ul>\n<li>카운터 구현\n<ul>\n<li>메모리 참조가 일어날때마다 CPU counter를 올리고, 페이지 A가 참조되면 페이지에 카운터를 덮어씌운다.</li>\n<li>O(n)의 조회방식, 심지어 그때마다 메모리 액세스가 한번 더 일어남.</li>\n</ul>\n</li>\n<li>스택 구현\n<ul>\n<li>페이지 번호로 <a href=\"https://becomeweasel.me/array-and-linked-list/#doubly-linked-list\">Doubly Linked List</a> 형태로 스택을 구현한다.</li>\n<li>페이지 A가 참조되면, A를 헤드로 옮긴다.\n<ul>\n<li>이때 6번의 포인터 움직임이 필요하다.</li>\n</ul>\n</li>\n<li>찾는데 드는 오버헤드는 없지만, 매번의 페이지 참조마다 6번의 메모리 액세스가 있다.</li>\n<li><strong>교체가 일어나지 않아도 평소 오버헤드가 너무 크다.</strong></li>\n</ul>\n</li>\n<li><strong>두번째 기회 (Second Chance)</strong>\n<ul>\n<li>기본적으로 FIFO다.</li>\n<li>페이지를 <strong>원형의 큐</strong>로 구성한다.</li>\n<li>페이지 테이블 내의 모든 페이지의 Ref bit를 초기값 0으로 할당하고, 참조가 되면 1로 바꾼다.</li>\n<li>참조비트가 <strong>0인 페이지를 찾으면, 그 페이지를 교체</strong>한다.</li>\n<li><strong>만약 1이라면, 그 페이지는 0으로 바꾸고 한번 더 돈다. 한번의 기회를 더 주는것이다.</strong></li>\n<li>한번 더 돌았을때도, 0이면 교환한다.</li>\n<li>그런데 모든 <strong>bit가 1인 경우를 생각해보면, FIFO의 알고리즘처럼 동작한다.</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lfu\" style=\"position:relative;\"><a href=\"#lfu\" aria-label=\"lfu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LFU</h3>\n<ul>\n<li>전제는 <strong>많이 사용되는 페이지는 더 많이 사용될 것</strong>이라는 전제</li>\n<li>페이지에 참조된 횟수를 나타내는 카운터를 넣는다.</li>\n<li>가장 카운터가 적은 페이지를 교체한다.</li>\n<li>하지만 어떠한 페이지가 집중적으로 참조되다가 그 뒤에도 사용되지 않으면 어느정도까지 계속 머무르는 경향이 일어난다. 즉 전제와 어긋나게 된다.</li>\n</ul>\n<h3 id=\"mfu\" style=\"position:relative;\"><a href=\"#mfu\" aria-label=\"mfu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MFU</h3>\n<ul>\n<li>전제는 <strong>카운터가 작은 페이지는 이제 막 들어왔고, 사용되지 않았다</strong>는 전제.</li>\n<li>페이지에 참조된 횟수를 나타내는 카운터를 넣는다.</li>\n<li>가장 카운터가 큰 페이지를 교체한다.</li>\n<li><strong>Locality가 자주 변하는 시스템에서 유용하다.</strong></li>\n</ul>\n<h2 id=\"프리페이징prepaging\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%ED%8E%98%EC%9D%B4%EC%A7%95prepaging\" aria-label=\"프리페이징prepaging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리페이징(Prepaging)</h2>\n<p>프로세스가 시작될때는 항상 initial page fault가 난다. 아무것도 안올라와 있기 때문에..</p>\n<p>이것을 방지하기 위해서, 프로세스가 필요로 하는 페이지의 전부 혹은 일부를 참조되기전에 미리 메모리에 올리는것이다.</p>\n<p>물론, 페이지가 사용되지 않으면 낭비가 있다.</p>\n<h2 id=\"swap의-어떤-이점이-있는가\" style=\"position:relative;\"><a href=\"#swap%EC%9D%98-%EC%96%B4%EB%96%A4-%EC%9D%B4%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80\" aria-label=\"swap의 어떤 이점이 있는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swap의 어떤 이점이 있는가?</h2>\n<ul>\n<li>장점\n<ul>\n<li>가상 메모리를 만들고 유지하는데 도움이 된다. 그렇기에 더 많은 프로세스가 구동될 수 있다.</li>\n<li>실제 필요한 메모리용량만큼만 디스크에서 메모리로 올릴 수 있게 해주니, 물리메모리보다 더 큰 용량의 프로세스가 구동될 수 있다.</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li>디스크에 접근하는 I/O → 디스크가 입출력을 할때 기다리지 않고 컨텍스트 스위칭</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%A7%80%EC%97%AD%EC%84%B1\">지역성</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">페이지 교체 알고리즘</a></p>\n<ul>\n<li><a href=\"#fifo\">FIFO</a></li>\n<li><a href=\"#optimal\">Optimal</a></li>\n<li><a href=\"#lru\">LRU</a></li>\n<li><a href=\"#lru-%EA%B7%BC%EC%82%AC\">LRU 근사</a></li>\n<li><a href=\"#lfu\">LFU</a></li>\n<li><a href=\"#mfu\">MFU</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A6%AC%ED%8E%98%EC%9D%B4%EC%A7%95prepaging\">프리페이징(Prepaging)</a></p>\n</li>\n<li>\n<p><a href=\"#swap%EC%9D%98-%EC%96%B4%EB%96%A4-%EC%9D%B4%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80\">Swap의 어떤 이점이 있는가?</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"February 06, 2022","title":"운영체제의 메모리 훔쳐보기 3편 - 페이지 교체 알고리즘","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/page-replacement-algorithm/"}},"prev":{"id":"2b1ab9c1-7d44-5a52-b72a-91915d8fa2ea","html":"<h2 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가며</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 423px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAG2BJkB/8QAFhABAQEAAAAAAAAAAAAAAAAAAAEx/9oACAEBAAEFAlXf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQABPyFX/9oADAMBAAIAAwAAABB8P//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQADAQEAAAAAAAAAAAAAAAEAESFxkf/aAAgBAQABPxBbetRtOnkO7n//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"마션\"\n        title=\"마션\"\n        src=\"/static/b7c4d40935bbbcbb299372593889fec7/b7bea/martian.jpg\"\n        srcset=\"/static/b7c4d40935bbbcbb299372593889fec7/4ec73/martian.jpg 180w,\n/static/b7c4d40935bbbcbb299372593889fec7/158ba/martian.jpg 360w,\n/static/b7c4d40935bbbcbb299372593889fec7/b7bea/martian.jpg 423w\"\n        sizes=\"(max-width: 423px) 100vw, 423px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>마션이라는 책에서 가장 유명한 파트이다. 그리고 나는 저 도입부에 <strong>100%</strong> 공감하고 있다.</p>\n<p>현장실습을 3월 2일자로 시작하면서, 이젠 돌이킬 수 없는 4학년이고 취업 전선에 뛰어든 신세다.<br>\n그렇기에 현장실습과 코딩테스트, CS 스터디를 두개씩 동시에 하고 있으며 개인 Spring 프로젝트를 준비하고 있다.</p>\n<p>그중에서도 빼놓을 수 업는 중요한 것은 Spring에 대한 공부라고 생각한다.<br>\n물론 Spring에 대한 지식이 전혀 없는 것은 아니다. 공부를 하면 했지, 절대 하지 않은 것은 아니다.<br>\n하지만 그럼에도 <strong>나는 왜 다시 스프링을 공부해야 하는가?</strong></p>\n<p>항상 참인 명제인 <em><strong>나는 생각보다 멍청하고, 배운것을 모조리 까먹는다는 것이다.</strong></em></p>\n<p>그렇기에 Spring의 1타 강사 아니 사실 인프런 1타 강사인것 같은 김영한 님의 강의를 듣기로 했다.</p>\n<blockquote>\n<p>물론 강의가 중요한 것은 아니지만, 내가 쌩돈 내면서 결제하면 그나마 열심히 할 것 같아서..</p>\n</blockquote>\n<p>그래서 공부한 것들을 내 <strong>기억이 아닌 기록</strong>에 의존하려 한다.</p>\n<h1 id=\"객체-지향-설계와-스프링\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\" aria-label=\"객체 지향 설계와 스프링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 설계와 스프링</h1>\n<h2 id=\"스프링의-진짜-핵심\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%A7%84%EC%A7%9C-%ED%95%B5%EC%8B%AC\" aria-label=\"스프링의 진짜 핵심 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링의 진짜 핵심</h2>\n<ul>\n<li>스프링은 자바 언어 기반의 프레임워크</li>\n<li>자바 언어의 가장 큰 특징 : 객체 지향 언어\n<ul>\n<li>즉, 스프링은 객체 지향 언어가 가진 강력한 특징을 살려냄으로써 <strong>좋은 객체 지향</strong> 어플리케이션을 개발할 수 있게 도와주는 프레임워크다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"좋은-객체-지향-프로그래밍은\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%80\" aria-label=\"좋은 객체 지향 프로그래밍은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋은 객체 지향 프로그래밍은…</h2>\n<p>프로그램을 단순히 명령어의 목록으로 보는것에서 벗어나, <strong>객체들의 모임</strong>으로 파악하는 것.<br>\n객체끼리는 메시지를 주고받으며 데이터를 처리한다.</p>\n<p>또 유연하고 변경이 용이하다는 특징이 있다… 이 난해한 말은 간단히 말해서 <strong>레고를 조립</strong>하듯이 프로그램을 개발하는 것이다.</p>\n<h2 id=\"다형성\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"다형성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성</h2>\n<p>실제 우리가 살고 있는 세계와 객체 지향은 완전히 대응시키기는 어렵지만,<br>\n실생활에서의 예제를 <strong>역할</strong>과 <strong>구현</strong>으로 나눠서 보면 좋다.</p>\n<p>운전자와 자동차들이 있다고 해보자.<br>\n운전자는 운전만 하고, 자동차는 굴러가기만 하면 되는것이다.</p>\n<p>즉, 타고 있는 <strong>자동차가 바뀌어도 운전자는 아무 신경쓰지 않고 그대로 운전을 할 수 있어야 한다.</strong></p>\n<p>다시 말해서 자동차의 <strong>구현</strong>과 운전자를 분리한 이유는 운전자가 자동차의 내부적인 동작 방식에 대해서 모르더라도 운전자에게 영향을 주지 않기 위함이다.</p>\n<p>이렇게 자동차가 K3,아반떼,벤츠,BMW … 등으로 운전자에게 영향을 주지 않고 자동차의 종류를 무한히 확장가능한 이것을 <strong>다형성</strong>이라고 한다.</p>\n<p>이를 통해서 새로운 자동차가 등장하더라도, <strong>운전자는 새로운 자동차의 내부적인 방식에 대해서 신경 쓸 필요가 전혀 없다.</strong> 그저 굴러가는 자동차일뿐이다.</p>\n<h3 id=\"달성하고자-하는-것\" style=\"position:relative;\"><a href=\"#%EB%8B%AC%EC%84%B1%ED%95%98%EA%B3%A0%EC%9E%90-%ED%95%98%EB%8A%94-%EA%B2%83\" aria-label=\"달성하고자 하는 것 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>달성하고자 하는 것</h3>\n<p><strong>역할</strong>과 <strong>구현</strong>으로 세상을 바라보면 세상이 <strong>단순</strong>해지고, <strong>유연</strong>해지고 <strong>변경</strong>이 편리하다.</p>\n<p>아까 운전자의 예시를 그대로 들면,</p>\n<ol>\n<li>운전자는 자동차라는 인터페이스의 역할만 알면 된다.</li>\n<li>운전자는 자동차의 내부 구조를 몰라도 된다.</li>\n<li>운전자는 자동차가 전기로 가든, 기름으로 가든, 뒤에서 밀어서 가든 내부구조가 변경되어도 영향을 받지 않게 된다.</li>\n<li>운전자는 자동차의 종류가 변하는 상황에서도 영향을 받지 않는다.</li>\n</ol>\n<p>자바에서는 <strong>역할</strong>은 인터페이스로, <strong>구현</strong>은 인터페이스를 구현한 클래스이다.</p>\n<h3 id=\"자바에서의-다형성\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"자바에서의 다형성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바에서의 다형성</h3>\n<p>대표적인 예시가 상위 클래스 혹은 인터페이스의 메소드를 재정의하는 <strong>오버라이딩</strong>이다.</p>\n<p>클라이언트는 서버의 인터페이스의 함수를 호출하면서, 서버 내의 메소드가 어떻게 구성되어있는지는 관심이 없으며, 서버는 <strong>런타임</strong>에 필요에 의해 <strong>구현을 유연하게 변경</strong>하여 적용할 수 있다.</p>\n<p>이를 통해 <strong>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경</strong>할 수 있다.</p>\n<h2 id=\"스프링과-객체-지향\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5\" aria-label=\"스프링과 객체 지향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링과 객체 지향</h2>\n<p>결국 가장 중요한 것은 <strong>다양성</strong>이다.</p>\n<p>스프링은 이 다형성을 극대화하게 이용할 수 있게 도와주는 것이다.<br>\n<strong>DI,IOC</strong>와 같은 개념들 역시 다형성을 서포트하는 기능들이다.</p>\n<h2 id=\"solid\" style=\"position:relative;\"><a href=\"#solid\" aria-label=\"solid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SOLID</h2>\n<p>로버트 마틴이 주장한 객체지향 설계 5가지 원칙을 앞 글자만 따서 SOLID라고 한다.</p>\n<h3 id=\"srp--단일-책임-원칙\" style=\"position:relative;\"><a href=\"#srp--%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\" aria-label=\"srp  단일 책임 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SRP : 단일 책임 원칙</h3>\n<p>한 클래스는 <strong>하나의 책임</strong>만을 가져야 하는데, 이 <strong>책임</strong>이라는 것은 모호하다. 문맥에 따라서 클 수도 있고, 작을 수도 있다.</p>\n<p>가장 중요한 기준은 <strong>변경</strong>이다. <strong>어떠한 변경점이 있을때 클래스에 미치는 파급효과가 적으면</strong> SRP를 잘 따른 것이다.</p>\n<blockquote>\n<p>하나의 클래스에 DB접근,View 로직,비즈니스 로직이 다 들어가 있다고 생각해보자.<br>\nDB에 변경점이 생기면, 클래스 전체가 바뀌어야 한다. SRP를 잘 지키지 못한 예시다.</p>\n</blockquote>\n<h3 id=\"ocp--개방-폐쇄-원칙\" style=\"position:relative;\"><a href=\"#ocp--%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\" aria-label=\"ocp  개방 폐쇄 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OCP : 개방 폐쇄 원칙</h3>\n<p><strong>가장 중요한 원칙이다.</strong><br>\n요소들이 <strong>확장에는 열려 있고 변경에는 닫혀</strong> 있어야 한다. 근데 확장을 하는데 어떻게 변경 없이 한다는 것일까?</p>\n<p>처음으로 돌아가서 다형성을 생각해보자.<br>\n운전자와 자동차의 관계에서 자동차의 모델이 바뀔때\n<strong>역할이 확장</strong>된다고 해도 기존의 자동차 모델 구현은 <strong>변경이 필요하지 않는 것이다.</strong></p>\n<p>인터페이스를 구현한 새로운 클래스를 만듦으로써 확장한다고 해보자.<br>\n<strong>그러면 인터페이스는 변경되지 않으며, 확장은 일어난다.</strong></p>\n<p>근데 이것이 정말 변경이 없을까? 요리를 예시로 들어보자.<br>\n예를 들어 고든 램지는 나에게 요리를 시키고, 나는 요리를 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">내 kitchen 인터페이스와 클래스가 이렇다고 해보자.\n\ninterface kitchen:    \n    func cook()\n\nclass fryKitchen :\n    @오버라이드\n    func cook():\n        fry()\n\nclass boilKitchen :\n    @오버라이드\n    func cook():\n        boil()\n\n램지 do : \nkitchen k= new fryKitchen()\n\nk.cook() -> kitchen 인터페이스 안에 있는 cook을 호출\n\n나는 kitchen 인터페이스 안에서 기존에는 구워서(fry()) 해서 만드는데,\n만약 삶아서 요리를 하는것으로 변경한다면?\n\n아마 코드는 이렇게 변할 것이다.\n\n램지의 do :\n# kitchen k = new fryKitchen()\nkitchen k = new boilKitchen()\n\nk.cook() -> kitchen 인터페이스 안에 있는 cook을 호출\n\n고든 램지의 행동은 여전히 같다. 하지만 k에 대해서 코드가 변경이 일어난다. 이상하다...</code></pre></div>\n<p>위 코드에서의 문제점은 <strong><code class=\"language-text\">kitchen</code>에 대한 구현 객체</strong>를 직접 선택하는데 있다.<br>\n<strong>내가 다형성을 사용한게 확실한데, OCP 원칙을 위반</strong>하는 것이다.</p>\n<p>이 문제를 해결하기 위해서는 객체를 생성하고 연관관계를 맺어주는 <strong>별도의 설정자, 조립자</strong>가 필요하다.</p>\n<h3 id=\"lsp--리스코프-치환-원칙\" style=\"position:relative;\"><a href=\"#lsp--%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99\" aria-label=\"lsp  리스코프 치환 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LSP : 리스코프 치환 원칙</h3>\n<p>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.</p>\n<p>이게 무슨 소리일까…</p>\n<p>아까 위의 요리 사례에서 <code class=\"language-text\">kitchen</code> 인터페이스의 메소드인 <code class=\"language-text\">cook()</code>은 어쨌든 요리를 만드는 메소드다.<br>\n<code class=\"language-text\">fryKitchen</code> 이건, <code class=\"language-text\">boilKitchen</code>이건 요리가 만들어져야 하는 것이다.</p>\n<p>내가 <code class=\"language-text\">kitchen</code> 인터페이스를 구현하면서 <code class=\"language-text\">cook()</code> 메소드를 요리가 아닌 음쓰를 만든다면?<br>\n<code class=\"language-text\">kitchen</code> 인터페이스를 믿고 사용할 수 있을까?<br>\n조금 타더라도, 조금 느리더라도 <code class=\"language-text\">cook()</code>을 호출하면 <strong>요리는 만들어져야</strong> 한다.</p>\n<blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 672px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 126.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAIAAAC+dZmEAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFn0lEQVQ4yxXNWXMThwEA4P0LLcOkJNAIR7YOW/e1a+1KWmkP7b3aXUmr+5YlWRKyDsuyTGMg2NDAQAwxsjH4dsABJtC0ncz0re1MMtO39qUMTTvTP9Lp9wc+IBgCSQrRTF3RG6dJyu/x2pwei8Vm9IBmkoK/vL9+cLx7dLJzcjY5PZucfrN79vLg9Ju907Odk9MJUGtkqgvJWIKPyOGNu+MHjzcLZTWEg2jIFVeZrx5tHh7tnJztnpxNXp4/e/Xm+M3bF2++O3n1ev/Fy6fAUrex1KvXF3McHwrhXpoLIn6XH3XjBFSuxB9vf3lwNDk8/n+7frM//rx7997Nrcebk6f3nh9uAYPl9uq411+u+f3uGd3VS5cu6g1ak1mHYeBgubY9uf/sYPvw+Mne/sNElCJCEB5GMdzHCVhMZYHB8Npo3BuvtQUhFMLnlRhdrCQGo+ZSv9ps527fuf70+eOD4+2V1U6EIyIszothJS5KMicpDDBeba2tdddvLosKLynB7qBYb2XXbvQHK410iu12a5O9rd1nW7E4E8IghieqzUo8FRVESk1KQLY2iGQ7PrZkhykEMleq0dGokctKDOGlMUgRiM61+s7eFs+hPthebZSqi2WGxRkWE8QwYPdSbm+A4Wiew2HIjiJugcZkgaICXjowH/ZBqNux3G9kklw2J5WruVhMFCVaEMMMiwE4BnMsnk4pAktyVIjGUDFMyGSQ9lglxM1DDgG0iS5znMeycTqmMNEoz3Ekz1NkOAj4EAjyOOxzegKFaNSrClRWZFWPJWk3pBzGrE3fQpwFr0PxgXIIpoNe37wL9NgQnweBPYDLbrGa9PMeG4MhJOxU6VCKCLYQ5yMS3FXQo5LwOoY+F/03WDTtdQTtcx7r3KxhWq/Xmi0GAHTZUR/kh0HIaqK8rjjuLxPofj7y4ejGh/3Rzy83//lF8fdl6o95ogw70jYdj7jMJuOU5rLbbQUyKSWfi/MMqb/8CTI7HUc8X2Dgn+923r99+P78t+93Vv51K78lwBvOzzbD87cwt0DjHEOEQr6IQAGKxAYQUBaYjCqHQVuFxa6L2Ekr+ff99f/+6cm/z2//507tDxJ8C9RvhKFYAJI4mmfIZFLOZqNAOhUr5JOJqFivFSsyU0Khhs/54/3BPx50fv7h6Yd327/rFQ5V8k6Ky1GwKmDJKJ9NKbVqpnutApQKaTUWEWgiGY0Mu/VmlN3IRM7ujt48XN9bqT3qFD4vqr2cnKSQGAm1FxLNhbQihv0IKHI4IAqUJLIST4sMPlpuff3VxtvzZz/95fsf3h5O7q3dHjZWm/ks4/fO/Lqe4X4zqg97NZ/XdVVzZeqzTwEMDzAMIUcYmacblezO5MF3rw//9tfv351P7t/sDhtpOQgaf/VL1DnbKkvDpeJoUCcwxGQyMFQAMJl0DpsJ9rqZMBZhw912+dWLJ+++nRRkkoJtfptO9/HFqxcvhP3uVjXWbWbjCjutnfpUc6W1mAFmZ3UWq9Fum4PnXTSB+iC3KoW7i+npTz66fOEXmosXpi59ZNZq/G7rYjk+7Fbbi3kS9yNe16BbAuZMOqfL6nHbUf+8qrApVSYxlAjABu3Vac1li37aPKPV67R6rSYTo5e75fFwcTxsjPrV9estwGDUOpwWj8cRROG0KlSKyXwmwTGkF3S57BadVmOfM8xop0iPqZmTVvsLw0F90K0O+5VSQQaMszNms8ED2gnMn0lE6tVcq1FNJmKCwJBEEEYgPBQI+GGZxes5qdcpDpcbo5V6sRBVFAKw2owOhznghwQ+nElF262Ffq/dalRLhWwqGY1GJUmRhIiQiYtZmSwV4+PVdr2ejkTwhWocgLx2BPGgQViW2HIh3essjoe98WCp06wtVPOFQiaVSqpqtJyLX2ukWs1cqZykKF82IySS3P8AKLkNB3Qu+VcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wow\"\n        title=\"wow\"\n        src=\"/static/599793b7cfdf1d3fe82e4c031b73117e/30d16/wow.png\"\n        srcset=\"/static/599793b7cfdf1d3fe82e4c031b73117e/e9ff0/wow.png 180w,\n/static/599793b7cfdf1d3fe82e4c031b73117e/f21e7/wow.png 360w,\n/static/599793b7cfdf1d3fe82e4c031b73117e/30d16/wow.png 672w\"\n        sizes=\"(max-width: 672px) 100vw, 672px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\nLSP를 위반한 대표적인 사례 : 와갤요리</p>\n</blockquote>\n<p>즉, 하위 클래스는 인터페이스 규약을 다 지켜야 하는 것이다.<br>\n단순히 컴파일 시점에서의 성공의 얘기가 아닌 의미론적으로 맞아야 한다는 것이다.</p>\n<h3 id=\"isp--인터페이스-분리-원칙\" style=\"position:relative;\"><a href=\"#isp--%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\" aria-label=\"isp  인터페이스 분리 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ISP : 인터페이스 분리 원칙</h3>\n<p>특정 클래스를 위한 인터페이스 여러 개가 범용적인 인터페이스 하나보다 낫다.</p>\n<p>간단히 얘기해서 인터페이스를 작게 분리함으로써 <strong>명확하게끔하고, 대체가능성을 높</strong>이라는 것이다.</p>\n<p>위의 예시를 요리와 서빙, 포장으로 나누어보자.\n<code class=\"language-text\">kitchen</code> 인터페이스와 <code class=\"language-text\">serve</code> 인터페이스와 <code class=\"language-text\">pack</code> 인터페이스를 각각 분리함으로써<br>\n각각의 인터페이스를 명확하게 하고, 적절히 조합함으로써 대체 가능성을 높이는 것이다.</p>\n<h3 id=\"dip--의존관계-역전-원칙\" style=\"position:relative;\"><a href=\"#dip--%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99\" aria-label=\"dip  의존관계 역전 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DIP : 의존관계 역전 원칙</h3>\n<p>OCP 만큼이나 중요한 원칙이다.</p>\n<p>프로그래머는 <em><strong>“추상화에 의존해야지, 구체화에 의존하면 안된다.”</strong></em> 의존성 주입은 이 원칙을 따르는 방법 중 하나다.</p>\n<p>앞서 이야기한 역할에 의존하게 해야한다는 것과 같은 맥락이다.<br>\n클라이언트가 인터페이스가 아닌 구현체에 의존하게 되면 변경이 어려워진다.</p>\n<p>즉, 고든 램지는 내가 요리를 한다는 것에만 관심이 있지 구워서 만들지, 삶아서 만들지에 대해서는 관심이 없어야 한다는 것이다.<br>\n<strong>구워서 만드는 것이 어떻게 이루어지는지, 삶는 방법은 어떤지에 대해서 관심 끄라는 얘기!</strong> <del>이세계 고든 램지</del></p>\n<p>아까의 OCP 사례가 문제점이 있다고 했으니 다시 가져와보자.</p>\n<p>램지의 행동을 잘 보면 <code class=\"language-text\">kitchen k</code> 는 구현 클래스인 <code class=\"language-text\">fryKitchen</code>과 <code class=\"language-text\">boilKitchen</code>에 의존하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">램지 do :\n# kitchen k = new fryKitchen()\nkitchen k = new boilKitchen()</code></pre></div>\n<blockquote>\n<p>여기서 의존한다라는 것은 강사님이 말하길 “저 코드를 알기만 하면 의존이다.”</p>\n</blockquote>\n<p>클라이언트인 고든 램지가 직접 어떤 구현 클래스를 선택할지 선택함으로써 클라이언트가 <code class=\"language-text\">fryKitchen</code>과 <code class=\"language-text\">boilKitchen</code>에 의존하고 있다.</p>\n<p>이 부분에서 <strong>DIP</strong>를 위반하는 것이다.</p>\n<h2 id=\"다형성만으로는-부족해\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1%EB%A7%8C%EC%9C%BC%EB%A1%9C%EB%8A%94-%EB%B6%80%EC%A1%B1%ED%95%B4\" aria-label=\"다형성만으로는 부족해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성만으로는 부족해</h2>\n<p>객체지향의 핵심은 다형성인것은 분명하지만, 다형성만으로는 쉽게 갈아끼우는 레고처럼 개발할 수 없다.<br>\n다형성만 사용해서는 구현 객체를 변경할때 클라이언트인 램지의 행동도 변경이 된다.<br>\n다형성만으로는 <strong>OCP,DIP</strong>를 지킬 수 없는 것이다.</p>\n<p>뭔가가 더 필요하다.. More and More</p>\n<h2 id=\"객체-지향-설계와-스프링-1\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-1\" aria-label=\"객체 지향 설계와 스프링 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 설계와 스프링</h2>\n<p>스프링은 <strong>DI(Dependency Injection)</strong> 을 이용해서 OCP,DIP를 가능하게끔 해준다.<br>\n즉, 우리가 원하는 대로 레고를 조립하듯이 개발을 할 수 있게끔 해준다.</p>\n<blockquote>\n<p>DI 개념은 솔직히 공부만으로는 잘 이해가 안간다. 면접에서 받은 질문 중에 하나..</p>\n</blockquote>\n<p>앞으로 코드를 직접 작성해보면서 의존성 주입을 이해하며 스프링의 재미를 느끼고 싶다. <del>아니 느껴야 한다.</del></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\">들어가며</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%A7%84%EC%A7%9C-%ED%95%B5%EC%8B%AC\">스프링의 진짜 핵심</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%80\">좋은 객체 지향 프로그래밍은…</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\">다형성</a></p>\n<ul>\n<li><a href=\"#%EB%8B%AC%EC%84%B1%ED%95%98%EA%B3%A0%EC%9E%90-%ED%95%98%EB%8A%94-%EA%B2%83\">달성하고자 하는 것</a></li>\n<li><a href=\"#%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1\">자바에서의 다형성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5\">스프링과 객체 지향</a></p>\n</li>\n<li>\n<p><a href=\"#solid\">SOLID</a></p>\n<ul>\n<li><a href=\"#srp--%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\">SRP : 단일 책임 원칙</a></li>\n<li><a href=\"#ocp--%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\">OCP : 개방 폐쇄 원칙</a></li>\n<li><a href=\"#lsp--%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99\">LSP : 리스코프 치환 원칙</a></li>\n<li><a href=\"#isp--%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\">ISP : 인터페이스 분리 원칙</a></li>\n<li><a href=\"#dip--%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99\">DIP : 의존관계 역전 원칙</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1%EB%A7%8C%EC%9C%BC%EB%A1%9C%EB%8A%94-%EB%B6%80%EC%A1%B1%ED%95%B4\">다형성만으로는 부족해</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\">객체 지향 설계와 스프링</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"March 04, 2022","title":"스프링 핵심 원리 - 기본편 : 객체 지향 설계와 스프링","categories":"Spring","author":"weasel","emoji":"📓"},"fields":{"slug":"/spring-core-chap1/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/GIL/","nextSlug":"/page-replacement-algorithm/","prevSlug":"/spring-core-chap1/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}