{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/GIL/",
    "result": {"data":{"cur":{"id":"5a4dee1d-16e6-5c3a-ab6c-8868ee79a5f5","html":"<p><strong>GIL</strong>은 Global Interpreter Lock의 약자이다.</p>\n<p>Global이 붙으니 전역적이라는 의미이고, Lock을 사용하니 무언가를 제한한다는것은 알겠는데 Interpreter는 뭘까?\n인터프리터에 대해서 제한을 건다는 것이 어떤 의미일까?</p>\n<p>아래에서 쭉 알아보자.</p>\n<h2 id=\"interpreter\" style=\"position:relative;\"><a href=\"#interpreter\" aria-label=\"interpreter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interpreter</h2>\n<p>짧게 얘기하면 <strong>Python 인터프리터는 코드를 한 줄씩 읽으면서 실행</strong>하는 프로그램이다.</p>\n<blockquote>\n<p>이 방식때문에 인터프리터 언어가 느리단 얘기가 나오는 것이고, Java에서 이를 개선해서 등장한 방식이 JIT다.</p>\n</blockquote>\n<p>이 인터프리터의 구현체는 여러가지가 있는데 대표적인 구현체가 C로 구현한 것이고, 이를 <strong>CPython</strong>이라고 한다.</p>\n<p>이 글에서는 CPython 기준으로 설명할 것이다.</p>\n<blockquote>\n<p><a href=\"https://wiki.python.org/moin/GlobalInterpreterLock\">Python 위키</a> 항목을 읽어보면 <em><strong>Non-CPython implementations</strong></em>에 Jython, IronPython은 GIL이 없고, PyPy는 CPython과 비슷한 GIL을 가지고 있다. 또 Cython에는 CIL이 존재하지만, <code class=\"language-text\">with</code> 키워드를 이용하여 잠시동안 해제가 가능하다고 한다.</p>\n</blockquote>\n<p>대충 인터프리터가 어떤 의미인지는 알았으니 본론으로 들어가서 GIL에 대해서 알아보자.</p>\n<h2 id=\"gil\" style=\"position:relative;\"><a href=\"#gil\" aria-label=\"gil permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GIL</h2>\n<p><a href=\"https://wiki.python.org/moin/GlobalInterpreterLock\">Python 위키</a>를 계속 참고해보면, 이렇게 정의하고 있다.</p>\n<blockquote>\n<p>In CPython, the <strong>global interpreter lock</strong>, or <strong>GIL</strong>, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. The GIL prevents race conditions and ensures thread safety. A nice explanation of <a href=\"https://python.land/python-concurrency/the-python-gil\">how the Python GIL helps in these areas can be found here</a>. In short, this mutex is necessary mainly because CPython’s memory management is not thread-safe.</p>\n</blockquote>\n<p>중요한 부분 위주로 해석을 해보면,</p>\n<p>GIL은 CPython에서 객체들에 대한 접근을 보호하는 뮤텍스(Mutex)로써, 여러개의 쓰레드가 동시에 파이썬의 바이트코드를 실행하는 것을 방지하는 역할이라는 것이다.<br>\n따라서 GIL은 경쟁 상태에 진입하는 것을 막아주고, 쓰레드 안전성을 보장한다.<br>\n또 간단하게 말해서, <strong>CPython의 메모리 관리가 쓰레드-안전이 아니기 때문에</strong> 뮤텍스가 필요하다는 것이다.</p>\n<p>더 간단하게 말하면, <em>Python 인터프리터에 대해서 전역적으로 잠금</em>이 걸리기 때문에 <strong>한 시점에 오직 하나의 쓰레드만 인터프리터를 실행할 수 있다.</strong></p>\n<p>또 이어지는 설명에서 이렇게 설명을 한다.</p>\n<blockquote>\n<p>In hindsight, the GIL is not ideal, since it prevents multithreaded CPython programs from taking full advantage of multiprocessor systems in certain situations.</p>\n</blockquote>\n<p>해석해보자면 돌이켜보았을때 GIL은 멀티쓰레딩 CPython 프로그램이 특정 상황에서 <strong><em>멀티프로세서 시스템의 장점을 다 사용하지 못</em></strong> 하게끔 하기 때문에 GIL은 이상적이지 않다.</p>\n<blockquote>\n<p>여기서 말하는 멀티프로세서 시스템의 장점은 <strong>멀티 쓰레딩 동작을 할때 여러 개의 쓰레드가 각각의 프로세서 상에서 병렬적으로 실행됨</strong>을 의미한다.</p>\n</blockquote>\n<p>즉, <strong>GIL 때문에 CPython에서는 그러한 병렬적인 실행이 불가능하다는 것이다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB8ElEQVQ4y31TPW/UQBC9Bv4S/AcIFb8BUSJ+AmmCoKUIJZQkUHGKQEgIEqCAIwV0BO7OF1vx2V5/2/v50MydLZ8u8KQn7e7svJmdmR3VdY0oiuD7PqSUMMZAa83rpmmYbdv2e1r/i1VVYUSCDkBelvDOz1f0PHZ2ziEMQwRBwGcUmM6stVskkNaIHHvUDWxdI8syzpSglOI9kdb/A2mNtJR48mOCO++PcPfjWzz9eYqmLCGyHMY6zlykGTsMszPWolUabr0nGwsaqXDv5B2uHT7D9ZfPcf/DG2RxjEik0NYiSgSCcLkSMaYX1MagblV/3gvKtoVflfi+vMDp8gJBVXI22jooY0HVMQ5c5yFIQGqz/WSnFG6OD3Bl/xGu7j/G7aNXbAzjBGe//yARKRqpuH7U/SEpc5oOaliapjwJnOGvTODY93AcLHCWCRak6NpYzpJ4GZRx2xkaKfHg6wl2xge4NT7E3uQzG6tWolUKUmsUVY04jpEkSU8aJ5EV/PSNGpLg7rdPuPH6BT/94eTLKhqJKQ2lqfiSxybPc2ZRFBBCIC8rvrvR5Y05XMOsB5UiU+3o8mWgOg4Huxd03EnH7CZ+sfAwm82Y5DgEZTefzzGdTrkpXUAWJGfqTvcfuzU9i1iW5ZadHDs7/V86I9Jf/guSa978g3z/uwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/135772f5932488ef9186461afe7f1027/37523/example_gil.png\"\n        srcset=\"/static/135772f5932488ef9186461afe7f1027/e9ff0/example_gil.png 180w,\n/static/135772f5932488ef9186461afe7f1027/f21e7/example_gil.png 360w,\n/static/135772f5932488ef9186461afe7f1027/37523/example_gil.png 720w,\n/static/135772f5932488ef9186461afe7f1027/302a4/example_gil.png 1080w,\n/static/135772f5932488ef9186461afe7f1027/6be49/example_gil.png 1160w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"gil의-필요성\" style=\"position:relative;\"><a href=\"#gil%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"gil의 필요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GIL의 필요성</h3>\n<p>괜히 멀티쓰레딩만 방해하고, GIL은 대체 왜 있는걸까?</p>\n<p>이것에 대한 해답은 아까 말한 정의에 나와있다.</p>\n<p><strong><em>GIL is … mutext that protects access to Python Objects.</em></strong></p>\n<p>Python에서 모든 것은 객체로 존재하고, <a href=\"https://github.com/python/cpython/blob/main/Include/object.h\">CPython에서 각각의 객체들이 C 구조체를 통해 만들어진다는 것을 생각해보면,</a> 수 많은 객체에 대응되는 수 많은 구조체가 있음을 알 수 있다.</p>\n<p>그러면 자연스럽게 메모리 관리를 생각하게 된다.</p>\n<p>Python에서 메모리 관리는 참조 횟수(reference count)를 이용해 GC(Garbage Collection)를 수행하는데, 이 참조 횟수가 C 구조체 안에 적혀 있다.\nCPython의 소스코드를 확인해보면 이렇게 코드가 나와있다.</p>\n<blockquote>\n<p><a href=\"https://github.com/python/cpython/blob/main/Include/object.h\">https://github.com/python/cpython/blob/main/Include/object.h</a></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_object</span> <span class=\"token punctuation\">{</span>\n    _PyObject_HEAD_EXTRA\n    Py_ssize_t ob_refcnt<span class=\"token punctuation\">;</span>\n    PyTypeObject <span class=\"token operator\">*</span>ob_type<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> PyObject<span class=\"token punctuation\">;</span></code></pre></div>\n<p>잘 보면 PyObject 구조체 안에 참조 횟수를 <strong>직접 저장</strong>하고 있다.</p>\n<p>운영체제를 열심히 들으신 분이라면 바로 왜 위에서 언급한 <strong>경쟁 상태</strong>가 생길수 있는지 아실 것이다.</p>\n<p>만약 CPython의 의도와는 정반대로 여러개의 쓰레드가 동시에 Python 인터프리터를 실행한다면,<br>\n참조 횟수에 병렬 프로그래밍의 고질적 문제 중 하나인 <a href=\"https://becomeweasel.me/mutex-and-semaphore/#race-condition\"><strong>경쟁 상태</strong></a>가 발생하게 된다.</p>\n<p>단순히 여기서 그치는 것이 아니라 아까 Python GC의 원리가 참조 횟수에 기반을 둔다는 점을 다시 생각한다면,\n<strong>올바르지 않은(비정합적인)</strong> 참조 횟수를 기반으로 GC가 일어남으로써 <strong>GC가 의도한 바와는 다르게 동작할 수 있다는 것이다.</strong></p>\n<p>그렇다고 객체에 대해서 작업을 할때, 좀 더 좁게 말하자면 <strong><code class=\"language-text\">ob_refcnt</code>에 대한 작업을 수행할때마다</strong> 별도의 뮤텍스를 이용해서 Lock을 얻고 해제한다면 비효율적이고, 프로그래머가 일일이 제어하기에는 부담이 가는 작업이다.</p>\n<p>그렇기에 CPython에서는 <strong>한 쓰레드가 인터프리터를 실행 중일때는 다른 쓰레드가 실행하지 못하도록 인터프리터를 잠궈버렸다.</strong><br>\n이렇게 된다면, 객체의 참조 횟수에 대한 경쟁 상태 역시 고려할 필요가 없어진다.</p>\n<blockquote>\n<p>GIL을 선택한 이유에 대해서 조금 더 자세하게 알아보자면, 이 <a href=\"https://softwareengineering.stackexchange.com/questions/186889/why-was-python-written-with-the-gil\">링크</a>와 이 <a href=\"https://realpython.com/python-gil/\">링크</a>를 참조하면 된다.</p>\n</blockquote>\n<blockquote>\n<p>짧게 얘기하자면, Python을 처음 만들때는 쓰레드라는 개념이 인기 있기 전이였고, 그 후에 쓰레드가 등장했을때 가장 <strong>현실적이고 쉬운</strong> 방법이 GIL이였다.</p>\n</blockquote>\n<p>첨언하자면, 왜 GIL이 아닌 다른 해결책을 도입하지 않냐고 하자 Python의 개발자인 <a href=\"https://en.wikipedia.org/wiki/Guido_van_Rossum\"><strong>Guido van Rossum</strong></a>은 이렇게 말했다고 한다.</p>\n<blockquote>\n<p>”단일 쓰레드 프로그램에서(그리고 I/O 바운드 멀티 쓰레드 프로그램) 성능이 저하되지 않는 GIL 해결책을 가지고 오면, 그 해결책을 기쁘게 받아들이겠다.”</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#interpreter\">Interpreter</a></p>\n</li>\n<li>\n<p><a href=\"#gil\">GIL</a></p>\n<ul>\n<li><a href=\"#gil%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\">GIL의 필요성</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"GIL은 Global Interpreter Lock의 약자이다. Global이 붙으니 전역적이라는 의미이고, Lock을 사용하니 무언가를 제한한다는것은 알겠는데 Interpreter는 뭘까?\n인터프리터에 대해서 제한을 건다는 것이 어떤 의미일까? 아래에서 쭉 알아보자. Interpreter 짧게 얘기하면 Python 인터프리터는 코드를 한 줄씩 읽으면서 실행하는 프로그램이다. 이 방식때문에 인터프리터 언어가 느리단 얘기가 나오는 것이고, Java에서 이를 개선해서 등장한 방식이 JIT다. 이 인터프리터의 구현체는 여러가지가 있는데 대표적인 구현체가 C로 구현한 것이고, 이를 CPython이라고 한다. 이 글에서는 CPython 기준으로 설명할 것이다. Python 위키 항목을 읽어보면 Non-CPython implementations에 Jython, IronPython은 GIL이 없고, PyPy는 CPython과 비슷한 GIL을 가지고 있다. 또 Cython에는 CIL이 존재하지만…","frontmatter":{"date":"February 08, 2022","title":"GIL 훔쳐보기","categories":"Python","author":"weasel","emoji":"📓"},"fields":{"slug":"/GIL/"}},"next":{"id":"01585043-5594-5707-8533-9be6484f7713","html":"<p><a href=\"https://becomeweasel.me/virtual-memory/\">이전편 : 가상 메모리</a></p>\n<h2 id=\"지역성\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EC%97%AD%EC%84%B1\" aria-label=\"지역성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>지역성</h2>\n<p>페이지 교체 알고리즘에 대해 언급하기 전에 먼저 <strong>지역성</strong>이라는 것에 대해서 알아야 한다.</p>\n<ul>\n<li><strong>시간 지역성</strong> (Temporal Locality ) : 현재 참조된 메모리가 <strong>가까운 미래내에 참조</strong>될 가능성이 높음\n<ul>\n<li>loop,subroutine,stack</li>\n</ul>\n</li>\n<li><strong>공간 지역성</strong> (Spatial Locality) : 하나의 메모리가 참조되면 <strong>주변의 메모리가 참조</strong>될 가능성이 높음\n<ul>\n<li>Array 순회, 명령어의 순차실행</li>\n</ul>\n</li>\n</ul>\n<p>프로그램의 메모리 참조는 고도의 지역성을 가진다. 임의의 시간 Δt 내에 프로그램의 <strong>일부분만을 집중적으로 참조</strong>한다는 것이다.<br>\n이러한 지역성이 있기 때문에 적절한 페이지 교체 알고리즘이 중요하다.</p>\n<p>왜 중요할까?<br>\n예를 들어서 주기적으로 두개의 페이지만 참조하는 로직이 있다고 해보자.<br>\n만약 그 두개의 페이지를 번갈아가면서 교체를 한다면, 페이지 폴트는 두 개의 페이지에 대해서 접근할때마다 계속 일어날 것이다.</p>\n<p>이게 왜 위험하냐면, <strong>불필요한 I/O 작업의 오버헤드도 있고, 그때마다 컨텍스트 스위칭</strong>이 계속 일어나기 때문이다.</p>\n<h2 id=\"페이지-교체-알고리즘\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"페이지 교체 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 교체 알고리즘</h2>\n<p>페이지 폴트가 났을때, 메모리에 빈공간이 있으면 올리면 되는 일이다. 물론 I/O가 들어가긴 하지만.\n근데 만약 <strong>모든 메모리가 사용중</strong>이라면 교체될 페이지를 골라야하는데, 이걸 잘 고르는게 성능에 큰 영향을 미친다.</p>\n<p>그러므로 원하는 것은 <strong>가장 낮은 페이지 폴트 확률</strong>이다. 모든 예시에서 <code class=\"language-text\">[1,2,3,4,1,2,5,1,2,3,4,5]</code> 의 순서로 페이지가 필요로 한다고 해보자.</p>\n<p>일반적으로 프레임의 개수가 많으면, 페이지 폴트의 빈도도 줄어든다.</p>\n<blockquote>\n<p>다만 정비례 하는것은 아니다. 이는 ‘벨라디의 모순’과 연관되어 있다.</p>\n</blockquote>\n<h3 id=\"fifo\" style=\"position:relative;\"><a href=\"#fifo\" aria-label=\"fifo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FIFO</h3>\n<ul>\n<li>단순하게 페이지 교체를 할 때 <strong>가장 오래된 페이지를 선택해 교체</strong>한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABwElEQVQoz42TCY/TMBCF8/9/F4uEQEgVaQv0gG1qO3HuHrns5EN2S3e3dCVGGtkazzzPe2MHy+WC+XzBdvuLzWbLZr0hzwuEEH5VSpGmKalOkVKRxAmDMYRh6H21WrFer5nNZmRZRhBFe8ReIIVCqZjNdutBdlGEktKD7IUgjhOkcnt5AxZC0vcD1lqMMTgLeMdOTUV91HS9ZRxH/semaSJwyX/dBWDCmJGi0tQHRdsNnqIxFqE0QqUkWYm1LzWvPbi/wZm1E3mpyUvBuek9oLOmaen6gWsaj2oDp4fTUOv0duDO2q7l3J4v3V+T3b6qj8RpgdI5MsnIy8MNzHfYth1t29J13e02J9npXHA8ZZ6yE/3S+eiH4Og3rq7r6YfhLeD7lGOqOqFpB4bBeKBIat+V0/CO8Avle1EdX2NHsiImK9yzMD5ux5Gu6y/e90x3A3nY4WvKRZWQVwpjp8dP5Or/DCVWiiRJ0VqT57n/EXV9QCmBVIK6rn0szQtsEsPuN5OOIYmZ5B4bPTNW5UuHriCKIhbzJeG3kJ+rlf8py+V3wnDuY7vnyNNsypLll898/fjEjzDk09MHTlV109AB/gGO+5zhUiAitwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/37523/1.png\"\n        srcset=\"/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/e9ff0/1.png 180w,\n/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/f21e7/1.png 360w,\n/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/37523/1.png 720w,\n/static/bca7af28f36efdc1d6b6c3e1e5e1a1f8/58213/1.png 902w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></li>\n<li>근데 프레임이 3개일때와 4개일때를 비교해보면, <strong>프레임이 늘었는데도 오히려 페이지 폴트가 증가했다. → 이것을 ‘벨라디의 모순’현상이라 한다.</strong></li>\n<li>즉 투입한 리소스와 효과가 비례하지 않음을 알 수 있고, 적절한 교체 알고리즘을 선택하는것이 중요함을 보인다.</li>\n</ul>\n<h3 id=\"optimal\" style=\"position:relative;\"><a href=\"#optimal\" aria-label=\"optimal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optimal</h3>\n<ul>\n<li>가장 오랫동안 사용되지 않을 (페이지 교체가 필요한 시점으로부터) 페이지를 선택한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABoElEQVQoz42Sy27bMBBF9f8fUqABumgW7b7rdhk4sBxHrmzrYVmi+BL1oE4hwg5qw4sMMLicAXln7gyjoizZ7/fkecFutyNJEqztGIYB51zwvu/pui7gPM8sdsV7i+4T1lqaRtC2Etm2F5Q0dYOUCu/9B+Ej0qhzjlkrvOvwRsMwsFxrVYbr3cMu/ie7nq8e9QthfQ6B14q5d4yT59wkuL4Lj4ztKCpBVbdIbW+I/B0GyfNCepGy2DhOnOod0zSEWCnN6/qNoqhQyqCVxk/+8QyXxr1omKfpo+o4jhTVG8YaFmVLThnFtkipZM2xKtjXBYU8814dOIoTq2zLOI2XpZQ5KHlTSZvzzQz97KlNy0k1lKqmtYqzFqR1Tm0kB1Ey+olICBG2qYRGSosQirZVjOOMkob9PiNND0HqZyzabDas1+9st79Yx1+J10/E8RNp+szf9HvIva6+EMffKPKf5PkPjtkzdftCbTRJdeDQlMhOX75N12Ht8oErrM2w9oQxJdaW2K7EuVNwKTOUKtC6DOh6RSkb/uxW/E5eqJQIW/4HhkoC0jDh6SkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/119b448614681a08121f38cfc6f5d979/37523/2.png\"\n        srcset=\"/static/119b448614681a08121f38cfc6f5d979/e9ff0/2.png 180w,\n/static/119b448614681a08121f38cfc6f5d979/f21e7/2.png 360w,\n/static/119b448614681a08121f38cfc6f5d979/37523/2.png 720w,\n/static/119b448614681a08121f38cfc6f5d979/71c8e/2.png 875w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></li>\n<li>가장 이상적인 알고리즘이기 때문에 가장 낮은 페이지 폴트를 보여준다.</li>\n<li>그렇지만, 다음에 무엇을 사용할지 알 수 없기 때문에 <strong>구현이 어렵고</strong> Optimal은 다른 알고리즘과의 성능비교의 기준으로 사용된다.</li>\n<li><strong>만약, 같은 행동을 반복하는 Bot의 형태고, 메모리 예측을 완벽하게 알 수 있다면 적용할 수 있다.</strong></li>\n</ul>\n<h3 id=\"lru\" style=\"position:relative;\"><a href=\"#lru\" aria-label=\"lru permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU</h3>\n<p>LRU는 <strong>Least Recently Used</strong>의 약자로 페이지 교체를 하는 시점에서<br>\n가장 덜 최근에 사용된것, 다시 말해 <strong>가장 오래전에 사용한 것</strong> 페이지를 선택해 교체하는 알고리즘이다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABPElEQVQoz32O2U6DUBRF+f/f8dlUq9FUwSrQwZYivUyX4VKg2DSpsAzO2sSd7IeTs/c6Rzs7H/JgWpiWxa1uMLy4RNd1HPeJZrcj3xSsAo/RwuTOmTMTDrpjcT65wXBsLmYGJ8aA6/kY21ugiTDFCyRxqhChJJQZVbMjT1KkL/HdCLVcEoY+/jpmv5U8H/ZEVUbelMwTj4dgQbItaLsOjT9qQo9qPaNuMqJohdpIgskVG2/6tu9eDu/BruNIHWg9tXfXtv2MerSJpyPirSSIHpFlhBAWReZ/cLp/rX2H2rdCsZyS3gwoVxZCedTuPYk/YdMUv4Bt/8AP0Od8DFzYZKNTto6JsMdUjkEsTIo6+wC2/Cft59Vepf9Eup6T1jny3iRRCXHuU9bFVykIAlzXpaoqlFKUZYkQgjzPeQUDwhDgw5w1kgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/38254e624e1790e808285a7052ea5bf0/37523/3.png\"\n        srcset=\"/static/38254e624e1790e808285a7052ea5bf0/e9ff0/3.png 180w,\n/static/38254e624e1790e808285a7052ea5bf0/f21e7/3.png 360w,\n/static/38254e624e1790e808285a7052ea5bf0/37523/3.png 720w,\n/static/38254e624e1790e808285a7052ea5bf0/90712/3.png 882w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>Optimal을 제외하고 굉장히 좋은 성능을 보이는데, 그 이유는 LRU가 <strong>Temporal Locality를 전제로 하고 있기 때문이다.</strong> <strong>최근에 사용된것은 다시 참조될 가능성이 크니,</strong> 반대로 가장 오래전에 사용한것을 지우면서 페이지 교체 자체를 줄이려는 것이다.\n<ul>\n<li>그런데 문제점은 <strong>LRU를 실제로 구현하는데에 있다.</strong>\n<ul>\n<li>예를 들어 모든 페이지에 참조된 시간을 적어놓는다면, 페이지 테이블에 추가적인 메모리가 들것이고 (min heap으로 컷해도 될듯) 참조될때마다 이것을 계속 수정하는 오버헤드가 있다.</li>\n<li>만약 Linear하게 가장 오래전에 사용된 것을 찾는다고 해보자.</li>\n<li>이때의 시간복잡도는 <code class=\"language-text\">n</code>개의 페이지에 대해서 <code class=\"language-text\">O(n)</code>인데, 이 N 값이 의미하는 것은 프로세스의 개수이고 보통 너무 크다는데 있다.</li>\n</ul>\n</li>\n<li><strong>그러므로 커널에 구현하기는 시간적/공간적 오버헤드가 너무 크다. 따라서 근사치 모델이 필요하다.</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lru-근사\" style=\"position:relative;\"><a href=\"#lru-%EA%B7%BC%EC%82%AC\" aria-label=\"lru 근사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU 근사</h3>\n<ul>\n<li>카운터 구현\n<ul>\n<li>메모리 참조가 일어날때마다 CPU counter를 올리고, 페이지 A가 참조되면 페이지에 카운터를 덮어씌운다.</li>\n<li>O(n)의 조회방식, 심지어 그때마다 메모리 액세스가 한번 더 일어남.</li>\n</ul>\n</li>\n<li>스택 구현\n<ul>\n<li>페이지 번호로 <a href=\"https://becomeweasel.me/array-and-linked-list/#doubly-linked-list\">Doubly Linked List</a> 형태로 스택을 구현한다.</li>\n<li>페이지 A가 참조되면, A를 헤드로 옮긴다.\n<ul>\n<li>이때 6번의 포인터 움직임이 필요하다.</li>\n</ul>\n</li>\n<li>찾는데 드는 오버헤드는 없지만, 매번의 페이지 참조마다 6번의 메모리 액세스가 있다.</li>\n<li><strong>교체가 일어나지 않아도 평소 오버헤드가 너무 크다.</strong></li>\n</ul>\n</li>\n<li><strong>두번째 기회 (Second Chance)</strong>\n<ul>\n<li>기본적으로 FIFO다.</li>\n<li>페이지를 <strong>원형의 큐</strong>로 구성한다.</li>\n<li>페이지 테이블 내의 모든 페이지의 Ref bit를 초기값 0으로 할당하고, 참조가 되면 1로 바꾼다.</li>\n<li>참조비트가 <strong>0인 페이지를 찾으면, 그 페이지를 교체</strong>한다.</li>\n<li><strong>만약 1이라면, 그 페이지는 0으로 바꾸고 한번 더 돈다. 한번의 기회를 더 주는것이다.</strong></li>\n<li>한번 더 돌았을때도, 0이면 교환한다.</li>\n<li>그런데 모든 <strong>bit가 1인 경우를 생각해보면, FIFO의 알고리즘처럼 동작한다.</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lfu\" style=\"position:relative;\"><a href=\"#lfu\" aria-label=\"lfu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LFU</h3>\n<ul>\n<li>전제는 <strong>많이 사용되는 페이지는 더 많이 사용될 것</strong>이라는 전제</li>\n<li>페이지에 참조된 횟수를 나타내는 카운터를 넣는다.</li>\n<li>가장 카운터가 적은 페이지를 교체한다.</li>\n<li>하지만 어떠한 페이지가 집중적으로 참조되다가 그 뒤에도 사용되지 않으면 어느정도까지 계속 머무르는 경향이 일어난다. 즉 전제와 어긋나게 된다.</li>\n</ul>\n<h3 id=\"mfu\" style=\"position:relative;\"><a href=\"#mfu\" aria-label=\"mfu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MFU</h3>\n<ul>\n<li>전제는 <strong>카운터가 작은 페이지는 이제 막 들어왔고, 사용되지 않았다</strong>는 전제.</li>\n<li>페이지에 참조된 횟수를 나타내는 카운터를 넣는다.</li>\n<li>가장 카운터가 큰 페이지를 교체한다.</li>\n<li><strong>Locality가 자주 변하는 시스템에서 유용하다.</strong></li>\n</ul>\n<h2 id=\"프리페이징prepaging\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%AC%ED%8E%98%EC%9D%B4%EC%A7%95prepaging\" aria-label=\"프리페이징prepaging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프리페이징(Prepaging)</h2>\n<p>프로세스가 시작될때는 항상 initial page fault가 난다. 아무것도 안올라와 있기 때문에..</p>\n<p>이것을 방지하기 위해서, 프로세스가 필요로 하는 페이지의 전부 혹은 일부를 참조되기전에 미리 메모리에 올리는것이다.</p>\n<p>물론, 페이지가 사용되지 않으면 낭비가 있다.</p>\n<h2 id=\"swap의-어떤-이점이-있는가\" style=\"position:relative;\"><a href=\"#swap%EC%9D%98-%EC%96%B4%EB%96%A4-%EC%9D%B4%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80\" aria-label=\"swap의 어떤 이점이 있는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swap의 어떤 이점이 있는가?</h2>\n<ul>\n<li>장점\n<ul>\n<li>가상 메모리를 만들고 유지하는데 도움이 된다. 그렇기에 더 많은 프로세스가 구동될 수 있다.</li>\n<li>실제 필요한 메모리용량만큼만 디스크에서 메모리로 올릴 수 있게 해주니, 물리메모리보다 더 큰 용량의 프로세스가 구동될 수 있다.</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li>디스크에 접근하는 I/O → 디스크가 입출력을 할때 기다리지 않고 컨텍스트 스위칭</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%A7%80%EC%97%AD%EC%84%B1\">지역성</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">페이지 교체 알고리즘</a></p>\n<ul>\n<li><a href=\"#fifo\">FIFO</a></li>\n<li><a href=\"#optimal\">Optimal</a></li>\n<li><a href=\"#lru\">LRU</a></li>\n<li><a href=\"#lru-%EA%B7%BC%EC%82%AC\">LRU 근사</a></li>\n<li><a href=\"#lfu\">LFU</a></li>\n<li><a href=\"#mfu\">MFU</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A6%AC%ED%8E%98%EC%9D%B4%EC%A7%95prepaging\">프리페이징(Prepaging)</a></p>\n</li>\n<li>\n<p><a href=\"#swap%EC%9D%98-%EC%96%B4%EB%96%A4-%EC%9D%B4%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80\">Swap의 어떤 이점이 있는가?</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"February 06, 2022","title":"운영체제의 메모리 훔쳐보기 3편 - 페이지 교체 알고리즘","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/page-replacement-algorithm/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/GIL/","nextSlug":"/page-replacement-algorithm/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}