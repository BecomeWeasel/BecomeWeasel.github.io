{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/btree/",
    "result": {"data":{"cur":{"id":"2eca3e50-54f4-5b20-b093-d5250a2cae1e","html":"<h2 id=\"why-b-트리\" style=\"position:relative;\"><a href=\"#why-b-%ED%8A%B8%EB%A6%AC\" aria-label=\"why b 트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why B 트리?</h2>\n<p>B 트리는 이진트리와 다르게 하나의 노드에 많은 정보를 가질 수 있는 트리를 의미한다.<br>\n노드의 최대 자식의 개수를 <code class=\"language-text\">M</code>이라고 할때, <code class=\"language-text\">M</code>차 B트리라고 한다.</p>\n<p>B 트리는 <strong>고전적인 메모리 계층 구조의 물음에서 출발한다.</strong><br>\n이진탐색트리의 시간복잡도가 최악이 될 때는 노드가 편향된 경우인데, 이를 해결하는 것이 AVL,RB 트리와 같은 균형이진트리다.</p>\n<p>그런데 이것만으로 부족하다. 왜 그러냐면, <code class=\"language-text\">O(logn)</code> 을 보장하는 균형이진트리의 최악을 생각해보자.<br>\n최악이 있을까? 분명히 있다.</p>\n<p>RB트리에서 원소가 1백만개라고 해보면, 트리의 높이는 최대 <code class=\"language-text\">2*log(10^6)</code>이다. 따라서 대략 20정도이다.</p>\n<blockquote>\n<p>RB 트리에서 Red 노드는 최대 두개만 연속으로 되어있음을 생각하면 쉽게 알 수 있다.</p>\n</blockquote>\n<p>그러면, 원하는 원소를 찾기 위해서 20번 정도의 노드 액세스가 필요한데,<br>\n만약 모든 노드가 메인 메모리에 있다고 생각해보면, <strong>매우 비싼 20번의 메모리 접근</strong>이 일어나는 것이다.</p>\n<p>심지어 메인 메모리가 아닌 디스크에 있다면? <strong>더 많은 시간이 단순히 노드에 접근하는데 쓰일 것이다.</strong></p>\n<p>따라서 이러한 메모리, 디스크에 관한 접근을 줄여야 한다. 그러기 위해서는 <strong>트리의 탐색 높이를 줄여야 한다.</strong><br>\n이진트리에서 log의 베이스가 2인 이유가 2개의 자식노드임을 기억했을때 degree를 늘려야 하는 것이다.</p>\n<blockquote>\n<p>💡 실제로는 트리 노드들이 하나의 캐시 라인이나 디스크 블록을 채울 수 있는 가장 큰 차수를 사용하고 있다.</p>\n</blockquote>\n<p>따라서 B 트리는 아주 많은 양의 데이터들이 존재하는 곳에 사용되고, 높이를 <code class=\"language-text\">h</code> 라고 할때,<br>\n<strong>조회,삽입,삭제 등등의 동작 모두 <code class=\"language-text\">O(h)</code> 의 디스크 접근을 요구한다</strong>.<br>\nB 트리는 노드에 가능한 최대의 키들을 삽입하면서 트리의 높이를 낮게 유지한다.</p>\n<blockquote>\n<p>즉, Balanced를 삽입,삭제 과정에서 혼자서 유지한다는 것이다.</p>\n</blockquote>\n<p><strong>그렇기에 AVL,RB 트리와 비교해서 매우 낮은 디스크 접근을 수행한다.</strong></p>\n<blockquote>\n<p>💡 이게 뭔말인가 했더니 노드의 사이즈를 디스크 블록 사이즈와 거의 동일하게 유지한다는 말, 어차피 디스크 액세스할때 1K 읽나 , 1 Byte 읽나 오버헤드는 같으니까, 한번에 많이 읽어오면 되는거다.</p>\n</blockquote>\n<p>이러한 여러가지 특성때문에 B 트리는 B+트리와 더불어서 DBMS에서 많이 사용되고 있다.</p>\n<blockquote>\n<p>💡 인덱스 다룰때 많이 쓴다고 한다. 요즘에 MongoDB 만지는데 대놓고 공식문서에 인덱스는 B트리 쓴다고 되어 있다. 물론 PostgreSQL 이런건 B+트리도 쓰고, MySQL은 B 트리,B+트리, 해시 다 쓴다.</p>\n</blockquote>\n<h2 id=\"b-트리-정의\" style=\"position:relative;\"><a href=\"#b-%ED%8A%B8%EB%A6%AC-%EC%A0%95%EC%9D%98\" aria-label=\"b 트리 정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>B 트리 정의</h2>\n<p>degree가 m인 B트리는 아래와 같은 특성을 가진다.</p>\n<ul>\n<li>루트 노드는 적어도 2개의 자식을 가진다.</li>\n<li>루트 노드와 외부 노드를 제외한 모든 내부 노드는 <strong>적어도 <code class=\"language-text\">올림(m/2)</code>개, 최대 <code class=\"language-text\">m</code> 개의 자식</strong>을 가진다.\n<ul>\n<li>m=2이면, 1~2개의 자식 노드 → 포화 이진 트리</li>\n<li>m=3이면, 2~3개의 자식 노드 → 2-3 트리</li>\n<li>m=4이면, 2~4개의 자식 노드 → 2-3-4 트리</li>\n</ul>\n</li>\n<li><strong>모든 외부 노드들은 같은 레벨</strong>에 있다. (Perfectly Balanced)\n<ul>\n<li>이게 매우 중요… 높이의 상한을 준다는 것이니까 디스크 접근에 대한 상한을 준다는 것.</li>\n<li>그림에서 <code class=\"language-text\">{8,11}, {22,23}, {58,59}</code> 같은 애들을 외부 노드라고 부른다.</li>\n</ul>\n</li>\n<li>각각의 노드는 적어도 <code class=\"language-text\">[m/2]</code> 개, 최대 <code class=\"language-text\">m-1</code> 개의 키를 가질 수 있다.\n<ul>\n<li>\n<p>아래 그림을 보면, m=3일때, <code class=\"language-text\">[3/2]=1</code> ~ <code class=\"language-text\">3-1=2</code> 개의 키를 가진다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABIklEQVQoz3VS2YqEQAz0/79MfBEfhBFFBe/7vo8sFbZdx50paDodY1KVRKJfnOd53eu6Xu9lWd7euL8dQLoHAdu2UZ7n/G7bllRVJcMw6DiOt7hPyTnhM0Cg73s+8HVdx4WeiZ6AT3pWKIqCdF2nMAyvQEjWNI1M02RbYBgGcl2XPM+jNE3/JAuM40hZlpHv+28/Nk3DPsdxmO2dEVohziUZieI4vqShGoYBG370cpom/l5VFUVRRPM8f5a87ztZlkWv14tZIRkk13XNjBRFIdu2WW6SJOyTZZmCIOAkz2FJokdgdG802IAFmOFGvwTA/OtQYIClmCJsNBkF0DvYAGRi6iJGbAL8aAtW7d/aiOqQCym4y7Jkn2B8Xy8UhR9HKPgB6zgJx2crqzsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/bef22c4605b0d8b8b5e8c36ba50d16c7/37523/btree_example.png\"\n        srcset=\"/static/bef22c4605b0d8b8b5e8c36ba50d16c7/e9ff0/btree_example.png 180w,\n/static/bef22c4605b0d8b8b5e8c36ba50d16c7/f21e7/btree_example.png 360w,\n/static/bef22c4605b0d8b8b5e8c36ba50d16c7/37523/btree_example.png 720w,\n/static/bef22c4605b0d8b8b5e8c36ba50d16c7/35751/btree_example.png 873w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>이런 조건이 있는 이유는, 만약 m=5일때 , 1개의 키가 있다고 해보자. 다음 키는 그 키보다 작거나 크거나 즉 두개인데, 그러면 3-4-5 트리를 만족하지 않는다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>B 트리의 목적이 데이터를 넓게 흩뿌리면서 높이를 낮게 가져간다는 점을 생각해보면서, <code class=\"language-text\">n</code>개의 원소가 있다고 할 때, 높이의 상한에 대해서 계산해보자.</p>\n<ul>\n<li>Best Case\n<ul>\n<li>최고의 경우는 가장 잘 흩뿌려질때니</li>\n<li><code class=\"language-text\">logm(n) n=(log n)/(log m)=O(log n)</code></li>\n</ul>\n</li>\n<li>Worst Case\n<ul>\n<li>최악의 경우는 가장 덜 흩뿌려질때, 즉 노드가 최소의 자식을 가지는 <strong><code class=\"language-text\">올림(m/2)</code></strong> 갈래로 흩어질때임.</li>\n<li><code class=\"language-text\">log올림(m/2)(n)=(log n)/(log(올림(m/2))=O(log n)</code></li>\n</ul>\n</li>\n</ul>\n<p>즉 모든 최고,최악의 경우 모두 <code class=\"language-text\">O(log n)</code> 의 높이가 보장됨을 알게 되었다.</p>\n<h2 id=\"조회\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%ED%9A%8C\" aria-label=\"조회 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>조회</h2>\n<p>조회는 이진탐색의 그것과 매우 비슷하다. 이진 탐색에서 조회는 분기가 세가지다. (못 찾는 경우 제외)</p>\n<p>내가 찾는 키를 <code class=\"language-text\">k</code> 라고 하고, 노드의 키를 <code class=\"language-text\">v</code> 라고 하면,</p>\n<ul>\n<li><code class=\"language-text\">k=v</code> : 같거나 → 찾았다.</li>\n<li><code class=\"language-text\">k>v</code> : 작거나 → 왼쪽 서브 트리로 간다.</li>\n<li><code class=\"language-text\">k&lt;v</code> : 크거나 → 오른쪽 서브 트리로 간다.</li>\n</ul>\n<p>이것처럼 B 트리에서도 비슷한 방식대로 움직이는데, 분기가 두가지다.</p>\n<ul>\n<li><code class=\"language-text\">k=v</code> : 같거나 → 찾았다.</li>\n<li><code class=\"language-text\">i-th v&lt; k &lt; i+1-th v</code> 를 만족하는 <code class=\"language-text\">i</code> 를 찾고 <code class=\"language-text\">i-th pointer</code> 가 가르키는 서브트리로 간다.\n<ul>\n<li>이때 만족하는 <code class=\"language-text\">i</code> 는 최대 <code class=\"language-text\">m-1</code> 개이므로, <strong>루프를 돌아도 되고, 이진 탐색을 수행해도 된다. ←</strong> 루프를 돌아도 안전한게, 어차피 같은 메모리안에 올라와\n있다. 추가적인 디스크 액세스가 필요하지 않다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 480px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABHklEQVQoz5WS66rCQAyE+/4vqFSkd3vTXgW1tc3hC2RZ1D8nsGy3SWYmsxuIF/u+y3/iV31gCUtWVaWrbVtJkkTyPJemaXRP01Rut5uUZSnX6/UnaGBglqjrWovv97uCjuOoOc4QAP54PKQoCvkU4wB9JlRQTGOWZaoGUMBPp5Ocz2clJef32R74h67rFHCaJhmGQY7HowJxBgAw1PV9L1EUyfP5/AJ1Cmm6XC5O+rZtqtIPwP085O/3+1shTDYChQTmo4SwJqx4vV6umW98XdfVeamAcRy7Jgtu+vMfXrJ8Yi4LT93IMNiNmY+MGoahsptaLOGCDoeDvgJTxBTzPOuECogvNNgYFAAKK2/P/kFKHTveLcuiOciZhnom+gMxFAUOupB+xgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/e0626a3c76d2f199af7b22febd2e4bec/e85cb/key_in_node.png\"\n        srcset=\"/static/e0626a3c76d2f199af7b22febd2e4bec/e9ff0/key_in_node.png 180w,\n/static/e0626a3c76d2f199af7b22febd2e4bec/f21e7/key_in_node.png 360w,\n/static/e0626a3c76d2f199af7b22febd2e4bec/e85cb/key_in_node.png 480w\"\n        sizes=\"(max-width: 480px) 100vw, 480px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"삽입\" style=\"position:relative;\"><a href=\"#%EC%82%BD%EC%9E%85\" aria-label=\"삽입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삽입</h2>\n<p>삽입부터 B 트리가 복잡해지고, 또 그 과정에서 B 트리가 가지는 균형유지의 전략을 볼 수 있다.</p>\n<p><strong>일단, 조회의 과정을 거치고, 삽입할만한 적절한 리프 노드 위치를 찾는다. 그 다음부터 분기가 나뉜다.</strong></p>\n<blockquote>\n<p>💡 리프 노드에 넣는 이유는 아래에서 설명하겠지만 삽입시에 일어나는 분할이 상향식이기 때문이다.</p>\n</blockquote>\n<ul>\n<li>삽입할 곳에 <strong>자리가 남아있다면 (<code class=\"language-text\">current capacity&lt;m-1</code>) , 그냥 넣고 끝낸다.</strong></li>\n<li>삽입한 뒤에 <strong>넘친다면, 분할한다.</strong></li>\n</ul>\n<h3 id=\"분할\" style=\"position:relative;\"><a href=\"#%EB%B6%84%ED%95%A0\" aria-label=\"분할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분할</h3>\n<p>리프노드에 삽입한 후에 m개의 키를 가진다면, 분할하는 과정을 거친다. m개의 키를 가진 노드에 대해서 세 그룹으로 분할한다. (아래 과정은 m이 홀수일때)</p>\n<ol>\n<li>중위순서의 <strong>키보다 작은</strong> 키들로 이루어진 노드들</li>\n<li>중위순서의 키</li>\n<li>중위순서의 <strong>키보다 큰</strong> 키들로 이루어진 노드들</li>\n</ol>\n<p>그리고 1번과 3번 그룹의 부모를 2번으로 만든다. 즉, 여전히 성질이 깨지지 않게끔 하는 것.</p>\n<p>만약 이때 부모가 넘친다면? 또 다시 진행한다. <strong>그렇기에 리프노드에서의 넘침이 상향식으로 전파될 가능성이 있는것.</strong></p>\n<p>이게 루트까지 넘친다면, 루트에 대해서 두 개의 자식을 가지는 새로운 노드를 만든다.</p>\n<p>예시를 다 보여주기에는 어려우니, 가장 복잡한 예시만 들면 아래와 같다.</p>\n<ul>\n<li>\n<p><strong>예시</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.444444444444446%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAzklEQVQY03VR2QqDMBDM//9Z6auIYvG+D1RExXPKbCtUaBaWZDK72ZlEZVmGNE0RRRFc1wWx53koyxJXDMOAuq7R9z3+xXmeOI9DVgVNkBzHEU3TwPd9mKYJwzAET9OEbdukbt/3W58iwelUlOc52rYVtUwqJ+YahiG6rhNMB47jII5jOaOzl2WhKIrPhSTYxOnLsohtJovJJ0kiNbRMRdzbti3n5IMggPl8iAit5cv2FRzEmOcZ67pqe5Q86E+jDvNZqIZOqqq6cczj+ylv9eTNx7PcEmQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/2c473db869d67750e15df47ab742bb9d/37523/insert_1.png\"\n        srcset=\"/static/2c473db869d67750e15df47ab742bb9d/e9ff0/insert_1.png 180w,\n/static/2c473db869d67750e15df47ab742bb9d/f21e7/insert_1.png 360w,\n/static/2c473db869d67750e15df47ab742bb9d/37523/insert_1.png 720w,\n/static/2c473db869d67750e15df47ab742bb9d/dd104/insert_1.png 1064w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>우선 67이 들어갈 위치를 찾는 과정을 거치고, 넣을만한 곳을 찾았는데 넣는 순간 5개의 키를 가지면서 넘친다. <strong>분할 발생!</strong></p>\n<p>중위순서의 키는 67이니, <code class=\"language-text\">{55,66}, {67}, {68,70}</code> 로 나눈 후 <code class=\"language-text\">{55,66} → {67} ← {68,70}</code> 으로 만든다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1UlEQVQoz4VR2QqEMAz0/z/NZ/FFBW+ronjfOksC0eLCbiBtJ0knmda4rgu6k8lOtu87tm3DcRx3Tq+lvJ4z8DK9sCgK2LYN0zThOA7O83yXoyxLTNP0ELZti6qq2OmslEIYhkjTFHVdM86yDE3TsMdxzI2IhCaj2DzPD6Hv+0iShC/3fY8oihh3XYdlWeC6LpOM44hhGHhiy7K4ERGt68pxmp4JaREgXQRLjLBeIyZSaVJ5x683/GVCSJN5nsdK8jy/VZBK4/3L/1wIgyDgDyHpcibCD81kHwfiV+wsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/fa253ab3b458bb68a35785c1aecc779c/37523/insert_2.png\"\n        srcset=\"/static/fa253ab3b458bb68a35785c1aecc779c/e9ff0/insert_2.png 180w,\n/static/fa253ab3b458bb68a35785c1aecc779c/f21e7/insert_2.png 360w,\n/static/fa253ab3b458bb68a35785c1aecc779c/37523/insert_2.png 720w,\n/static/fa253ab3b458bb68a35785c1aecc779c/302a4/insert_2.png 1080w,\n/static/fa253ab3b458bb68a35785c1aecc779c/f3a19/insert_2.png 1086w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>근데 67이 들어갈 위치는 50의 옆이다. 그런데 그럼 루트에서 넘침이 생기니, 루트에 대해서 상향식으로 분할이 전파된다.</p>\n<p>따라서 <code class=\"language-text\">{5,10} → {22} ← {50,67}</code>의 구조로 만든 후 체크하면 5개의 키를 안 넘치니 끝.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA5UlEQVQoz11R2QqEMAzs/3+a+CAieKBP3oqKeJ+zTFgXt4HQSZNMJq3C1+77Fn/w29I0RRzHKIoC67pCt3ef0i/emM3TNKFpGpRliSzL0HUd9n3/1eoilH7Bk4qiKBKCbdt+Sq7rkjwHWJaFJEnQ9/2fGKVPoaI8z8WJHxKej5GE67NmHMd/wqfoOA5JzvMsqhhzNd2GYZDco5w972GKSRbxbYg5nURs4N15nuKM27bFsiySZ45ExHVdy3szVq7rwvd9hGGIIAgEcx3P82DbtvxuVVUwDEOcseM48obEJDNNU/pY9wEgehwNWbIT+wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/68b7d3a5772d18ff86b5b8e542e4b6ea/37523/insert_3.png\"\n        srcset=\"/static/68b7d3a5772d18ff86b5b8e542e4b6ea/e9ff0/insert_3.png 180w,\n/static/68b7d3a5772d18ff86b5b8e542e4b6ea/f21e7/insert_3.png 360w,\n/static/68b7d3a5772d18ff86b5b8e542e4b6ea/37523/insert_3.png 720w,\n/static/68b7d3a5772d18ff86b5b8e542e4b6ea/47aef/insert_3.png 1063w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ul>\n<h2 id=\"삭제\" style=\"position:relative;\"><a href=\"#%EC%82%AD%EC%A0%9C\" aria-label=\"삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삭제</h2>\n<p>삭제는 삽입보다 복잡하다.<br>\nB트리에서의 삭제는 삭제된 후에 B트리의 성질을 유지하기 위해서 최소키의 개수를 만족하는지,<br>\n만족하지 않으면 추가적인 조치가 필요하기 때문이다.</p>\n<p>B트리에서의 삭제는 크게는 두가지, 작게는 세가지 경우가 있는데 , <strong>먼저 삭제할 키인 <code class=\"language-text\">k</code>가 리프에 있는지 없는지를 따져서 두가지로 나뉜다.</strong></p>\n<blockquote>\n<p>💡 모든 삽입, 삭제 과정에서 <code class=\"language-text\">k</code>가 들어갈 혹은 삭제될 위치를 찾는 조회과정이 선행된다.</p>\n</blockquote>\n<h3 id=\"code-classlanguage-textkcode가-리프에-있을때\" style=\"position:relative;\"><a href=\"#code-classlanguage-textkcode%EA%B0%80-%EB%A6%AC%ED%94%84%EC%97%90-%EC%9E%88%EC%9D%84%EB%95%8C\" aria-label=\"code classlanguage textkcode가 리프에 있을때 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">k</code>가 리프에 있을때</h3>\n<p>근데 여기서 또 나뉜다. 골치 아프다. 아래 과정에서 <code class=\"language-text\">m</code>은 3이다. (2-3트리)</p>\n<ul>\n<li>\n<p><code class=\"language-text\">k</code>가 있는 노드의 키의 개수가 <strong>최소 키의 개수보다 클때</strong> → 그냥 <code class=\"language-text\">k</code>를 삭제해도 아무런 문제가 없다.</p>\n</li>\n<li>\n<p><strong>형제 노드 중 하나의 키의 개수가 최소 키의 개수보다 클때</strong></p>\n<ol>\n<li>\n<p>부모 키의 값으로 <code class=\"language-text\">k</code>를 대체한다.</p>\n</li>\n<li>\n<p>최소 키의 개수보다 큰 형제노드가 왼쪽 형제라면 가장 큰 값을, 오른쪽 형제라면 가장 작은 값을 부모 키로 대체한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 108.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAACgklEQVQ4y51V2ZKbMBDc//+JPOQ7UpWn5Glrk8r6RiyH0AHCXEaw2KZTktcHtlmnoiqVhpnRqEX3wJNud1iXHYpKI45jcM7BGIOU0j4LISDj2NpmJkliV0qpjZn8sixhRt/3eNru9njv9ui6HZqmgdYautZ2bdsW+XoNwRgE5yiyzPpMrK7rU37XdeeCeDBypeCvHHiOgyJNR/NMMTOejHGc+/3eOjdlBc8NwcIQVVGcNhUGbRRBSQm92ZwKHYudEFon+vPGLMdkThAJgU2eDwpS37ezrqoBsuM4IDxEkHCO8M0DDQLQHz8RfvsO3/OQMAYlBPzVCpHvI/I8eMsVskTdoDwXBJAZBoVALCXknwnE8wsk58hTZdFJShFzbg8WlKL8QD8oeA/29WBph7jYfkrG4MqXp5wI2u0sSf1+h3WhkZeNtW3c+K/IGEV4fWIqJd7mM7iLOdZxfBfd5Z4BKcdA17SouUBZFNiUJRqt0ejGSqj6eN5eiPkGIfpL0QAlY5h/+Qp3NkeVnWVjSHMXC7wtl6guCLkrG7MabaUqRRQyxEYqMrasGlQGqWVYSCRCIOECTV1/Ipu+hwgCLOcr/Hp+RUgIfIfAnUyRRBSKMbjTGXxCEKwckOnUavO/ZFPUW1R6N9bE/yabQ28fYpFqEefv1ja+6zzcXHmkqCUoyyFpCEHDAREPdXhPU8bK0xQ8pOA0su03psOhbK4S8nSN3y9TECOPLDvLRimQxQIBIeOyuXeFMi/gexQqSezGY8x8sZX5DUhpZTQq7EtHKiTc2QzUyIMQkNcJeBDYrwuZTA+ycRw4rxMoLh6/Q/PPqD5azgja2IfW06fWMzHTlm3T3BT8Cy7sqZFWZIElAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/6ef3ba3700d55e742542b93cedaaf488/37523/remove_1.png\"\n        srcset=\"/static/6ef3ba3700d55e742542b93cedaaf488/e9ff0/remove_1.png 180w,\n/static/6ef3ba3700d55e742542b93cedaaf488/f21e7/remove_1.png 360w,\n/static/6ef3ba3700d55e742542b93cedaaf488/37523/remove_1.png 720w,\n/static/6ef3ba3700d55e742542b93cedaaf488/302a4/remove_1.png 1080w,\n/static/6ef3ba3700d55e742542b93cedaaf488/78797/remove_1.png 1125w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>양 쪽 형제가 최소 키의 개수</strong>를 가지고 있고 , <strong>부모 노드의 키가 최소 키의 개수보다 많다면,</strong></p>\n<ol>\n<li><code class=\"language-text\">k</code>를 삭제한 후, 부모 키와 형제 노드를 병합한다. → <strong>정확히는 부모 키가 내려오는 것.</strong></li>\n<li>부모노드의 키를 하나 줄이고, 자식 수 역시 줄여서 B트리의 특성을 유지한다.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 108.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAACbklEQVQ4y5WVi7KaMBCGff8X6vQV2k5PZzoqKHcNCQS5JHIRhb+TKIoK7WlmMiGbzJ/N7pdlUTUXpKJFIWvEcQzOOSilCMNQj0mSgBCCofV9fx+H73FbnC8dTm2Htr2grms0TYOqqlCWpZ4XWYaQEORpilNdX8W67kn4SRD/aFmSwLcsuJstMs6f1qZEF4Prqnddp42VlOCUgu4JZJbfNxdpBkYIkihCdTw+XX0QXdyNeJwiiwKB44AEOxyr6klw7/u6l1JOX/kqple0V3vPx862QVxXx8758hXRz186Of5mA+L7IJ4HT4cgeUvQQ1DFi3PEjCEmBDyk4HGM8NsPZJYNURRgux1iSvXBbL+HyPN3wSm3X1tYdIjzdnJt8sqvwdX9hkZ/OSPNS+SiRt9dntcmmHzz8PXEQxTBNQw4poE0jj+JzS0pw8K5bVGXJU5NrbNZVxXqqtbZl0Loudoziw36MTQKjxT2eo2fHyscogfMKmmOacLdbCBHCZnFphQSWZpqcKMwhGFYODWnK5tCXDPMInDGwCnTt5jHpu9B/QCebcMzTQTbLYjvAbfXw0MCZ7WGb9sIthbs1QoJY/+HzWBN8gb58YwZbj6JjX7b17UoP+EgroLK9roPb1eeEVVNZBnYLgDdBRBZPpnZtxhObRpseXIA2xNdZVT25zicjOHYK8cw7mg8sElgm6ZOzF+xGZ/S9b0GWNe8srzXSTWq6p2o30QU4SjENNiv2LhbC+7aQOg4WC0NfHz/jUvbIiIE9nKFQGFjWbCWSySUzXB4myiPpJCQhdAeFEWBLMt1MVDPTXmu7KqrctYM/5iR4B+f165xH+XS0wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/531572d3d77ac63c3ad1147aef43cb39/37523/remove_2.png\"\n        srcset=\"/static/531572d3d77ac63c3ad1147aef43cb39/e9ff0/remove_2.png 180w,\n/static/531572d3d77ac63c3ad1147aef43cb39/f21e7/remove_2.png 360w,\n/static/531572d3d77ac63c3ad1147aef43cb39/37523/remove_2.png 720w,\n/static/531572d3d77ac63c3ad1147aef43cb39/302a4/remove_2.png 1080w,\n/static/531572d3d77ac63c3ad1147aef43cb39/78797/remove_2.png 1125w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>양 쪽 형제가 <strong>최소 키의 개수를 가지고 있고, 부모 노드 역시 최소 키의 개수면</strong> → 부모를 루트로 한 서브 트리의 높이 자체가 줄어들기 때문에 재구조화가 이어진다. 아래\n참조</p>\n<ul>\n<li>어디에서 가져오든, 무조건 빵꾸가 생기잖아요~</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"code-classlanguage-textkcode가-내부노드에-있고-현재-노드-혹은-자식-노드의-키의-개수가-최소-이상일때\" style=\"position:relative;\"><a href=\"#code-classlanguage-textkcode%EA%B0%80-%EB%82%B4%EB%B6%80%EB%85%B8%EB%93%9C%EC%97%90-%EC%9E%88%EA%B3%A0-%ED%98%84%EC%9E%AC-%EB%85%B8%EB%93%9C-%ED%98%B9%EC%9D%80-%EC%9E%90%EC%8B%9D-%EB%85%B8%EB%93%9C%EC%9D%98-%ED%82%A4%EC%9D%98-%EA%B0%9C%EC%88%98%EA%B0%80-%EC%B5%9C%EC%86%8C-%EC%9D%B4%EC%83%81%EC%9D%BC%EB%95%8C\" aria-label=\"code classlanguage textkcode가 내부노드에 있고 현재 노드 혹은 자식 노드의 키의 개수가 최소 이상일때 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">k</code>가 내부노드에 있고, 현재 노드 혹은 자식 노드의 키의 개수가 최소 이상일때</h3>\n<p><code class=\"language-text\">k</code>를 predecessor(왼쪽 서브트리의 가장 큰 값) 혹은 successor(오른쪽 서브트리의 가장 작은 값)와 교환해준다. 찾는 과정은 BST의 그것과 매우 유사.</p>\n<p>그런 후에 리프 노드가 된 <code class=\"language-text\">k</code> 를 삭제한 후 필요에 의해서 리프노드에서의 삭제 핸들링 과정으로 넘어간다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 111.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAACRUlEQVQ4y62V8ZKaMBDGff9n6B99nV47N62dq44nYEhIAgkhCKig+HWSqx562Ho33ZmdhOzkY8P+skwAwKxb5GULrTWEEMiyzI9SSiitIZU6PxNC/Lzve7cVx+MRQ5ucFp33zvv+Zf5n3LctGpli2zTo2haHw8H7SeiN4PXCtdVKY/bpM5Y/ptBpehEbE52cshsG9m0HawxSIVAWFt1u57OryhIqzVDkObabzeuegcbk+m3ONlUFGkUIZnMUSp3XS2NAghBkGaDM8/O+49g3dFZZCx7H4IxBcQFJKaKAgMYca5ODhiGUlEg5B4tWsLnBsAZvBNdFARHHkJwjpRSCEKwCgoRyNNZ4QSeWsgSJF8zHBceqNbRqe8Qq3Y3G/nrk05u8n/DZ75HpNWRWot93F0idMxs78i2u1oXFw8MUwewXlJD/xmYs4BBxaMgkQVkU6LrOu8MmkxJGaw/6u7BhqxXC+RyFMRfYxGEEEjhszH3YJISAUwqVJOCcI/nyFenjd1hrES+X/thpkviK36zyGRtrISnzNyRjDIJziG+P0NOfqOs1kihC5mKcgxPiM/4QNmULRHL7/7CxtvLoHMawedk4gs2NTGtrsZzPEM1mH8dm33X+eyqZ+nGITa6UR2n3nm7TVBVWQYDF0xO0fM3KVTV6fka4WMDqe7pNWZ67TS4lBGOew7ppfEVdS9NZ5ivNouiObmMKyJj6jiLj2MPtbkxd1yiUBgtCSMZ8W+Pv7TYuq0wpKKX8jymm1D9zIZAPbs/1kX8DlACqpMC+0kEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/5a2d02eb2aa7026c72e2c52df0310ed1/37523/remove_3.png\"\n        srcset=\"/static/5a2d02eb2aa7026c72e2c52df0310ed1/e9ff0/remove_3.png 180w,\n/static/5a2d02eb2aa7026c72e2c52df0310ed1/f21e7/remove_3.png 360w,\n/static/5a2d02eb2aa7026c72e2c52df0310ed1/37523/remove_3.png 720w,\n/static/5a2d02eb2aa7026c72e2c52df0310ed1/302a4/remove_3.png 1080w,\n/static/5a2d02eb2aa7026c72e2c52df0310ed1/78797/remove_3.png 1125w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 그림에선, 양쪽 형제 모두 최소 키의 개수만큼 가지고 있고, 부모노드의 키의 개수가 최소개수 이상이니 15,17이 병합된다.</p>\n<h3 id=\"code-classlanguage-textkcode가-내부노드에-있고-현재-노드자식-노드의-키의-개수가-최소개수일때\" style=\"position:relative;\"><a href=\"#code-classlanguage-textkcode%EA%B0%80-%EB%82%B4%EB%B6%80%EB%85%B8%EB%93%9C%EC%97%90-%EC%9E%88%EA%B3%A0-%ED%98%84%EC%9E%AC-%EB%85%B8%EB%93%9C%EC%9E%90%EC%8B%9D-%EB%85%B8%EB%93%9C%EC%9D%98-%ED%82%A4%EC%9D%98-%EA%B0%9C%EC%88%98%EA%B0%80-%EC%B5%9C%EC%86%8C%EA%B0%9C%EC%88%98%EC%9D%BC%EB%95%8C\" aria-label=\"code classlanguage textkcode가 내부노드에 있고 현재 노드자식 노드의 키의 개수가 최소개수일때 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">k</code>가 내부노드에 있고, 현재 노드,자식 노드의 키의 개수가 최소개수일때</h3>\n<p>만약 이 상황에서 <code class=\"language-text\">k</code>를 삭제하면, 전체적인 높이가 낮아지면서 B 트리의 조건을 유지하려 함. 이를 트리의 재구조화라 한다.</p>\n<ol>\n<li><code class=\"language-text\">k</code>를 삭제하고, <code class=\"language-text\">k</code>의 자식을 하나로 합친다.</li>\n<li><code class=\"language-text\">k</code> 의 부모 키를 인접한 형제노드에 붙인다. (이때 <code class=\"language-text\">k</code> 는 당연히 루트가 아니다. 루트면 위에서 걸렸겟지)</li>\n<li>아까 병합한 노드를 2번의 자식노드로 설정한다. (왼쪽 혹은 오른쪽)</li>\n<li>만약 이럴때, 부모노드의 키의 개수에 따라 수행 과정이 다르다. 이에 대해서 또 분기한다.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 173.88888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAYAAACU9ioYAAAACXBIWXMAAAsTAAALEwEAmpwYAAADq0lEQVRIx5VWa2/qOBDt//8zK+0vWO2nK11ppXsLBUJIIUDzckLiPPyInbMaA72hTVs60ijBNidjn5njeRDK4FRr8FYiz3MkSeKecZJgv9+jOJ3AOUfFOYZheHWy8fvVHnpjIZWF0gZCCLRti67r0NQ1mqZBXZY4hiGq4nQDMga9AcQX1lYVdkGAqihuxj8CfRh/cbDWDTYZg//X36jzPyA0t3/eOvAoDG+AJyMcRpM8Y9j/86+L7vwnoNc90ihCdDggOR5h+v5PpJOAF7CmLPHs+4iiCJvFAkpIDKbH5ukJhyBwUT4/LfC8XkML8X7LbwG1UqirCjWxW5YYrAFvJHJ2ch+rifE8d6SNo5wk5e15XG2bSJxaOzn38Rm+za3L77bi8JcLF9VdLE8tsNZCa+0w6QgKxtBwDiml877vvwYcT1CCF0UBqeTt1n0f/nKJve9/b8uc12CsQNO0bswYC15VKLIMeZaBxbEj5Zq3HyY2Wa8U5r+X+PHjF/xV4DLU9hrB4gk7z8Nus4H/+IjAW0N13btgJkvPGOPOiZ5kJB4nLl0K0Ri5tXaS7QdrB/SG/EyE1r17EqBSGhgMdhHHIeHufTx/Xq9fwV2EnTRglUJRtq464vgsWy8vLwjDEGmaIksTbLeBmyffhyHiOL6sj6GU+nzLYxN1g58/Z+AX+frIXrd8ozYXpy2Q07shQnYJqpJDCuFS6rrNKW18eMvSlDVyQFFprOYLrGYzBIvl/XlIXyZxKIvC5RqVC7GaximKjIFlGbI4RpHnsJcs+FxtpHIytVkuEYfh+Qh6jdBbIfQ8hDT3OEO4Cd7l4Zdqc/0Z5QJZqW7Gvq02LrLLGKUV7/pXZb9LbT4jBbbH7/9mWM5X2K7XCNffFIe+16hbiRMXKGoNVgpstwckUewIIaf0+fLWu5JC8jT/NXfiQKVJpOy8Ffbr9UUcZgg8b5qUm6S+pA0lsJICvT4TUTUKxamGEh2kkBBt68rNTskX7rBDJpCW+r47RSqDgivUnUGaZi5xj8ej63FItan4kyRGnjM3zhi7Kbt3ERo7gEBJwqRS7rCpt6G7w8mTUjjsdq5jEF13uWtGQN/tbejuZUmC7CV6vYfv721Gi5LDEZvVCnYEQlt92YUIN5vP8/Dt16joT4w5MVBS/pEyY5xo5GnqFHuqR3wHWDKG9XzuKqLjHM+eh2i/h9Ea/mKBPEnAoti9f9jbjAEpIupfyImQtmkcGXRlusteCEhqSHk9KV//AwN1qfahqog6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/e8f530aef0b73e22d411068cf9753eaf/37523/remove_4.png\"\n        srcset=\"/static/e8f530aef0b73e22d411068cf9753eaf/e9ff0/remove_4.png 180w,\n/static/e8f530aef0b73e22d411068cf9753eaf/f21e7/remove_4.png 360w,\n/static/e8f530aef0b73e22d411068cf9753eaf/37523/remove_4.png 720w,\n/static/e8f530aef0b73e22d411068cf9753eaf/302a4/remove_4.png 1080w,\n/static/e8f530aef0b73e22d411068cf9753eaf/78797/remove_4.png 1125w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>새로 구성된 인접 형제노드(부모 키 붙인)가 <strong>오버플로우 나면, 삽입연산에서의 분할 수행</strong></li>\n<li>인접 형제노드가 구성되더라도, <code class=\"language-text\">k</code>의 부모 노드가 최소 키의 개수보다 작아진다면, 다시 위의 2번 과정부터 수행한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 173.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAYAAACU9ioYAAAACXBIWXMAAAsTAAALEwEAmpwYAAAECklEQVRIx51W6XLzNgz0+z9QZ/q30ydomokPOZZsWfdJibLu7SxsqdJnJ+kUM4xFEgEBYhfg5tb0SFSDXHfIc4UoimS4risjjmOkaYowDOU7CAIkSTLreZ4na+M4grLp+xF106NpBzRNi9vthqqqoLWWwXlEY1GEuq5lb9LhL3X4PRvED9K3Hc6GAe9ywTiM3+rS6IZ/5iEGWkRBAJVl6LoOXdvK3jAMaNtW1tIoQhKGGLoe4zDM3onB6WOSm9awjkekYbg6eSmebeNsHNF23ZPOZvqgoatposhzmTd1LXN6Q6GHcRDI2tD3spacTFi//S5er0Km1FUF73rFrarud9f38B0HWZLMXiRRJGuTFK4H+48/5bBVyFVRwDQM2J8nfG63qIoS9umEy/ETp/0Bkech8n0Y7++wDAPO+QwVxzB2O3waBszjEV1d/5vltmmQJynyJEEWxzJn6DJPEuiigC5KJEEo+9xjRJIc30eepugfYW9+vfBXYgUNMj38qLfK8ushmwh8siWX7/Gb8eThr97ysplt67AXYItBjE9eLWWzBCWlaxo4ti13RYP9AyJLnbIsoZSa95ZGn4FdlnDOF+RxvDK0DIv8LcryyeAKhzRkHQ4olbp72nUCEYJ5Cp9CBl2tM+yTKXBbHrgKuSpLBI4r8BCmNA1Cz5PQp38axhFpHAu4uTcd/sRlnnQ+HuGaFszdXuaOZcEhtYwjYs9DEgQ4vL2JHrlcKYXjbofD3+9QDzbNBllRCFYOqTJti7IoUGT3uS41Kq0FwJxzr7ndZE7gNw+WrO7wOzk6FWLV/QjqVZanwctnFgmNgpSTjGpoVvHFWvnI8jIhc8jLE6jEks8+4fu+9BLnaiPwPfl2vfsv91hwv8Xhy/DHARdWIvPybahfMoVVIw5DRFGCvKhR6BoXL0ecVYjzBn1PPN6v5pUjL5nCFuBcXOgG0M2AvLwnhJ0xUi264bWHTxX7alkzWPuuhXc5o0iTFVOyOMHHzoJrX6VtfEm9qtRSicmYCZvu5SLdbSmkHtepq1XxGjYMk975ti1lv9Za2MCSZZvWvVJHMU7bregFrjtfjbk/CAFWsCHSWQRIL/YPzslhzkPPh1YKpcoROI70FoZNg4Hrwb9e56j+M1NO3g1J2f8PpjygsBxNfUMYK2R5IXD5Su/Ll8Oqvo2jNHbLOOD08SHd8CvPnuohKVcoJS8qFlfWwyxNkWfZ/KZh5ll5VJ4Ln0mCJw9n2KgCp+1OytMEm/PhgNB1Vx6FjoPTfo/P7Q7lQ/fpDnkSnxmsxsw23y70jo2cLzECmIMZjh9vRT5ZAt+X/1vVQ2k6Skn/YBEg1jjn3dFDehM6rsDp8NcbzP3+8RRJYHxssX97E4xOBv8BohebSJZfp+MAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/ac498d0eac07d0ebb947975160b7b7ee/37523/remove_5.png\"\n        srcset=\"/static/ac498d0eac07d0ebb947975160b7b7ee/e9ff0/remove_5.png 180w,\n/static/ac498d0eac07d0ebb947975160b7b7ee/f21e7/remove_5.png 360w,\n/static/ac498d0eac07d0ebb947975160b7b7ee/37523/remove_5.png 720w,\n/static/ac498d0eac07d0ebb947975160b7b7ee/302a4/remove_5.png 1080w,\n/static/ac498d0eac07d0ebb947975160b7b7ee/78797/remove_5.png 1125w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>다른 예시</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.222222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWElEQVQoz12Q707bMBTF+/7PsG983ATatAkQdJvgBRgVf5JCCAlpSWsnTWLHrpP0N9WgruxK19fWuefcezwC2Gw2u9wPXT4in88R8ZjXaExvxQ7b5+xzR/+LbN/D2vhsRYwSD9SLgFpErKs5vW0ZnIGPtB13tL0412FUjVMrOr2iN4rBWd/QdT22kvR9/zbMWY+7psBWS5xp6DrLMPRvG26PyWTC8fevVGXxPmnwtZEB6e0Rs/tvZOExncl327h2TnpzRDL5QnR9SFvF/wSbskSKgs7aDxacXmHrV9ZKstaSzdbqewxW4XThcasL78wLtmWCKZ78h6vFFGdXOFvS5PdoGaJEjKlTdJGiRITVS48r8YSWU3T5gi4eaJYRppkzEvEv8ugMkfwmC09R8o46vyILT5jdHpAEY/LgM1l4Rhb8YBFfopbXvEx/kvz5xOzxwtc0OEc8X/AXSa0T3J9JcVsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/46369e4f2b2d4a0032cfbfec062f6bdb/37523/remove_6.png\"\n        srcset=\"/static/46369e4f2b2d4a0032cfbfec062f6bdb/e9ff0/remove_6.png 180w,\n/static/46369e4f2b2d4a0032cfbfec062f6bdb/f21e7/remove_6.png 360w,\n/static/46369e4f2b2d4a0032cfbfec062f6bdb/37523/remove_6.png 720w,\n/static/46369e4f2b2d4a0032cfbfec062f6bdb/159fb/remove_6.png 1019w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>4를 삭제하자. 이러면 현재 노드, 자식 노드 모두 키가 최소다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.222222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABOUlEQVQoz22Q207CQBCGef838BrjjUaJJCAxhksvvFAC4SBGqD0JpbSU7W63tP0MrcFDOpnJzM7888/MNqiRoshLLzYj3Ld7nPkd5rRHptx/uOKPHaVRT1gVU7VFRTbCe0VsDXRokyWSXKsT5n9foy5ZVMFRyQvQ+7D05TtNyJTgIAKSyCdVguyQkudZtWHd2sV3ce8NMCdt3Nkt9qzLIbZOg/NDjDNtYY2uWAyvCd2n+pN/n6KjNTJ0UDsXFX2Sa/GDy1LUzkEGFiKw0dGqItTSJxE+SmzQclv9XRIivAUytJCBg4491H5DHFhoFZKlEfHWItmvkIGLjn1i/wO5c2h4yx7OsI31fMN6+VASess+1rSDOThjMergjpsYkx7muIU97yPXjyzHPcxhE2PcxRxeYIwueX855wvQJxZeVrnLvQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/988b1adfb0311e33e2a968ad2cf42516/37523/remove_7.png\"\n        srcset=\"/static/988b1adfb0311e33e2a968ad2cf42516/e9ff0/remove_7.png 180w,\n/static/988b1adfb0311e33e2a968ad2cf42516/f21e7/remove_7.png 360w,\n/static/988b1adfb0311e33e2a968ad2cf42516/37523/remove_7.png 720w,\n/static/988b1adfb0311e33e2a968ad2cf42516/4cdf7/remove_7.png 995w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>2와 6을 합치고,</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZklEQVQoz22Q+07iQBSHef8X8AU2WbN/bbKSGMMSNnGjGGVZVGyVim0HuguUTgFLbzOf6QVF45mczPxy5ly+0+AT01pTnMKilcNMDNgs76vYLr7nu5zCGh8LFRnlxzwt3+v/f/CsX/iPLXSWolX+vrFWte8XrMV+JzINqSKPt6+xPFqRbWTpKok/JXsrWHerMG2evSHSu0Z6AzaBzbMc18garTRJ6OLbV4TTv4SLR7ZrUU24G1fX+yFTBFabmXWCMJqIux9MRx3m41aZoFRW3rE0cc0WYvgda3CEnHY/7DDOIAggXEOSk29jUKDiCk1to3d4O63TpNL1ahrhzCB8OEVaZ+g0JokmLMQAKU7xRQ//qUM4N1g4FwQF/nJEJMf4bg/f6bAUfZbivNJul4Y3ajMxC6xjtE7ZzPvYZod/xlfsYRPn+guT+xOc4RHCPGbh/EZ6lzjGT+zeAa7ZRtwe4pgt7JtvvADQ9mDzqHy+gQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/ad4fd288ce57d57d0ba91bdee863250e/37523/remove_8.png\"\n        srcset=\"/static/ad4fd288ce57d57d0ba91bdee863250e/e9ff0/remove_8.png 180w,\n/static/ad4fd288ce57d57d0ba91bdee863250e/f21e7/remove_8.png 360w,\n/static/ad4fd288ce57d57d0ba91bdee863250e/37523/remove_8.png 720w,\n/static/ad4fd288ce57d57d0ba91bdee863250e/350de/remove_8.png 998w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>내 부모 노드와 합친것을 자식-부모관계로 연결시켜준다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABYklEQVQoz2WR6U7CQBSF+/6PwBvoPxM10WjqggkSF5C4sWhbC50pXUBLq9CZz7RVQbiTyb25M/fMOWcM1kJr/Ze1VmWdjFt4r00mo0Z1Viy93KtzxiZIBVQMlb3FnPdhE/nWIrLrqM8UrfIVAuofsLH+wmrk6Yw8m/FDtOplCfOPiDxNQKkNdcaqtI/ggdhrEbhXyP45gdMgFq1/TH4jCbuI52MC6xzp3pNNX5YMta4kxM4poW0iegd4A5PAOkH29tH5fAmqFmX9Lm/xinvdXeznM2b+9dLDSkqKWuhSnvqqhtTnV5kXyRTWHMmzjIJwkSt70gpwKttE3gOhdcFEXBO5l0TDDoF9xNhplz8bvN0w7ptEss8semLitRG9E+LhBdLqELsmvnXFRLQxQusQ324QOSZ+bwd/sF96OOrUkM4NfncbMThG9vcQVpPpqF7a4j7uMO5uMbTuEPc1RoM6oWPyDbY4X8nrKEe1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/9d3f626a1a83a9548a7b1710204f27e8/37523/remove_9.png\"\n        srcset=\"/static/9d3f626a1a83a9548a7b1710204f27e8/e9ff0/remove_9.png 180w,\n/static/9d3f626a1a83a9548a7b1710204f27e8/f21e7/remove_9.png 360w,\n/static/9d3f626a1a83a9548a7b1710204f27e8/37523/remove_9.png 720w,\n/static/9d3f626a1a83a9548a7b1710204f27e8/d9217/remove_9.png 904w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이때 7,9,11이 오버플로우가 나니 중앙값인 9를 분할해 처리한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABdUlEQVQoz2WS627TQBCF/f5PAT9AQrwAKoS0pIi4SUhFlKohdYjt+H5NnYvjy37I3uIEGGm1s7MzZ8+ZHYUXE0J0uxB169dFTKDfyvWrR7Duy5wuT/xV15jyP9gfH4rthsiaEppjIlMlMlTq4466PHFJpCHQAf77QssszymyiPqUy0AlEKW8r04Hyl1KuX9GlAWX1mAolxL38QP+WiXWBy/CIN/ZuNo1oX5LVR664n38iPPzGm/5EWs1JAvnZ4ZCVO0hc+7wjTGJ9Q1Rl23skGi4KwlY5s+dkl0ww9eHuE+fMBd9ts7k3EMpJafOZW/qY94xqQ5HKaeoEFV9bstRxiklGZHLGiV1v5PYE/zlFak7JVx/xtMGpPbXVv5m9pbQGuFrfXx9xNa7JwtmONoQd/EeeznAW7zDWU2I9BuUxFaJreYHb0isO4LVBwJzSGL0CMwRm/kbQqMZnS+EmzGprZL59/jmFHv+Ck9XcR9e4xg/iPQevwHN+l6scZmVlwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/dce1ec9c31503fa9c509e7b0f9bf3ef5/37523/remove_10.png\"\n        srcset=\"/static/dce1ec9c31503fa9c509e7b0f9bf3ef5/e9ff0/remove_10.png 180w,\n/static/dce1ec9c31503fa9c509e7b0f9bf3ef5/f21e7/remove_10.png 360w,\n/static/dce1ec9c31503fa9c509e7b0f9bf3ef5/37523/remove_10.png 720w,\n/static/dce1ec9c31503fa9c509e7b0f9bf3ef5/b3ad9/remove_10.png 909w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>당연하게도 9,15에 대해서 <strong>분할의 propagation</strong>이 일어날 수 있다.</p>\n</li>\n</ul>\n<h2 id=\"차수에-대한-고민\" style=\"position:relative;\"><a href=\"#%EC%B0%A8%EC%88%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%AF%BC\" aria-label=\"차수에 대한 고민 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>차수에 대한 고민</h2>\n<p>결국에 높이를 최대한 낮춘다는 것이 B 트리의 성능 개선점이라고 보았을때,<br>\n차수(degree 혹은 order)를 잘 고르는 것이 중요하다.</p>\n<p>좋은 차수를 고르는 방법은, <strong>페이지 사이즈에 꽉 맞춰 들어가는 최대한 큰 사이즈의 노드</strong>를 고르는 것이다.</p>\n<p>만약에 디스크에서 읽어오는 데이터베이스를 B 트리를 통해서 구성하려 한다면,<br>\n각각의 노드가 <strong>디스크 페이지 크기에 딱 맞는 사이즈</strong>를 골라야 할 것이다.</p>\n<p>만약에 In-memory 데이터베이스를 구성하려 한다고 해보자.<br>\n그 말은 데이터는 메모리&#x3C;->메모리 간 이동이 많을 것이고 중간에 L2 혹은 L3 캐시에 적재될때가 가장 빠른 접근을 할 수 있을때이다.</p>\n<p>따라서  최대한 캐시 효율을 누릴 수 있게 <strong>L2나 L3 캐시의 라인 사이즈에 맞게끔</strong>, 즉 <strong>초과해서 캐시 바깥의 노드를 읽을 필요가 없게끔 구성해야한다.</strong></p>\n<p>모든 케이스에서 어떤 차수를 사용하는지 고르기 전에 먼저 하드웨어에 대한 스펙을 봐야할것이고,<br>\n내가 구현하려는 기능에서 B 트리가 어떤 역할을 하는지 알아야 할 것이다.</p>\n<blockquote>\n<p>💡 Typically, you’d choose the order so that the resulting node is as large as possible\nwhile still fitting into the block device page size.\nIf you’re trying to build a B-tree for an on-disk database, you’d probably pick the order\nsuch that each node fits into a single disk page,\nthereby minimizing the number of disk reads and writes necessary to perform each operation.\nIf you wanted to build an in-memory B-tree, you’d likely pick either the L2 or L3 cache line sizes as your target\nand try to fit as many keys as possible into a node without exceeding that size.\nIn either case, you’d have to look up the specs to determine what size to use.</p>\n</blockquote>\n<h2 id=\"강점\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%A0%90\" aria-label=\"강점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>강점</h2>\n<p>B 트리가 어떻게 균형을 유지하는지는 알았는데 실용적으로 어떤 강점이 있을까?<br>\nHashTable의 grow 된다는 점을 생각하지 않았을때, <code class=\"language-text\">O(1)</code> 이어서 더 유리한거 아닌가?</p>\n<p>분명한 건 해시테이블을 이용할때는 하나의 조회에 있어서 <code class=\"language-text\">O(1)</code>이 소요되는것은 맞다.<br>\n하지만, 이 조회는 어디까지나 <code class=\"language-text\">Hash Table.eqaul(key)</code> 의 결과물이지 DB에서 쓰이는 <code class=\"language-text\">range</code> 와 같은 연산을 수행하지 못한다.</p>\n<blockquote>\n<p>💡 실제로 회사에서 설계를 하면서 Redis를 사용하자는 의견이 나왔을때, 이 근거로 반대했다. <code class=\"language-text\">range</code> 연산이 필요한 곳에서는 HashTable에 기반한 redis는 전혀 이점을 누릴 수 없다.</p>\n</blockquote>\n<p>즉, <code class=\"language-text\">range</code> 와 같은 연산을 수행할때는 계속된 참조가 필요한 것이다.  또, 해시테이블에서 특별한 구현체를 제외하고는 일반적으로 데이터가 정렬되어 있지 않다.\n그렇기에 <strong><code class=\"language-text\">range</code> 와 같은 연산이 매우 비효율적인것이다.</strong></p>\n<p>그럼 해시테이블과 비교했을때 강점에 대해서는 알았는데, 다른 트리랑 비교하면 어떨까?<br>\n다른 트리에서도 <code class=\"language-text\">O(log n)</code> 을 지원하는데 그건 왜 사용되지 않을까?</p>\n<p>앞서 말한 높이의 상한에 있어서의 엄격함과 더불어서 B 트리의 노드들의 데이터는 배열속에서 순차적으로 저장되어 있고,<br>\n<strong>연속적으로 메모리에 저장되어 있음을 뜻한다.</strong> 즉, <strong>공간지역성이 높다는 것이다.</strong></p>\n<p>다시 말해서, B 트리노드 끼리 참조로 이동할때는 디스크 액세스가 필연적이지만, <strong>노드 내부의 데이터들은 배열과 같은 구조로 저장되어 있기 때문에 Sequential access에\n유리하다. 이는 공간지역성에 의해서 캐시효율이 높음을 의미한다.</strong></p>\n<p>그렇기에 같은 <code class=\"language-text\">O(log n)</code> 의 시간복잡도를 가져도, 다른 트리보다 빠른 접근이 가능한 것이다.<br>\n다른 트리는 노드끼리 이동할때 자연스럽게 추가적인 메모리 접근이 필요하지만, B 트리에서 노드 안의 데이터 접근은 공간지역성을 충분히 누릴 수 있다는 것.</p>\n<p>정리하자면,</p>\n<ol>\n<li>항상 정렬된 상태이기에 <strong>부등호 연산에 유리</strong>하다.</li>\n<li>참조 포인터가 적어 <strong>빠르게 메모리 접근</strong>이 가능하다.</li>\n<li>데이터 탐색뿐 아니라 삽입, 삭제에도 <code class=\"language-text\">O(h) = O(log n)</code>의 시간 복잡도를 가진다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">order</span> <span class=\"token expression\"><span class=\"token number\">3</span></span></span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">B_node</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">int</span> order<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of children */</span> \n\t\tB_node <span class=\"token operator\">*</span>child<span class=\"token punctuation\">[</span>order<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* children pointers */</span> \n\t\t<span class=\"token keyword\">int</span> key<span class=\"token punctuation\">[</span>order<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* keys */</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>💡 그런데 이제 h에 밸런싱을 곁들인…</p>\n</blockquote>\n<blockquote>\n<p>요즘 MongoDB에 대해서 빡세게 사용중인데, 정말 자료구조가 중요함을 새삼 느낀다.\n백엔드 개발자가 DB 모르는건 말이 안되니까.</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#why-b-%ED%8A%B8%EB%A6%AC\">Why B 트리?</a></p>\n</li>\n<li>\n<p><a href=\"#b-%ED%8A%B8%EB%A6%AC-%EC%A0%95%EC%9D%98\">B 트리 정의</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A1%B0%ED%9A%8C\">조회</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%82%BD%EC%9E%85\">삽입</a></p>\n<ul>\n<li><a href=\"#%EB%B6%84%ED%95%A0\">분할</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%82%AD%EC%A0%9C\">삭제</a></p>\n<ul>\n<li><a href=\"#k%EA%B0%80-%EB%A6%AC%ED%94%84%EC%97%90-%EC%9E%88%EC%9D%84%EB%95%8C\"><code class=\"language-text\">k</code>가 리프에 있을때</a></li>\n<li><a href=\"#k%EA%B0%80-%EB%82%B4%EB%B6%80%EB%85%B8%EB%93%9C%EC%97%90-%EC%9E%88%EA%B3%A0-%ED%98%84%EC%9E%AC-%EB%85%B8%EB%93%9C-%ED%98%B9%EC%9D%80-%EC%9E%90%EC%8B%9D-%EB%85%B8%EB%93%9C%EC%9D%98-%ED%82%A4%EC%9D%98-%EA%B0%9C%EC%88%98%EA%B0%80-%EC%B5%9C%EC%86%8C-%EC%9D%B4%EC%83%81%EC%9D%BC%EB%95%8C\"><code class=\"language-text\">k</code>가 내부노드에 있고, 현재 노드 혹은 자식 노드의 키의 개수가 최소 이상일때</a></li>\n<li><a href=\"#k%EA%B0%80-%EB%82%B4%EB%B6%80%EB%85%B8%EB%93%9C%EC%97%90-%EC%9E%88%EA%B3%A0-%ED%98%84%EC%9E%AC-%EB%85%B8%EB%93%9C%EC%9E%90%EC%8B%9D-%EB%85%B8%EB%93%9C%EC%9D%98-%ED%82%A4%EC%9D%98-%EA%B0%9C%EC%88%98%EA%B0%80-%EC%B5%9C%EC%86%8C%EA%B0%9C%EC%88%98%EC%9D%BC%EB%95%8C\"><code class=\"language-text\">k</code>가 내부노드에 있고, 현재 노드,자식 노드의 키의 개수가 최소개수일때</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%A8%EC%88%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%AF%BC\">차수에 대한 고민</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%95%EC%A0%90\">강점</a></p>\n</li>\n</ul>\n</div>","excerpt":"Why B 트리? B 트리는 이진트리와 다르게 하나의 노드에 많은 정보를 가질 수 있는 트리를 의미한다. 노드의 최대 자식의 개수를 이라고 할때, 차 B트리라고 한다. B 트리는 고전적인 메모리 계층 구조의 물음에서 출발한다. 이진탐색트리의 시간복잡도가 최악이 될 때는 노드가 편향된 경우인데, 이를 해결하는 것이 AVL,RB 트리와 같은 균형이진트리다. 그런데 이것만으로 부족하다. 왜 그러냐면,  을 보장하는 균형이진트리의 최악을 생각해보자. 최악이 있을까? 분명히 있다. RB트리에서 원소가 1백만개라고 해보면, 트리의 높이는 최대 이다. 따라서 대략 20정도이다. RB 트리에서 Red 노드는 최대 두개만 연속으로 되어있음을 생각하면 쉽게 알 수 있다. 그러면, 원하는 원소를 찾기 위해서 20번 정도의 노드 액세스가 필요한데, 만약 모든 노드가 메인 메모리에 있다고 생각해보면, 매우 비싼 20번의 메모리 접근이 일어나는 것이다. 심지어 메인 메모리가 아닌 디스크에 있다면? 더 많은…","frontmatter":{"date":"April 01, 2022","title":"B 트리","categories":"자료구조","author":"weasel","emoji":"📓"},"fields":{"slug":"/btree/"}},"next":{"id":"2b1ab9c1-7d44-5a52-b72a-91915d8fa2ea","html":"<h2 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가며</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 423px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAG2BJkB/8QAFhABAQEAAAAAAAAAAAAAAAAAAAEx/9oACAEBAAEFAlXf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQABPyFX/9oADAMBAAIAAwAAABB8P//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQADAQEAAAAAAAAAAAAAAAEAESFxkf/aAAgBAQABPxBbetRtOnkO7n//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"마션\"\n        title=\"마션\"\n        src=\"/static/b7c4d40935bbbcbb299372593889fec7/b7bea/martian.jpg\"\n        srcset=\"/static/b7c4d40935bbbcbb299372593889fec7/4ec73/martian.jpg 180w,\n/static/b7c4d40935bbbcbb299372593889fec7/158ba/martian.jpg 360w,\n/static/b7c4d40935bbbcbb299372593889fec7/b7bea/martian.jpg 423w\"\n        sizes=\"(max-width: 423px) 100vw, 423px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>마션이라는 책에서 가장 유명한 파트이다. 그리고 나는 저 도입부에 <strong>100%</strong> 공감하고 있다.</p>\n<p>현장실습을 3월 2일자로 시작하면서, 이젠 돌이킬 수 없는 4학년이고 취업 전선에 뛰어든 신세다.<br>\n그렇기에 현장실습과 코딩테스트, CS 스터디를 두개씩 동시에 하고 있으며 개인 Spring 프로젝트를 준비하고 있다.</p>\n<p>그중에서도 빼놓을 수 업는 중요한 것은 Spring에 대한 공부라고 생각한다.<br>\n물론 Spring에 대한 지식이 전혀 없는 것은 아니다. 공부를 하면 했지, 절대 하지 않은 것은 아니다.<br>\n하지만 그럼에도 <strong>나는 왜 다시 스프링을 공부해야 하는가?</strong></p>\n<p>항상 참인 명제인 <em><strong>나는 생각보다 멍청하고, 배운것을 모조리 까먹는다는 것이다.</strong></em></p>\n<p>그렇기에 Spring의 1타 강사 아니 사실 인프런 1타 강사인것 같은 김영한 님의 강의를 듣기로 했다.</p>\n<blockquote>\n<p>물론 강의가 중요한 것은 아니지만, 내가 쌩돈 내면서 결제하면 그나마 열심히 할 것 같아서..</p>\n</blockquote>\n<p>그래서 공부한 것들을 내 <strong>기억이 아닌 기록</strong>에 의존하려 한다.</p>\n<h1 id=\"객체-지향-설계와-스프링\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\" aria-label=\"객체 지향 설계와 스프링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 설계와 스프링</h1>\n<h2 id=\"스프링의-진짜-핵심\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%A7%84%EC%A7%9C-%ED%95%B5%EC%8B%AC\" aria-label=\"스프링의 진짜 핵심 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링의 진짜 핵심</h2>\n<ul>\n<li>스프링은 자바 언어 기반의 프레임워크</li>\n<li>자바 언어의 가장 큰 특징 : 객체 지향 언어\n<ul>\n<li>즉, 스프링은 객체 지향 언어가 가진 강력한 특징을 살려냄으로써 <strong>좋은 객체 지향</strong> 어플리케이션을 개발할 수 있게 도와주는 프레임워크다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"좋은-객체-지향-프로그래밍은\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%80\" aria-label=\"좋은 객체 지향 프로그래밍은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋은 객체 지향 프로그래밍은…</h2>\n<p>프로그램을 단순히 명령어의 목록으로 보는것에서 벗어나, <strong>객체들의 모임</strong>으로 파악하는 것.<br>\n객체끼리는 메시지를 주고받으며 데이터를 처리한다.</p>\n<p>또 유연하고 변경이 용이하다는 특징이 있다… 이 난해한 말은 간단히 말해서 <strong>레고를 조립</strong>하듯이 프로그램을 개발하는 것이다.</p>\n<h2 id=\"다형성\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"다형성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성</h2>\n<p>실제 우리가 살고 있는 세계와 객체 지향은 완전히 대응시키기는 어렵지만,<br>\n실생활에서의 예제를 <strong>역할</strong>과 <strong>구현</strong>으로 나눠서 보면 좋다.</p>\n<p>운전자와 자동차들이 있다고 해보자.<br>\n운전자는 운전만 하고, 자동차는 굴러가기만 하면 되는것이다.</p>\n<p>즉, 타고 있는 <strong>자동차가 바뀌어도 운전자는 아무 신경쓰지 않고 그대로 운전을 할 수 있어야 한다.</strong></p>\n<p>다시 말해서 자동차의 <strong>구현</strong>과 운전자를 분리한 이유는 운전자가 자동차의 내부적인 동작 방식에 대해서 모르더라도 운전자에게 영향을 주지 않기 위함이다.</p>\n<p>이렇게 자동차가 K3,아반떼,벤츠,BMW … 등으로 운전자에게 영향을 주지 않고 자동차의 종류를 무한히 확장가능한 이것을 <strong>다형성</strong>이라고 한다.</p>\n<p>이를 통해서 새로운 자동차가 등장하더라도, <strong>운전자는 새로운 자동차의 내부적인 방식에 대해서 신경 쓸 필요가 전혀 없다.</strong> 그저 굴러가는 자동차일뿐이다.</p>\n<h3 id=\"달성하고자-하는-것\" style=\"position:relative;\"><a href=\"#%EB%8B%AC%EC%84%B1%ED%95%98%EA%B3%A0%EC%9E%90-%ED%95%98%EB%8A%94-%EA%B2%83\" aria-label=\"달성하고자 하는 것 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>달성하고자 하는 것</h3>\n<p><strong>역할</strong>과 <strong>구현</strong>으로 세상을 바라보면 세상이 <strong>단순</strong>해지고, <strong>유연</strong>해지고 <strong>변경</strong>이 편리하다.</p>\n<p>아까 운전자의 예시를 그대로 들면,</p>\n<ol>\n<li>운전자는 자동차라는 인터페이스의 역할만 알면 된다.</li>\n<li>운전자는 자동차의 내부 구조를 몰라도 된다.</li>\n<li>운전자는 자동차가 전기로 가든, 기름으로 가든, 뒤에서 밀어서 가든 내부구조가 변경되어도 영향을 받지 않게 된다.</li>\n<li>운전자는 자동차의 종류가 변하는 상황에서도 영향을 받지 않는다.</li>\n</ol>\n<p>자바에서는 <strong>역할</strong>은 인터페이스로, <strong>구현</strong>은 인터페이스를 구현한 클래스이다.</p>\n<h3 id=\"자바에서의-다형성\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"자바에서의 다형성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바에서의 다형성</h3>\n<p>대표적인 예시가 상위 클래스 혹은 인터페이스의 메소드를 재정의하는 <strong>오버라이딩</strong>이다.</p>\n<p>클라이언트는 서버의 인터페이스의 함수를 호출하면서, 서버 내의 메소드가 어떻게 구성되어있는지는 관심이 없으며, 서버는 <strong>런타임</strong>에 필요에 의해 <strong>구현을 유연하게 변경</strong>하여 적용할 수 있다.</p>\n<p>이를 통해 <strong>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경</strong>할 수 있다.</p>\n<h2 id=\"스프링과-객체-지향\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5\" aria-label=\"스프링과 객체 지향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링과 객체 지향</h2>\n<p>결국 가장 중요한 것은 <strong>다양성</strong>이다.</p>\n<p>스프링은 이 다형성을 극대화하게 이용할 수 있게 도와주는 것이다.<br>\n<strong>DI,IOC</strong>와 같은 개념들 역시 다형성을 서포트하는 기능들이다.</p>\n<h2 id=\"solid\" style=\"position:relative;\"><a href=\"#solid\" aria-label=\"solid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SOLID</h2>\n<p>로버트 마틴이 주장한 객체지향 설계 5가지 원칙을 앞 글자만 따서 SOLID라고 한다.</p>\n<h3 id=\"srp--단일-책임-원칙\" style=\"position:relative;\"><a href=\"#srp--%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\" aria-label=\"srp  단일 책임 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SRP : 단일 책임 원칙</h3>\n<p>한 클래스는 <strong>하나의 책임</strong>만을 가져야 하는데, 이 <strong>책임</strong>이라는 것은 모호하다. 문맥에 따라서 클 수도 있고, 작을 수도 있다.</p>\n<p>가장 중요한 기준은 <strong>변경</strong>이다. <strong>어떠한 변경점이 있을때 클래스에 미치는 파급효과가 적으면</strong> SRP를 잘 따른 것이다.</p>\n<blockquote>\n<p>하나의 클래스에 DB접근,View 로직,비즈니스 로직이 다 들어가 있다고 생각해보자.<br>\nDB에 변경점이 생기면, 클래스 전체가 바뀌어야 한다. SRP를 잘 지키지 못한 예시다.</p>\n</blockquote>\n<h3 id=\"ocp--개방-폐쇄-원칙\" style=\"position:relative;\"><a href=\"#ocp--%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\" aria-label=\"ocp  개방 폐쇄 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OCP : 개방 폐쇄 원칙</h3>\n<p><strong>가장 중요한 원칙이다.</strong><br>\n요소들이 <strong>확장에는 열려 있고 변경에는 닫혀</strong> 있어야 한다. 근데 확장을 하는데 어떻게 변경 없이 한다는 것일까?</p>\n<p>처음으로 돌아가서 다형성을 생각해보자.<br>\n운전자와 자동차의 관계에서 자동차의 모델이 바뀔때\n<strong>역할이 확장</strong>된다고 해도 기존의 자동차 모델 구현은 <strong>변경이 필요하지 않는 것이다.</strong></p>\n<p>인터페이스를 구현한 새로운 클래스를 만듦으로써 확장한다고 해보자.<br>\n<strong>그러면 인터페이스는 변경되지 않으며, 확장은 일어난다.</strong></p>\n<p>근데 이것이 정말 변경이 없을까? 요리를 예시로 들어보자.<br>\n예를 들어 고든 램지는 나에게 요리를 시키고, 나는 요리를 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">내 kitchen 인터페이스와 클래스가 이렇다고 해보자.\n\ninterface kitchen:    \n    func cook()\n\nclass fryKitchen :\n    @오버라이드\n    func cook():\n        fry()\n\nclass boilKitchen :\n    @오버라이드\n    func cook():\n        boil()\n\n램지 do : \nkitchen k= new fryKitchen()\n\nk.cook() -> kitchen 인터페이스 안에 있는 cook을 호출\n\n나는 kitchen 인터페이스 안에서 기존에는 구워서(fry()) 해서 만드는데,\n만약 삶아서 요리를 하는것으로 변경한다면?\n\n아마 코드는 이렇게 변할 것이다.\n\n램지의 do :\n# kitchen k = new fryKitchen()\nkitchen k = new boilKitchen()\n\nk.cook() -> kitchen 인터페이스 안에 있는 cook을 호출\n\n고든 램지의 행동은 여전히 같다. 하지만 k에 대해서 코드가 변경이 일어난다. 이상하다...</code></pre></div>\n<p>위 코드에서의 문제점은 <strong><code class=\"language-text\">kitchen</code>에 대한 구현 객체</strong>를 직접 선택하는데 있다.<br>\n<strong>내가 다형성을 사용한게 확실한데, OCP 원칙을 위반</strong>하는 것이다.</p>\n<p>이 문제를 해결하기 위해서는 객체를 생성하고 연관관계를 맺어주는 <strong>별도의 설정자, 조립자</strong>가 필요하다.</p>\n<h3 id=\"lsp--리스코프-치환-원칙\" style=\"position:relative;\"><a href=\"#lsp--%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99\" aria-label=\"lsp  리스코프 치환 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LSP : 리스코프 치환 원칙</h3>\n<p>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.</p>\n<p>이게 무슨 소리일까…</p>\n<p>아까 위의 요리 사례에서 <code class=\"language-text\">kitchen</code> 인터페이스의 메소드인 <code class=\"language-text\">cook()</code>은 어쨌든 요리를 만드는 메소드다.<br>\n<code class=\"language-text\">fryKitchen</code> 이건, <code class=\"language-text\">boilKitchen</code>이건 요리가 만들어져야 하는 것이다.</p>\n<p>내가 <code class=\"language-text\">kitchen</code> 인터페이스를 구현하면서 <code class=\"language-text\">cook()</code> 메소드를 요리가 아닌 음쓰를 만든다면?<br>\n<code class=\"language-text\">kitchen</code> 인터페이스를 믿고 사용할 수 있을까?<br>\n조금 타더라도, 조금 느리더라도 <code class=\"language-text\">cook()</code>을 호출하면 <strong>요리는 만들어져야</strong> 한다.</p>\n<blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 672px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 126.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAIAAAC+dZmEAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFn0lEQVQ4yxXNWXMThwEA4P0LLcOkJNAIR7YOW/e1a+1KWmkP7b3aXUmr+5YlWRKyDsuyTGMg2NDAQAwxsjH4dsABJtC0ncz0re1MMtO39qUMTTvTP9Lp9wc+IBgCSQrRTF3RG6dJyu/x2pwei8Vm9IBmkoK/vL9+cLx7dLJzcjY5PZucfrN79vLg9Ju907Odk9MJUGtkqgvJWIKPyOGNu+MHjzcLZTWEg2jIFVeZrx5tHh7tnJztnpxNXp4/e/Xm+M3bF2++O3n1ev/Fy6fAUrex1KvXF3McHwrhXpoLIn6XH3XjBFSuxB9vf3lwNDk8/n+7frM//rx7997Nrcebk6f3nh9uAYPl9uq411+u+f3uGd3VS5cu6g1ak1mHYeBgubY9uf/sYPvw+Mne/sNElCJCEB5GMdzHCVhMZYHB8Npo3BuvtQUhFMLnlRhdrCQGo+ZSv9ps527fuf70+eOD4+2V1U6EIyIszothJS5KMicpDDBeba2tdddvLosKLynB7qBYb2XXbvQHK410iu12a5O9rd1nW7E4E8IghieqzUo8FRVESk1KQLY2iGQ7PrZkhykEMleq0dGokctKDOGlMUgRiM61+s7eFs+hPthebZSqi2WGxRkWE8QwYPdSbm+A4Wiew2HIjiJugcZkgaICXjowH/ZBqNux3G9kklw2J5WruVhMFCVaEMMMiwE4BnMsnk4pAktyVIjGUDFMyGSQ9lglxM1DDgG0iS5znMeycTqmMNEoz3Ekz1NkOAj4EAjyOOxzegKFaNSrClRWZFWPJWk3pBzGrE3fQpwFr0PxgXIIpoNe37wL9NgQnweBPYDLbrGa9PMeG4MhJOxU6VCKCLYQ5yMS3FXQo5LwOoY+F/03WDTtdQTtcx7r3KxhWq/Xmi0GAHTZUR/kh0HIaqK8rjjuLxPofj7y4ejGh/3Rzy83//lF8fdl6o95ogw70jYdj7jMJuOU5rLbbQUyKSWfi/MMqb/8CTI7HUc8X2Dgn+923r99+P78t+93Vv51K78lwBvOzzbD87cwt0DjHEOEQr6IQAGKxAYQUBaYjCqHQVuFxa6L2Ekr+ff99f/+6cm/z2//507tDxJ8C9RvhKFYAJI4mmfIZFLOZqNAOhUr5JOJqFivFSsyU0Khhs/54/3BPx50fv7h6Yd327/rFQ5V8k6Ky1GwKmDJKJ9NKbVqpnutApQKaTUWEWgiGY0Mu/VmlN3IRM7ujt48XN9bqT3qFD4vqr2cnKSQGAm1FxLNhbQihv0IKHI4IAqUJLIST4sMPlpuff3VxtvzZz/95fsf3h5O7q3dHjZWm/ks4/fO/Lqe4X4zqg97NZ/XdVVzZeqzTwEMDzAMIUcYmacblezO5MF3rw//9tfv351P7t/sDhtpOQgaf/VL1DnbKkvDpeJoUCcwxGQyMFQAMJl0DpsJ9rqZMBZhw912+dWLJ+++nRRkkoJtfptO9/HFqxcvhP3uVjXWbWbjCjutnfpUc6W1mAFmZ3UWq9Fum4PnXTSB+iC3KoW7i+npTz66fOEXmosXpi59ZNZq/G7rYjk+7Fbbi3kS9yNe16BbAuZMOqfL6nHbUf+8qrApVSYxlAjABu3Vac1li37aPKPV67R6rSYTo5e75fFwcTxsjPrV9estwGDUOpwWj8cRROG0KlSKyXwmwTGkF3S57BadVmOfM8xop0iPqZmTVvsLw0F90K0O+5VSQQaMszNms8ED2gnMn0lE6tVcq1FNJmKCwJBEEEYgPBQI+GGZxes5qdcpDpcbo5V6sRBVFAKw2owOhznghwQ+nElF262Ffq/dalRLhWwqGY1GJUmRhIiQiYtZmSwV4+PVdr2ejkTwhWocgLx2BPGgQViW2HIh3essjoe98WCp06wtVPOFQiaVSqpqtJyLX2ukWs1cqZykKF82IySS3P8AKLkNB3Qu+VcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wow\"\n        title=\"wow\"\n        src=\"/static/599793b7cfdf1d3fe82e4c031b73117e/30d16/wow.png\"\n        srcset=\"/static/599793b7cfdf1d3fe82e4c031b73117e/e9ff0/wow.png 180w,\n/static/599793b7cfdf1d3fe82e4c031b73117e/f21e7/wow.png 360w,\n/static/599793b7cfdf1d3fe82e4c031b73117e/30d16/wow.png 672w\"\n        sizes=\"(max-width: 672px) 100vw, 672px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\nLSP를 위반한 대표적인 사례 : 와갤요리</p>\n</blockquote>\n<p>즉, 하위 클래스는 인터페이스 규약을 다 지켜야 하는 것이다.<br>\n단순히 컴파일 시점에서의 성공의 얘기가 아닌 의미론적으로 맞아야 한다는 것이다.</p>\n<h3 id=\"isp--인터페이스-분리-원칙\" style=\"position:relative;\"><a href=\"#isp--%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\" aria-label=\"isp  인터페이스 분리 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ISP : 인터페이스 분리 원칙</h3>\n<p>특정 클래스를 위한 인터페이스 여러 개가 범용적인 인터페이스 하나보다 낫다.</p>\n<p>간단히 얘기해서 인터페이스를 작게 분리함으로써 <strong>명확하게끔하고, 대체가능성을 높</strong>이라는 것이다.</p>\n<p>위의 예시를 요리와 서빙, 포장으로 나누어보자.\n<code class=\"language-text\">kitchen</code> 인터페이스와 <code class=\"language-text\">serve</code> 인터페이스와 <code class=\"language-text\">pack</code> 인터페이스를 각각 분리함으로써<br>\n각각의 인터페이스를 명확하게 하고, 적절히 조합함으로써 대체 가능성을 높이는 것이다.</p>\n<h3 id=\"dip--의존관계-역전-원칙\" style=\"position:relative;\"><a href=\"#dip--%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99\" aria-label=\"dip  의존관계 역전 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DIP : 의존관계 역전 원칙</h3>\n<p>OCP 만큼이나 중요한 원칙이다.</p>\n<p>프로그래머는 <em><strong>“추상화에 의존해야지, 구체화에 의존하면 안된다.”</strong></em> 의존성 주입은 이 원칙을 따르는 방법 중 하나다.</p>\n<p>앞서 이야기한 역할에 의존하게 해야한다는 것과 같은 맥락이다.<br>\n클라이언트가 인터페이스가 아닌 구현체에 의존하게 되면 변경이 어려워진다.</p>\n<p>즉, 고든 램지는 내가 요리를 한다는 것에만 관심이 있지 구워서 만들지, 삶아서 만들지에 대해서는 관심이 없어야 한다는 것이다.<br>\n<strong>구워서 만드는 것이 어떻게 이루어지는지, 삶는 방법은 어떤지에 대해서 관심 끄라는 얘기!</strong> <del>이세계 고든 램지</del></p>\n<p>아까의 OCP 사례가 문제점이 있다고 했으니 다시 가져와보자.</p>\n<p>램지의 행동을 잘 보면 <code class=\"language-text\">kitchen k</code> 는 구현 클래스인 <code class=\"language-text\">fryKitchen</code>과 <code class=\"language-text\">boilKitchen</code>에 의존하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">램지 do :\n# kitchen k = new fryKitchen()\nkitchen k = new boilKitchen()</code></pre></div>\n<blockquote>\n<p>여기서 의존한다라는 것은 강사님이 말하길 “저 코드를 알기만 하면 의존이다.”</p>\n</blockquote>\n<p>클라이언트인 고든 램지가 직접 어떤 구현 클래스를 선택할지 선택함으로써 클라이언트가 <code class=\"language-text\">fryKitchen</code>과 <code class=\"language-text\">boilKitchen</code>에 의존하고 있다.</p>\n<p>이 부분에서 <strong>DIP</strong>를 위반하는 것이다.</p>\n<h2 id=\"다형성만으로는-부족해\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1%EB%A7%8C%EC%9C%BC%EB%A1%9C%EB%8A%94-%EB%B6%80%EC%A1%B1%ED%95%B4\" aria-label=\"다형성만으로는 부족해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성만으로는 부족해</h2>\n<p>객체지향의 핵심은 다형성인것은 분명하지만, 다형성만으로는 쉽게 갈아끼우는 레고처럼 개발할 수 없다.<br>\n다형성만 사용해서는 구현 객체를 변경할때 클라이언트인 램지의 행동도 변경이 된다.<br>\n다형성만으로는 <strong>OCP,DIP</strong>를 지킬 수 없는 것이다.</p>\n<p>뭔가가 더 필요하다.. More and More</p>\n<h2 id=\"객체-지향-설계와-스프링-1\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-1\" aria-label=\"객체 지향 설계와 스프링 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 설계와 스프링</h2>\n<p>스프링은 <strong>DI(Dependency Injection)</strong> 을 이용해서 OCP,DIP를 가능하게끔 해준다.<br>\n즉, 우리가 원하는 대로 레고를 조립하듯이 개발을 할 수 있게끔 해준다.</p>\n<blockquote>\n<p>DI 개념은 솔직히 공부만으로는 잘 이해가 안간다. 면접에서 받은 질문 중에 하나..</p>\n</blockquote>\n<p>앞으로 코드를 직접 작성해보면서 의존성 주입을 이해하며 스프링의 재미를 느끼고 싶다. <del>아니 느껴야 한다.</del></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\">들어가며</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%A7%84%EC%A7%9C-%ED%95%B5%EC%8B%AC\">스프링의 진짜 핵심</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%80\">좋은 객체 지향 프로그래밍은…</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\">다형성</a></p>\n<ul>\n<li><a href=\"#%EB%8B%AC%EC%84%B1%ED%95%98%EA%B3%A0%EC%9E%90-%ED%95%98%EB%8A%94-%EA%B2%83\">달성하고자 하는 것</a></li>\n<li><a href=\"#%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1\">자바에서의 다형성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5\">스프링과 객체 지향</a></p>\n</li>\n<li>\n<p><a href=\"#solid\">SOLID</a></p>\n<ul>\n<li><a href=\"#srp--%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\">SRP : 단일 책임 원칙</a></li>\n<li><a href=\"#ocp--%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\">OCP : 개방 폐쇄 원칙</a></li>\n<li><a href=\"#lsp--%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99\">LSP : 리스코프 치환 원칙</a></li>\n<li><a href=\"#isp--%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\">ISP : 인터페이스 분리 원칙</a></li>\n<li><a href=\"#dip--%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99\">DIP : 의존관계 역전 원칙</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1%EB%A7%8C%EC%9C%BC%EB%A1%9C%EB%8A%94-%EB%B6%80%EC%A1%B1%ED%95%B4\">다형성만으로는 부족해</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\">객체 지향 설계와 스프링</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"March 04, 2022","title":"스프링 핵심 원리 - 기본편 : 객체 지향 설계와 스프링","categories":"Spring","author":"weasel","emoji":"📓"},"fields":{"slug":"/spring-core-chap1/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/btree/","nextSlug":"/spring-core-chap1/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}