{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/stack-and-queue/",
    "result": {"data":{"cur":{"id":"900d1f47-ef6d-5598-b1bb-f6ffd1f5c715","html":"<h2 id=\"stack\" style=\"position:relative;\"><a href=\"#stack\" aria-label=\"stack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack</h2>\n<p>선형자료구조의 일종으로 LIFO의 특성을 가지고 있다. 가장 처음 들어간 원소가 가장 나중에 접근 가능 하고, 다시 말해서 호출 시에 가장 최근의 원소에 접근 할 수 있다. <code class=\"language-text\">O(n)</code>의 공간복잡도를 가진다.</p>\n<p>링크드 리스트를 이용한 구현과 배열을 이용한(정확히는 Dynamic Array) 두가지 버전이 있다. 링크드 리스트는 일관적인 시간복잡도 <code class=\"language-text\">O(1)</code>를 보여주는 대신에 추가적인 메모리 사용량(<em>Node 구조를 유지하는데 드는</em>)과 메모리 할당에 추가적인 비용이 들 수 있다.</p>\n<ul>\n<li>조회 : Top에 있는 원소를 조회할때는 <code class=\"language-text\">O(1)</code>, 하지만 특정한 데이터를 찾고자 할때는 <code class=\"language-text\">O(n)</code>이다.</li>\n<li>삽입 : 링크드 리스트를 이용한 구현에서는 단순히 기존의 Top 원소를 새 원소의 <code class=\"language-text\">next</code> 로 연결시켜주고 <code class=\"language-text\">head</code> 의 포인터에 새로운 원소를 연결시켜주면 되기 때문에 <code class=\"language-text\">O(1)</code>이다.</li>\n</ul>\n<p>배열을 이용한 구현에서도 특정 상황(Dynamic array의 팽창)을 제외하고는 <code class=\"language-text\">O(1)</code>이니 <code class=\"language-text\">amoritezd\\ O(1)</code>이다.</p>\n<ul>\n<li>삭제 : 링크드 리스트와 배열 모두 <code class=\"language-text\">O(1)</code>이다.</li>\n</ul>\n<h3 id=\"활용\" style=\"position:relative;\"><a href=\"#%ED%99%9C%EC%9A%A9\" aria-label=\"활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>활용</h3>\n<ul>\n<li>Stack Usage : JVM stack, 컴파일러에서 문법 체크(matching parentheses)</li>\n</ul>\n<aside>\n💡 프로그램의 함수 호출과 실행 순서에서 *1. 스택프레임에 지역변수,매개변수,복귀주소등의 정보를 저장하고 2. 함수의 실행이 끝나면 stack frame의 top을 pop한 후 복귀 주소로 복귀한다* 이기 때문에 , 가장 마지막에 호출된 함수를 가장 먼저 처리하고 복귀하는 후입선출의 구조이기 때문에 스택을 이용해서 관리한다.\n</aside>\n<h2 id=\"queue\" style=\"position:relative;\"><a href=\"#queue\" aria-label=\"queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue</h2>\n<p>선형자료구조로 FIFO의 특성을 가지고 있다. 먼저 들어간 원소가 가장 먼저 나오는 구조를 가지고 있다. <code class=\"language-text\">O(n)</code>의 공간복잡도를 가진다.</p>\n<p>배열을 이용해 구현할때는 단순 배열보다 원형 구조 (circular queue)를 이용해서 구현한다. 혹은 링크드 리스트를 이용해서 구현할수 도 있는데 이때는 <code class=\"language-text\">head</code> 와 <code class=\"language-text\">tail</code> 에 대한 정보를 기록해야 한다.</p>\n<ul>\n<li>조회 : 가장 끝에 있는 원소를 조회할때는 <code class=\"language-text\">O(1)</code>.</li>\n<li>삽입 : 링크드 리스트를 이용한 구현해서는 <code class=\"language-text\">O(1)</code>. 동적 배열을 이용할때는 <code class=\"language-text\">amoritezd\\ O(1)</code>이다. 원형 배열을 이용할때는 <code class=\"language-text\">O(1)</code>.</li>\n<li>삭제 : 모두 <code class=\"language-text\">O(1)</code>.</li>\n</ul>\n<p>스택과 큐 모두 배열을 이용하거나 링크드 리스트를 이용해 구현가능한데, 배열을 사용하는 경우에는 Dynamic array의 팽창을 고려해야하기 때문에 최악의 경우에는 느리지만, 전반적인 성능이 좋다. 반대로 링크드 리스트를 이용한 구현에서는 일관된 성능(<code class=\"language-text\">O(1)</code>)을 보여주지만, 메모리 할당에 들어가는 추가적인 비용 때문에 런타임 성능이 낮을 수 있다.</p>\n<h3 id=\"활용-1\" style=\"position:relative;\"><a href=\"#%ED%99%9C%EC%9A%A9-1\" aria-label=\"활용 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>활용</h3>\n<ul>\n<li>Queue Usage : 스케쥴링,키보드 버퍼 → 두 개 모두 데이터 혹은 요청이 입력된 시간 순서대로 처리해야할 필요가 있을 경우에 사용한다.</li>\n</ul>\n<h2 id=\"문제들\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EB%93%A4\" aria-label=\"문제들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제들</h2>\n<ul>\n<li>\n<p><strong>두 개의 스택으로 큐를 구현하기</strong></p>\n<p>생각보다 엄청 간단하다. 두 개의 스택을 각각 <code class=\"language-text\">in</code>과 <code class=\"language-text\">out</code>으로 구분하고, A,B,C 세개의 데이터가 입력으로 주어진다고 해보자. 출력은 A,B,C가 나와야 한다.</p>\n<ol>\n<li><code class=\"language-text\">in</code> 에 A,B,C를 차례로 push. 그러면 <code class=\"language-text\">in</code> 에는 <code class=\"language-text\">[A,B,C]</code> 의 순서대로 데이터가 쌓일 것이다.</li>\n<li>그 후 <code class=\"language-text\">in</code> 의 데이터를 각각 pop하면 C,B,A의 순서대로 나올것이다. 그 후  <code class=\"language-text\">out</code> 으로 push해보자. <code class=\"language-text\">out : [C,B,A]</code></li>\n<li>이후 <code class=\"language-text\">out</code> 의 원소들을 순서대로 pop하면 출력은 A,B,C가 나오고 <code class=\"language-text\">out: []</code></li>\n</ol>\n  <aside>\n  💡 네. 2개의 스택을 이용하여 구현할 수 있습니다. Enqueue 연산은 첫번째 스택에 원소를 추가하면 됩니다. Dequeue 연산은 두번째 스택을 이용합니다. 우선 두번째 스택이 비어있다면 첫번째 스택이 빌 때까지 첫번째 스택의 원소를 pop하고 두번째 스택에 push하는 것을 반복합니다. 그리고 두번째 스택이 비어있지 않다면 두번째 스택의 원소를 pop하면 됩니다.\n  </aside>\n</li>\n<li>\n<p><strong>스택에서 min을 <code class=\"language-text\">O(1)</code>에 작동하도록 하기</strong></p>\n<p>일단 최소 요소를 기록하는 <code class=\"language-text\">minEle</code> 변수를 stack 내부에 구현한다. 그 후 아래와 같은 사고방식대로 접근한다.</p>\n<h3 id=\"삽입\" style=\"position:relative;\"><a href=\"#%EC%82%BD%EC%9E%85\" aria-label=\"삽입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삽입</h3>\n<ol>\n<li>만약 스택이 비어있다면 <code class=\"language-text\">x</code> 를 삽입할때, <code class=\"language-text\">minEle=x</code> 로 할당한다.</li>\n<li>그렇지 않다면, <code class=\"language-text\">x</code> 와 <code class=\"language-text\">minEle</code> 의 대소를 비교해야하는데 두가지 경우가 존재한다.\n<ol>\n<li><code class=\"language-text\">x</code>가 <code class=\"language-text\">minEle</code> 보다 크거나 같다면, 그냥 삽입한다.</li>\n<li><code class=\"language-text\">minEle</code> 보다 작다면, <code class=\"language-text\">2x-minEle</code> 를 스택에 삽입하고, <code class=\"language-text\">minEle</code> 를 <code class=\"language-text\">x</code> 로 초기화해준다.</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"삭제\" style=\"position:relative;\"><a href=\"#%EC%82%AD%EC%A0%9C\" aria-label=\"삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삭제</h3>\n<ol>\n<li><code class=\"language-text\">y</code> 가 <code class=\"language-text\">min</code> 보다 크거나 같으면, <code class=\"language-text\">y</code> 를 그냥 삭제한다. 여전히 최소값은 <code class=\"language-text\">minEle</code> 다. 그리고 그 값은 스택이 아닌 <code class=\"language-text\">minELe</code> 에 있다고 보는것이 맞다.</li>\n<li><code class=\"language-text\">y</code> 가 <code class=\"language-text\">minEle</code> 보다 작을 경우에, <code class=\"language-text\">minEle</code> 를 <code class=\"language-text\">2*minEle-y</code> 로 변경해준다.</li>\n</ol>\n<h3 id=\"원리\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EB%A6%AC\" aria-label=\"원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원리</h3>\n<p><code class=\"language-text\">minEle</code> 보다 작은 원소가 삽입될때 우리는 <code class=\"language-text\">2x-minEle</code> 를 삽입하는데, 언제나 그것은 <code class=\"language-text\">x</code> 보다는 작다는 것이다.</p>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#stack\">Stack</a></p>\n<ul>\n<li><a href=\"#%ED%99%9C%EC%9A%A9\">활용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#queue\">Queue</a></p>\n<ul>\n<li><a href=\"#%ED%99%9C%EC%9A%A9-1\">활용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%AC%B8%EC%A0%9C%EB%93%A4\">문제들</a></p>\n</li>\n</ul>\n</div>","excerpt":"Stack 선형자료구조의 일종으로 LIFO의 특성을 가지고 있다. 가장 처음 들어간 원소가 가장 나중에 접근 가능 하고, 다시 말해서 호출 시에 가장 최근의 원소에 접근 할 수 있다. 의 공간복잡도를 가진다. 링크드 리스트를 이용한 구현과 배열을 이용한(정확히는 Dynamic Array) 두가지 버전이 있다. 링크드 리스트는 일관적인 시간복잡도 를 보여주는 대신에 추가적인 메모리 사용량(Node 구조를 유지하는데 드는)과 메모리 할당에 추가적인 비용이 들 수 있다. 조회 : Top에 있는 원소를 조회할때는 , 하지만 특정한 데이터를 찾고자 할때는 이다. 삽입 : 링크드 리스트를 이용한 구현에서는 단순히 기존의 Top 원소를 새 원소의  로 연결시켜주고  의 포인터에 새로운 원소를 연결시켜주면 되기 때문에 이다. 배열을 이용한 구현에서도 특정 상황(Dynamic array의 팽창)을 제외하고는 이니 이다. 삭제 : 링크드 리스트와 배열 모두 이다. 활용 Stack Usage : JV…","frontmatter":{"date":"February 05, 2022","title":"Stack과 Queue","categories":"자료구조","author":"weasel","emoji":"📓"},"fields":{"slug":"/stack-and-queue/"}},"next":{"id":"970ad7e7-c529-5911-b5d5-ca08c1dcb821","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAADJElEQVQozwEZA+b8AImBY7OpjtvTu9vUwMG5o+jn4Pz89vn58vv58Pj25/z77vDgz7Gkg3d7X7CZiP/Ut+69oJySh4WCfDcwKQCXjGnFwqvz8OHVz7zEvavk5Nv8/fb6+u76+O369+fd1MHItqCnooeBfWihkH+xln+yln6elIaHf3VfVkUAiIFjubag5uLQ0su6xsGyv7Wi8e7d5ubW9vPkzMGvl29TkG9crqOScmdXgXVfqpp+mYtwlYZtinpjdWtYAIGAaYeHd6CWgtjWy7CYgdirkamKbuXexPPs2rKjkK95YMmJa66cioV2W66ijOLPs6WYhJeVhJCPez45LgB8emNtb12km4nRzL+ecVjcoouUY0q8rJb79uS7sqqzl4udgXigrsOblIbGvKjmxayGYk9WRS69tp5WVU0Agn1oX19RoJuNraOVkl5G15Z/nWZNlXxrwKulsZ+ZqpyXnaCpn6q+hpSuyc3IuZV7q3ZXXkElnW5BTEU9ALGYfX5yYcaoj4R0X0QoFsuCXlw2IU85J9awocW4tp+ZnKGiqLCxs4CImr2+v3JbRJBoSdi7n5CEYqCbfwDHuKnDq5ffzr+gal16QSfDjWarfWJ/OCvy2tTX19O/v8GIjJSiprKoqrGppKGnloOxm4nOtKGawKzM0KoAtpJ4npmK2aKb/TtJ50dL4Vtc82Jl/jdG9Y6H///5sbTAOUZee2FXqYd+bW5/vLKrvbSwp6eop6qqdnR5AM69qZ6UfsBsUOBSWcPAwsenq7+Rl+pKU+SLafrz6KOpuT5KYqF3YJWAfnBrd6ymob+MbI+Tkc3V3J2eqQD1+POUiG6fWTjyMTn0NEbzNkf1PU34PEPYiGHu3tF5g5ZeZn6gdmJsbn+IjJ/dwbCuinGMq7na29jP0dQA5+jhxMa9rXVYyQ0J5wAF6wEK7QAM3BEW2o9pzMG7ZXOQfYGVmHdrZXaUmpmpuI50jJ6nttfm6+3p9fLsAOjo5erm3sGOcsxGQOIAB+cEDt4AAcYSDNyeeqSjqlBZbGFSUpl0bmBuioeEkHt2fE5kioukuuDm6f///vOR1ytpahhqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"meme\"\n        title=\"meme\"\n        src=\"/static/2117ef67cec6809a66915464c50776bd/37523/meme.png\"\n        srcset=\"/static/2117ef67cec6809a66915464c50776bd/e9ff0/meme.png 180w,\n/static/2117ef67cec6809a66915464c50776bd/f21e7/meme.png 360w,\n/static/2117ef67cec6809a66915464c50776bd/37523/meme.png 720w,\n/static/2117ef67cec6809a66915464c50776bd/1d69c/meme.png 750w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"java-7의-jvm\" style=\"position:relative;\"><a href=\"#java-7%EC%9D%98-jvm\" aria-label=\"java 7의 jvm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Java 7의 JVM</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.111111111111107%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABfElEQVQY0y2OPUsbAQBA8zfEtaMQsZIOKgaswY8Qo0bp4FAnEeng1k5SxMmlfgx+UyQfkkrd7FAbmsRGPNIKiTTJ3eVMzhg/yJlE8ZJyxidKhwfvbc+Uv7gklpSRszkS6QzBA4EfoV/EEiJSJkfqRGX/MEogFCF0ILAXjhAMhUnHY5xGwmTDP8kGA2T+RMlIIib/oYp1I4XLK+PcUuj3ygz40nTNC/S6JVy7BZwe6bn73CKOPZ2Ps16ObWYK48OcjjqID7/mamwQfX4ak084o3lV5NVSAsuahGU5iXnxL/XvA7Ssp3j5tYh5RaFpahvrwjfadkQmPywQb6pDe2tHaX3BkbUBbdTO/dQ7TNu/87R/lnF6ZBy+E+xuGYcnjW1OoHtTZPBLFpdfpXNOoHczSc93nZlPfhK2RgpjLnIjXRwPdaBNvMF4OqwaNUqVe8rV/zx5xaBUrVG+vqHo2UJR80jqOUrugqvbKnrlH0bpmtpN+RmjqFErajzodzwCEIszbXlPJeoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/51f2865401bf42f831eebc6e076cd1cf/37523/jvm7.png\"\n        srcset=\"/static/51f2865401bf42f831eebc6e076cd1cf/e9ff0/jvm7.png 180w,\n/static/51f2865401bf42f831eebc6e076cd1cf/f21e7/jvm7.png 360w,\n/static/51f2865401bf42f831eebc6e076cd1cf/37523/jvm7.png 720w,\n/static/51f2865401bf42f831eebc6e076cd1cf/6c2f2/jvm7.png 767w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n기존의 Java 7 까지의 Non Heap Area였던 Permanent Generation이 Native 영역인 Metaspace로 바뀌었다.</p>\n<p>기존의 Permanent 영역에는 아래와 같은 정보들이 저장되었다.</p>\n<ul>\n<li><strong>Class의 메타데이터 (바이트코드 포함)</strong></li>\n<li>Method의 메타데이터</li>\n<li><strong>static 객체, static 상수</strong></li>\n<li><strong>상수화된 String Object</strong></li>\n<li>Class와 관련된 배열 객체 메타데이터</li>\n<li>JVM 내부적인 객체들과 JIT의 최적화 정보</li>\n</ul>\n<h3 id=\"oom-문제점\" style=\"position:relative;\"><a href=\"#oom-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"oom 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OOM 문제점</h3>\n<p>이런 많은것들이 PermG안에 있다보니 , String Constant Pool, static object, Class 메타 데이터들이 쌓여 OOM이 발생하곤 했다. PermG는 시작할때부터 크게 잡지 않는 이상 리사이징이 되지 않아 그런 문제가 발생하곤 했다. <a href=\"https://goodgid.github.io/Java-8-JVM-Metaspace/\">좋은 글</a></p>\n<h2 id=\"java-8의-jvm\" style=\"position:relative;\"><a href=\"#java-8%EC%9D%98-jvm\" aria-label=\"java 8의 jvm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Java 8의 JVM</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiElEQVQY0xXFT2hSAQDA4XfquFuHOi1ownITIUi2CTtFh9aldqmIEMnw0laHBh46hCyCDo6IFtSYjFJnBKNLRAddysRZ6bbH5mZP36IYOn2+9/Z8zn+/0Xf5hKZep9tQodXAqJUpiDlKuyJdU4Njg46uUKlVUdodtG4P1WyiFSX0fZn6/80mBqC0OigNE2EmlMa9LOINZfFGNvCEc9wLpnEvrOGJbuH58oePgXmqTx7wz++jPOtja8pF2j1J6fF9xIduMt7b7E27OAgtINz9kGf0/V9G3mwz8u4340sy1hdZLP4UzqCE9XObiG+W9rV+KpN21Bt2xItn2RgbQL9zBcl5HnHCgea6Cq+fIdxc3MSxWGQokGP41Ta2+TyDzzNYniZxvM1jWzGZ8zxCHD7Fj9Ez/Lx0mqSlj6zjHLVbl9l1DvBr/AKH18dov/QjrMsqMdnge1EjIR+R2D8iIanE92rESzrJSg8plaESXmInGqHwaRlpJYoS+0orvYqRilNf/cZxKkZPLnACNfgunqfsHK0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/bb5245914008655bff34d9e7e26c4ef6/37523/jvm8.png\"\n        srcset=\"/static/bb5245914008655bff34d9e7e26c4ef6/e9ff0/jvm8.png 180w,\n/static/bb5245914008655bff34d9e7e26c4ef6/f21e7/jvm8.png 360w,\n/static/bb5245914008655bff34d9e7e26c4ef6/37523/jvm8.png 720w,\n/static/bb5245914008655bff34d9e7e26c4ef6/c8e86/jvm8.png 758w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\nJava 8에서부턴 PermG 영역을 삭제하고 <strong>Metaspace</strong> 영역을 추가해 <strong>Native 메모리의 영역</strong>으로 이동시켰다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 398px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQY01WR6U7CQBRG+5QaiZFn8QcuzyEhLvAILggxcUmUVoEAVRHsAqUVCAXtzBzTAY3+OLknmck3d+41QAFyxV+XSAmeH/D5JbQnYomQ/1FKIaXS1cjfC7bPFbuXityFYKesyJVhr6K47r7R9js0PJumb9MavmhSb3o2dbeNPejrx9JWEqEw9iuwXojJHsdkS4KNgxEb+YitQshZu0lzUMNyLcz3B64aVar1ivYnz6Lm3NMJnlnMF3i+R5IkGGlna4cJW8WEzaIgczgnc7QgezLXgQ3/AdMxMZ0ady833L3ean90TR3YGthIIZnFM6SUGKcdQaGmKNXRFOtwZClOLEnDG9CPHLojl17k4U4D3MmQXujyFrp0Rw5OFCBWc/1KFMby94LZ9INxNGI2iX4XpCR6PumVOF4wDCLCcKwDlFqepTVdxg/fWoS2MAIE3uAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/0201f2a4812c06c34fcf9d31f598e0f4/692d4/jvm8_area.png\"\n        srcset=\"/static/0201f2a4812c06c34fcf9d31f598e0f4/e9ff0/jvm8_area.png 180w,\n/static/0201f2a4812c06c34fcf9d31f598e0f4/f21e7/jvm8_area.png 360w,\n/static/0201f2a4812c06c34fcf9d31f598e0f4/692d4/jvm8_area.png 398w\"\n        sizes=\"(max-width: 398px) 100vw, 398px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"구체적인-변경점\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%EB%B3%80%EA%B2%BD%EC%A0%90\" aria-label=\"구체적인 변경점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구체적인 변경점</h3>\n<p>기존의 PermG 영역에 있던 정보들은 이렇게 변경되었다.</p>\n<ul>\n<li>Class의 메타데이터 (바이트코드 포함) → MetaSpace로 이동</li>\n<li>Method의 메타데이터 → MetaSpace로 이동</li>\n<li>static 객체,static 변수 (class variable) → <strong>Heap으로 이동,</strong></li>\n<li>상수화된 String Object → <strong>Heap으로 이동</strong></li>\n<li>Class와 관련된 배열 객체 메타데이터 → Metaspace로 이동</li>\n<li>JVM 내부적인 객체들과 JIT의 최적화 정보 → Metaspace로 이동</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 631px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACFUlEQVQozz2QSW8TQRCF57chEUggYCRuQXAAEZMQHHEhiAST4CAOQJByR+I/ES+zuWfrGXvGs2c8i52HuuT48NTV9XVVVz1pb+sUndY5Oo97ePeoh06rR7HIfXp+gfdPv+Ng+ysOn5wTF7E4j3Z+4Gjn5/ou+lwe/4X06s4xdjc+4/XdE7TvdfH24Rl2N05wsN1D9+UlDlvf6PGbzS7a979gf+uMdPziNz4++4W9zVPsPzhDe6OLiw9/IHHXgcNt2I6JvMiwWNQQubKao24qNIsaN1jADyaIkxA3WKJZ1qjrivhi2ZCWNw2KIoc06A+gqipkWYaiKAgCH5qmIQgCJHGMKIoQxzEMxsAdB1mWUT5JEsRRRPxWsyCAJIrHug7GGCzLwnQ6oTgMQ6RpSoVZmsK2rDWfTibwfR9pkhBPV4rCGSTxs65p0DQVlmnCMg2YpoE8z1GVJebzOcpyDu7YNLmqKDAMBtu2UZYlsds3WZpAGg2HUGSZ1sqzjNYQ649GIwh2dfWPYvGhLI/IHkWRoaoKsX6/j8FggOFwCIONIcUrj9I0WfvDOYfjrMQ5oiiE53mwLJtytu2QXNdFFIYIwxlZRB6OGSPPiqJAXdc0uudNoY8N6GMGZlrkZTCbQdMZdGasmAHTcpDn12iahnSd55CEV2Iy4UdVVdTY9wM43F3JA+cegmAG7nqwaWpvLdebrmuzLMV/OK2xFYhJGpwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/b3af97e1eb3705e13c4c5454c9a8e632/4597d/diff.png\"\n        srcset=\"/static/b3af97e1eb3705e13c4c5454c9a8e632/e9ff0/diff.png 180w,\n/static/b3af97e1eb3705e13c4c5454c9a8e632/f21e7/diff.png 360w,\n/static/b3af97e1eb3705e13c4c5454c9a8e632/4597d/diff.png 631w\"\n        sizes=\"(max-width: 631px) 100vw, 631px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위와 같이 변경하면서 , 기존 PermG에 있던 Static Object가 Heap 영역으로 옮겨져서 GC의 대상이 될 수 있게 하였다.</p>\n<ul>\n<li>장점\n<ul>\n<li>Native(Metaspace)로 많은 부분을 옮기면서, Native 영역은 JVM에 의해서 크기가 강제되지 않고, 프로세스가 이용할 수 있는 메모리 자원을 최대로 활용할 수 있게 되었다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 Metaspace 영역은 Heap이 아닌 Native 메모리 영역안에 있다. Heap 영역은 JVM이 관리하고 Native 영역은 OS레벨에서 관리해 자동으로 크기를 조절하고, Metaspace가 Native 메모리를 사용함으로써 개발자는 메모리에서의 영역확보의 상한을 크게 인식할 필요가 없게 되었다. 이것이 Java 8에서 Metaspace가 도입된 이유이다.</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#java-7%EC%9D%98-jvm\">Java 7의 JVM</a></p>\n<ul>\n<li><a href=\"#oom-%EB%AC%B8%EC%A0%9C%EC%A0%90\">OOM 문제점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#java-8%EC%9D%98-jvm\">Java 8의 JVM</a></p>\n<ul>\n<li><a href=\"#%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%EB%B3%80%EA%B2%BD%EC%A0%90\">구체적인 변경점</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 13, 2022","title":"JVM의 Java 8에서의 변화","categories":"Java","author":"weasel","emoji":"📓"},"fields":{"slug":"/jvm-change-in-java8/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/stack-and-queue/","nextSlug":"/jvm-change-in-java8/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}