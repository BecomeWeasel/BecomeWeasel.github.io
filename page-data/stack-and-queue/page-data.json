{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/stack-and-queue/",
    "result": {"data":{"cur":{"id":"900d1f47-ef6d-5598-b1bb-f6ffd1f5c715","html":"<h2 id=\"stack\" style=\"position:relative;\"><a href=\"#stack\" aria-label=\"stack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack</h2>\n<p>선형자료구조의 일종으로 LIFO의 특성을 가지고 있다. 가장 처음 들어간 원소가 가장 나중에 접근 가능 하고, 다시 말해서 호출 시에 가장 최근의 원소에 접근 할 수 있다. <code class=\"language-text\">O(n)</code>의 공간복잡도를 가진다.</p>\n<p>링크드 리스트를 이용한 구현과 배열을 이용한(정확히는 Dynamic Array) 두가지 버전이 있다. 링크드 리스트는 일관적인 시간복잡도 <code class=\"language-text\">O(1)</code>를 보여주는 대신에 추가적인 메모리 사용량(<em>Node 구조를 유지하는데 드는</em>)과 메모리 할당에 추가적인 비용이 들 수 있다.</p>\n<ul>\n<li>조회 : Top에 있는 원소를 조회할때는 <code class=\"language-text\">O(1)</code>, 하지만 특정한 데이터를 찾고자 할때는 <code class=\"language-text\">O(n)</code>이다.</li>\n<li>삽입 : 링크드 리스트를 이용한 구현에서는 단순히 기존의 Top 원소를 새 원소의 <code class=\"language-text\">next</code> 로 연결시켜주고 <code class=\"language-text\">head</code> 의 포인터에 새로운 원소를 연결시켜주면 되기 때문에 <code class=\"language-text\">O(1)</code>이다.</li>\n</ul>\n<p>배열을 이용한 구현에서도 특정 상황(Dynamic array의 팽창)을 제외하고는 <code class=\"language-text\">O(1)</code>이니 <code class=\"language-text\">amoritezd\\ O(1)</code>이다.</p>\n<ul>\n<li>삭제 : 링크드 리스트와 배열 모두 <code class=\"language-text\">O(1)</code>이다.</li>\n</ul>\n<h3 id=\"활용\" style=\"position:relative;\"><a href=\"#%ED%99%9C%EC%9A%A9\" aria-label=\"활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>활용</h3>\n<ul>\n<li>Stack Usage : JVM stack, 컴파일러에서 문법 체크(matching parentheses)</li>\n</ul>\n<blockquote>\n<p>💡 프로그램의 함수 호출과 실행 순서는 아래와 같으니</p>\n<ol>\n<li>스택프레임에 지역변수,매개변수,복귀주소등의 정보를 저장하고</li>\n<li>함수의 실행이 끝나면 stack frame의 top을 pop한 후 복귀 주소로 복귀한다</li>\n</ol>\n<p>가장 마지막에 호출된 함수를 가장 먼저 처리하고 복귀하는 후입선출의 구조를 처리하기 위해서 스택을 이용해서 관리한다.</p>\n</blockquote>\n<h2 id=\"queue\" style=\"position:relative;\"><a href=\"#queue\" aria-label=\"queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue</h2>\n<p>선형자료구조로 FIFO의 특성을 가지고 있다. 먼저 들어간 원소가 가장 먼저 나오는 구조를 가지고 있다. <code class=\"language-text\">O(n)</code>의 공간복잡도를 가진다.</p>\n<p>배열을 이용해 구현할때는 단순 배열보다 원형 구조 (circular queue)를 이용해서 구현한다. 혹은 링크드 리스트를 이용해서 구현할수 도 있는데 이때는 <code class=\"language-text\">head</code> 와 <code class=\"language-text\">tail</code> 에 대한 정보를 기록해야 한다.</p>\n<ul>\n<li>조회 : 가장 끝에 있는 원소를 조회할때는 <code class=\"language-text\">O(1)</code>.</li>\n<li>삽입 : 링크드 리스트를 이용한 구현해서는 <code class=\"language-text\">O(1)</code>. 동적 배열을 이용할때는 <code class=\"language-text\">amoritezd\\ O(1)</code>이다. 원형 배열을 이용할때는 <code class=\"language-text\">O(1)</code>.</li>\n<li>삭제 : 모두 <code class=\"language-text\">O(1)</code>.</li>\n</ul>\n<p>스택과 큐 모두 배열을 이용하거나 링크드 리스트를 이용해 구현가능한데, 배열을 사용하는 경우에는 Dynamic array의 팽창을 고려해야하기 때문에 최악의 경우에는 느리지만, 전반적인 성능이 좋다. 반대로 링크드 리스트를 이용한 구현에서는 일관된 성능(<code class=\"language-text\">O(1)</code>)을 보여주지만, 메모리 할당에 들어가는 추가적인 비용 때문에 런타임 성능이 낮을 수 있다.</p>\n<h3 id=\"활용-1\" style=\"position:relative;\"><a href=\"#%ED%99%9C%EC%9A%A9-1\" aria-label=\"활용 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>활용</h3>\n<ul>\n<li>Queue Usage : 스케쥴링,키보드 버퍼 → 두 개 모두 데이터 혹은 요청이 입력된 시간 순서대로 처리해야할 필요가 있을 경우에 사용한다.</li>\n</ul>\n<h2 id=\"문제들\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EB%93%A4\" aria-label=\"문제들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제들</h2>\n<ul>\n<li>\n<p><strong>두 개의 스택으로 큐를 구현하기</strong></p>\n<p>생각보다 엄청 간단하다. 두 개의 스택을 각각 <code class=\"language-text\">in</code>과 <code class=\"language-text\">out</code>으로 구분하고, A,B,C 세개의 데이터가 입력으로 주어진다고 해보자. 출력은 A,B,C가 나와야 한다.</p>\n<ol>\n<li><code class=\"language-text\">in</code> 에 A,B,C를 차례로 push. 그러면 <code class=\"language-text\">in</code> 에는 <code class=\"language-text\">[A,B,C]</code> 의 순서대로 데이터가 쌓일 것이다.</li>\n<li>그 후 <code class=\"language-text\">in</code> 의 데이터를 각각 pop하면 C,B,A의 순서대로 나올것이다. 그 후  <code class=\"language-text\">out</code> 으로 push해보자. <code class=\"language-text\">out : [C,B,A]</code></li>\n<li>이후 <code class=\"language-text\">out</code> 의 원소들을 순서대로 pop하면 출력은 A,B,C가 나오고 <code class=\"language-text\">out: []</code></li>\n</ol>\n  <aside>\n  💡 네. 2개의 스택을 이용하여 구현할 수 있습니다. Enqueue 연산은 첫번째 스택에 원소를 추가하면 됩니다. Dequeue 연산은 두번째 스택을 이용합니다. 우선 두번째 스택이 비어있다면 첫번째 스택이 빌 때까지 첫번째 스택의 원소를 pop하고 두번째 스택에 push하는 것을 반복합니다. 그리고 두번째 스택이 비어있지 않다면 두번째 스택의 원소를 pop하면 됩니다.\n  </aside>\n</li>\n<li>\n<p><strong>스택에서 min을 <code class=\"language-text\">O(1)</code>에 작동하도록 하기</strong></p>\n<p>일단 최소 요소를 기록하는 <code class=\"language-text\">minEle</code> 변수를 stack 내부에 구현한다. 그 후 아래와 같은 사고방식대로 접근한다.</p>\n<h3 id=\"삽입\" style=\"position:relative;\"><a href=\"#%EC%82%BD%EC%9E%85\" aria-label=\"삽입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삽입</h3>\n<ol>\n<li>만약 스택이 비어있다면 <code class=\"language-text\">x</code> 를 삽입할때, <code class=\"language-text\">minEle=x</code> 로 할당한다.</li>\n<li>그렇지 않다면, <code class=\"language-text\">x</code> 와 <code class=\"language-text\">minEle</code> 의 대소를 비교해야하는데 두가지 경우가 존재한다.\n<ol>\n<li><code class=\"language-text\">x</code>가 <code class=\"language-text\">minEle</code> 보다 크거나 같다면, 그냥 삽입한다.</li>\n<li><code class=\"language-text\">minEle</code> 보다 작다면, <code class=\"language-text\">2x-minEle</code> 를 스택에 삽입하고, <code class=\"language-text\">minEle</code> 를 <code class=\"language-text\">x</code> 로 초기화해준다.</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"삭제\" style=\"position:relative;\"><a href=\"#%EC%82%AD%EC%A0%9C\" aria-label=\"삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삭제</h3>\n<ol>\n<li><code class=\"language-text\">y</code> 가 <code class=\"language-text\">min</code> 보다 크거나 같으면, <code class=\"language-text\">y</code> 를 그냥 삭제한다. 여전히 최소값은 <code class=\"language-text\">minEle</code> 다. 그리고 그 값은 스택이 아닌 <code class=\"language-text\">minELe</code> 에 있다고 보는것이 맞다.</li>\n<li><code class=\"language-text\">y</code> 가 <code class=\"language-text\">minEle</code> 보다 작을 경우에, <code class=\"language-text\">minEle</code> 를 <code class=\"language-text\">2*minEle-y</code> 로 변경해준다.</li>\n</ol>\n<h3 id=\"원리\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EB%A6%AC\" aria-label=\"원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원리</h3>\n<p><code class=\"language-text\">minEle</code> 보다 작은 원소가 삽입될때 우리는 <code class=\"language-text\">2x-minEle</code> 를 삽입하는데, 언제나 그것은 <code class=\"language-text\">x</code> 보다는 작다는 것이다.</p>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#stack\">Stack</a></p>\n<ul>\n<li><a href=\"#%ED%99%9C%EC%9A%A9\">활용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#queue\">Queue</a></p>\n<ul>\n<li><a href=\"#%ED%99%9C%EC%9A%A9-1\">활용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%AC%B8%EC%A0%9C%EB%93%A4\">문제들</a></p>\n</li>\n</ul>\n</div>","excerpt":"Stack 선형자료구조의 일종으로 LIFO의 특성을 가지고 있다. 가장 처음 들어간 원소가 가장 나중에 접근 가능 하고, 다시 말해서 호출 시에 가장 최근의 원소에 접근 할 수 있다. 의 공간복잡도를 가진다. 링크드 리스트를 이용한 구현과 배열을 이용한(정확히는 Dynamic Array) 두가지 버전이 있다. 링크드 리스트는 일관적인 시간복잡도 를 보여주는 대신에 추가적인 메모리 사용량(Node 구조를 유지하는데 드는)과 메모리 할당에 추가적인 비용이 들 수 있다. 조회 : Top에 있는 원소를 조회할때는 , 하지만 특정한 데이터를 찾고자 할때는 이다. 삽입 : 링크드 리스트를 이용한 구현에서는 단순히 기존의 Top 원소를 새 원소의  로 연결시켜주고  의 포인터에 새로운 원소를 연결시켜주면 되기 때문에 이다. 배열을 이용한 구현에서도 특정 상황(Dynamic array의 팽창)을 제외하고는 이니 이다. 삭제 : 링크드 리스트와 배열 모두 이다. 활용 Stack Usage : JV…","frontmatter":{"date":"February 01, 2022","title":"Stack과 Queue","categories":"자료구조","author":"weasel","emoji":"📓"},"fields":{"slug":"/stack-and-queue/"}},"next":{"id":"37b121af-aaea-5b5c-96bd-dbe71d964439","html":"<h2 id=\"array\" style=\"position:relative;\"><a href=\"#array\" aria-label=\"array permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array</h2>\n<p>논리적 저장순서와 물리적 저장순서가 일치한다. 다시 말해서 <code class=\"language-text\">a[2]</code> 와 다음에 오는 <code class=\"language-text\">a[3]</code> 는 물리적으로 연결되어 있다.\n하지만, 하나의 Array의 크기가 너무 커 하나의 page(혹은 frame) 안에 다 못들어오는 경우에는 <strong>virtual adress는 <em>연속적</em>으로 이어져있지만, physical adress에서도 그렇다는 보장은 없다.</strong></p>\n<blockquote>\n<p>💡 하지만 physical adress와 virtual address에 관한 문제는 OS가 처리할 일이고 프로그래머에게 보이지 않는 추상계층이기에 우리가 깊게 생각할 필요는 없다고 생각한다.</p>\n</blockquote>\n<p>또, 한번 사이즈가 정해지면 변할 수 없다. 이를 해결하는 방법이 Dynamic Array다.</p>\n<ul>\n<li>조회 : 인덱스를 기반으로 한 접근이 가능하다. 인덱스를 알고 있다면 <code class=\"language-text\">O(1)</code>의 시간 내에 접근이 가능한데 , <strong>이것을 Random Access</strong>라고 한다.</li>\n<li>삽입 : Array의 특정 위치에 삽입을 할때는 원소를 넣고 끝나는 것이 아니라, 기존의 원소들을 shift 해주는 비용이 생기기 때문에 <code class=\"language-text\">O(n)</code>의 비용이 든다.</li>\n<li>삭제 : 삽입과 마찬가지로 shift의 비용 때문에 <code class=\"language-text\">O(n)</code>이 소요된다. 만약 shift를 해주지 않는다면 삭제를 한 곳에 빈 공간이 생기게 될것이고, contiguous한 Array의 특성이 깨진다.</li>\n</ul>\n<h2 id=\"arraylist\" style=\"position:relative;\"><a href=\"#arraylist\" aria-label=\"arraylist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ArrayList</h2>\n<p>Java 기준으로 primitive만 저장 할 수 있는 Array와는 다르게 Object도 가능하다. ArrayList에 add를 사용하여 primitive한 데이터를 집어넣을때는 Auto-boxing이 사용된다. 또 제네릭이 사용 가능하다.</p>\n<p>하지만 가장 큰 차이점은 <strong>ArrayList는 Dynamic Array라는 것이다.</strong> ArrayList는 내부적으로 Array와 사이즈 정보를 가지고 있다.</p>\n<p>Array의 초기 사이즈가 고정되어 있고 늘어나지 않는것에 비해서, ArrayList는 add를 이용해서 원소를 삽입하다가 원소가 가득차게 되면, 내부적인 Array의 크기를 두배 혹은 1.5배 정도로 늘여서 기존의 원소들을 다 옮기게 된다.</p>\n<p>이 과정에서의 시간 복잡도를 고민해보면, 기존 원소의 개수가 0개이고 사이즈가 <code class=\"language-text\">n</code>개라고 해보자.\n이때 <code class=\"language-text\">n</code>번의 add를 할때까지 내부 Array는 가득차지 않고 각각의 삽입연산의 시간복잡도는 <code class=\"language-text\">O(1)</code>이다.</p>\n<p>하지만 한번 더 add를 한다면 내부 Array를 두배로 늘리고 , 기존의 <code class=\"language-text\">n</code>개의 원소들을 모두 옮겨야 하니 <code class=\"language-text\">O(n)</code>의 시간이 소요된다.\n<code class=\"language-text\">n+1</code>번의 add에 걸리는 시간복잡도가 <code class=\"language-text\">O(1)*n+O(n)</code>이니, 평균적인 시간 복잡도는 <code class=\"language-text\">(O(1)*n+O(n))/(n+1)=O(1)</code>이 되는 것이다.</p>\n<p>이것을 분할 상환(Amortized Analysis)라고 한다.</p>\n<h2 id=\"linkedlist\" style=\"position:relative;\"><a href=\"#linkedlist\" aria-label=\"linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList</h2>\n<p>LinkedList는 불연속적인 데이터들의 집합이다. LinkedList는 Node라고 불리는 내부구조들의 chain으로 구성되어 있는데 구조는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\tNode<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이처럼 Node는 원소와 그 다음 Node를 가리키는 포인터로 구성된다. 각각의 원소들은 오직 자기 다음에 오는 Node의 정보만을 가리키고 있는 것이다.(Singly Linked List 기준). 물론 <code class=\"language-text\">next</code> 라는 포인터를 하나 더 유지하는 메모리 사용량도 무시할 순 없다.</p>\n<p>이것을 이용하여 삽입과 삭제를 <code class=\"language-text\">O(1)</code>만에 할 수 있다. 삽입을 할때는 단순히 <code class=\"language-text\">next</code> 만 교체하면 되고, 삭제 역시 마찬가지다.</p>\n<ul>\n<li>조회 : k번째 원소를 찾기 위해서는  <code class=\"language-text\">O(k)</code>만큼의 시간이 소요된다.</li>\n<li>삽입 : 동작 자체만으로는 <code class=\"language-text\">O(1)</code>이 걸리지만, 원하는 위치를 찾기 위해 LinkedList를 순회해야 하기 때문에 평균적으로 <code class=\"language-text\">O(n)</code>이 소요된다. 단, 맨 앞에 삽입하는 경우는 <code class=\"language-text\">O(1)</code>이 소요된다.</li>\n<li>삭제 : 삽입과 동일. 맨 앞 삭제는 <code class=\"language-text\">O(1)</code>, 맨 뒤 삭제는 <code class=\"language-text\">tail</code> 에 대한 정보가 있어도 <code class=\"language-text\">O(n)</code>이 걸리는데 그 이유는 마지막 원소를 가리키는 직전 원소를 찾기 위해 <code class=\"language-text\">O(n)</code>의 시간이 걸리기 때문이다.</li>\n</ul>\n<p>그럼에도 LinkedList가 중요한 이유는 Tree 구조를 이해할때 필수적이기 때문이다.</p>\n<h3 id=\"doubly-linked-list\" style=\"position:relative;\"><a href=\"#doubly-linked-list\" aria-label=\"doubly linked list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Doubly Linked List</h3>\n<p>앞서 살펴본 Linked List는 일반적으로 Singly Linked List를 지칭하는 말이다. Singly Linked List는 아래처럼 다음 원소를 가리키는 <code class=\"language-text\">next</code> 포인터 하나만을 가지고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\tNode<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이에 반해서 Doubly Linked List는 <code class=\"language-text\">next</code> 포인터와 그 직전 원소를 가리키는 <code class=\"language-text\">prev</code> 포인터 역시 가지고 있는 아래와 같은 구조를 띈다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\tNode<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n\tNode<span class=\"token operator\">*</span> prev<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또 일반 Singly Linked List와는 다르게 헤드 역시 Node로 이루어져 있다.</p>\n<ul>\n<li>\n<p>삽입 : new_node를 삽입하는 과정인데 살펴볼 필요가 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 465px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.222222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABgUlEQVQoz4WS/0sbQRDF7///SwqWqASvKBYFf4jWREETiTa2NWnOYBPvS27vdmf37lPuUuR6sXRgWGb3zePNm/UARAxP0ynL1aoqKcvyLdvRfHsvvZJNUxIlFNZtERRlSeEchdYURcH/wqv4VskrZ+NzepNLLr5dcT655Hh0RhRHGBHyJEHPA3KtEWN4jUL636/pPfZr/MXjgMPhKT9fAjy1TrmffWVn0OXT/Qn+wwl+r8PHqwN+LZeIteg0JV8s0GLQuebH/ImD3i7+8Aj/4ZT9m0M+XHeZLeZ4lUznHGIFYwURIVs8o1VWj1ARWqORMMQ6V2O1MaggQHS+6bFS39cjv2c8eY7Jsn/6ZLTGpQpantZLaW6uCqVU7RliidcRt9MRt7O7TU5H9CcDXJrilGJd4Vqb95rsza1WhLPJkP3+Ht3xMd3xZ/wbn86XDhLFVUONpfW9vLbk+vxTW2cJXp5RkhGrhDhLyEX/hWlbtqWwOX4UhgTzgExlW169KWsp/A3KKwBoS6V3QwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/9ec5b65f5a55161515d9d75b9fab7e31/9ff85/insert.png\"\n        srcset=\"/static/9ec5b65f5a55161515d9d75b9fab7e31/e9ff0/insert.png 180w,\n/static/9ec5b65f5a55161515d9d75b9fab7e31/f21e7/insert.png 360w,\n/static/9ec5b65f5a55161515d9d75b9fab7e31/9ff85/insert.png 465w\"\n        sizes=\"(max-width: 465px) 100vw, 465px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>new_node의 <code class=\"language-text\">prev</code>가 before을 가리키게 한다.</li>\n<li>new_node의 <code class=\"language-text\">next</code>가 before의 <code class=\"language-text\">next</code>를 가리키게 한다.</li>\n<li>before의 <code class=\"language-text\">next</code>의 <code class=\"language-text\">prev</code>가 new_node를 가리키게 한다.</li>\n<li>before의 <code class=\"language-text\">next</code>가 new_node를 가리키게 한다.</li>\n</ol>\n<p>이 과정에서 순서에 유의해야 하는데, 1번은 언제 일어나도 상관이 없다.\n하지만 2번,3번의 경우 4번보다 먼저 일어나야 하는데, 그렇지 않으면 before의 <code class=\"language-text\">next</code>가 가리키는 node를 접근 할 방법이 없어지기 때문이다. 또 당연히 첫 순서로 실행되어서는 안된다.</p>\n</li>\n<li>\n<p>삭제 : removed node를 삭제하려는 과정이다. removed의 이중 연결을 해제해주고, removed의 <code class=\"language-text\">next</code>와 <code class=\"language-text\">prev</code>를 서로 연결시켜준다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 541px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABa0lEQVQoz22Rb2/TMBDG8/2/CS/QJKatK7QrDE0MOtqmqhqgjEY04c3+FM1JY59j/1AcOrrSR3qsO/vu/NxdBOCcwxiD1jqwMhpTWwLqGlNVSKWDHeI96J34JteICW9RLZZJOuNo0qGTDDhLBrz6fMybURfE4axgqyrQWwEjpGnC6bTL6bxPZ37Oy9EJL4bHbFRJpDcVSfaNi8UV1/mUDz+u6Y37LPKvoAUvQqUUWhX4RoVYVtkN/VGP4Srm088J779/JM4TalsTsQfRhvXdQ7D90/EXvnWstdzf3nEIkfeehs0cG5j1GjWJsUq1ySKIMYgItbU479FZhponuLoO/21rNIzYudjaRaEoHhVxOuNk2uN8cUkvueBo3KEbv0X9fgyLYK9YUMizjv4VLYuS0c2Us9mAq2zM5XLI6y/viFcJzjr2hTy1fKjYFlYsD7f3reOez2o3btf+T2HLdht5/ovlMqUsNwfbO6TwD4qGsVHFw3W4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/3ff309f03e3a9cc570591c2c2562a1a0/9d576/remove.png\"\n        srcset=\"/static/3ff309f03e3a9cc570591c2c2562a1a0/e9ff0/remove.png 180w,\n/static/3ff309f03e3a9cc570591c2c2562a1a0/f21e7/remove.png 360w,\n/static/3ff309f03e3a9cc570591c2c2562a1a0/9d576/remove.png 541w\"\n        sizes=\"(max-width: 541px) 100vw, 541px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>removed의 prev가 removed의 <code class=\"language-text\">next</code>를 가리키게 한다.</li>\n<li>removed의 next가 removed의 <code class=\"language-text\">prev</code>를 가리키게 한다.</li>\n</ol>\n<p>두 연산은 순서를 바꿔도 상관이 없다.</p>\n</li>\n<li>\n<p>조회 : Doubly Linked List에는 <code class=\"language-text\">prev</code> 포인터가 있기 때문에, 최악의 경우 <code class=\"language-text\">O(n)</code>이 소모되었던 Singly Linked List와는 다르게 <code class=\"language-text\">O(n/2)</code>의 시간 안에 찾을 수 있다. 찾으려는 원소의 인덱스의 범위에 따라 <code class=\"language-text\">end</code>에서 <code class=\"language-text\">prev</code> 포인터를 이용해서 돌아가거나, <code class=\"language-text\">head</code>에서 <code class=\"language-text\">next</code> 포인터를 이용해 찾는 방법이다. 또, 직전 원소를 찾는 before도 쉽게 구현 할 수 있다.</p>\n</li>\n</ul>\n<p>이런 장점을 이용해서 연속적인 탐색과 접근에 유리하지만 , 구현이 상대적으로 복잡하고 <code class=\"language-text\">prev</code> 포인터를 유지해야 하기 때문에 메모리 사용량이 2배 정도 증가한다.</p>\n<p>하지만 사용성때문에 플레이리스트, 되돌리기와 같은 기능에 사용되는 자료구조다.</p>\n<h2 id=\"array-vs-linkedlist\" style=\"position:relative;\"><a href=\"#array-vs-linkedlist\" aria-label=\"array vs linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array vs LinkedList</h2>\n<p>일반론적인 얘기에서 조회는 <strong>Random Access</strong>를 지원하는 Array가 <code class=\"language-text\">O(1)</code>의 시간복잡도를 가지고 있어서 LinkedList보다는 빠르다.</p>\n<p>삽입과 삭제는 모두 LinkedList가 빠르다고 하지만 이유에 대해서 조금 더 면밀하게 살펴볼 필요가 있다.</p>\n<p><em>빠르다</em> 라고 하는 것은 삽입과 삭제 그 자체에 주목하는 부분이다.\n만약 바꿔야 할(삽입 혹은 삭제) 위치를 정확히 아는 상태에서는 Array보다 LinkedList가 항상 빠르다. 단순히 <code class=\"language-text\">next</code> 포인터만 변경해주면 되기 때문이다.</p>\n<p>평균적인 경우에서는 Linkedlist는 <code class=\"language-text\">O(n/2)</code>개의 원소들을 살펴보아야 하고, Array도 동일한 원소의 개수들을 shift 해줘야하니 비슷하다.</p>\n<p>그렇기 때문에 Usage에 따라 두 자료구조를 적절히 아래와 같이 선택해야 한다.</p>\n<ul>\n<li>삽입과 삭제가 빈번하게 일어나는 경우 →  <strong>LinkedList</strong></li>\n<li>데이터에 대한 접근(Access)가 빈번하게 일어나는 경우 → <strong>Array</strong></li>\n</ul>\n<h3 id=\"cache\" style=\"position:relative;\"><a href=\"#cache\" aria-label=\"cache permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cache</h3>\n<p>또 한가지 더 깊게 생각해보자면, <strong>캐싱</strong>과 연관이 있다. 정확히 말하면 <strong>Spatial Locality.</strong></p>\n<p>CPU가 일을 처리할때는 메모리에서 필요한 데이터를 로드하고, 일부를 캐싱한다. 그 캐시 안에 들어있는 요소들을 레지스터로 가져와서 일을 처리하는데, 이 과정에서 차이가 발생한다.</p>\n<p>LinkedList는 데이터들의 주솟값들이 서로 연속적이지 않기 때문에, loop를 돌때 (Iterator든 뭐든) 매번 다음 메모리 주소를 찾아야 하고 , CPU가 메모리에 계속적으로 접근해서 로드하는 과정이 생길 수 있다.</p>\n<p><strong>불필요한 오버헤드가 생기는 것이다.</strong></p>\n<p>반대로 배열은 연결된 데이터 구조를 가지기 때문에, 특정 영역에 존재하는 데이터들을 한번에 로드해와서 bulk들을 캐싱한다.\n그렇기에 loop를 돌때도 Array가 매우 크지 않으면 이미 캐시되어 있는 리소스들을 사용할 수 있게 되고 LinkedList와 비교했을 때 상대적으로 적은 메모리 접근이 일어나니 더 빠르다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#array\">Array</a></p>\n</li>\n<li>\n<p><a href=\"#arraylist\">ArrayList</a></p>\n</li>\n<li>\n<p><a href=\"#linkedlist\">LinkedList</a></p>\n<ul>\n<li><a href=\"#doubly-linked-list\">Doubly Linked List</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#array-vs-linkedlist\">Array vs LinkedList</a></p>\n<ul>\n<li><a href=\"#cache\">Cache</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 24, 2022","title":"Array와 Linked List","categories":"자료구조","author":"weasel","emoji":"📓"},"fields":{"slug":"/array-and-linked-list/"}},"prev":{"id":"8dc426c1-6ea9-5b2f-9546-c7694d04fcb3","html":"<h2 id=\"tcp\" style=\"position:relative;\"><a href=\"#tcp\" aria-label=\"tcp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP</h2>\n<p><strong>신뢰성 있는 데이터 전송</strong>을 지원하는 <strong>연결 지향형 전송계층</strong> 프로토콜로 <strong>3 way handshake로 연결을 수립</strong>하고 , <strong>4 way handshake로 연결을 해제</strong>한다.</p>\n<ul>\n<li>\n<p><strong>혼잡 제어, 흐름 제어, 오류 제어</strong>등을 통해 <strong>신뢰성을 보장</strong>하지만 이것때문에 UDP와 비교해서 속도가 느리다.</p>\n</li>\n<li>\n<p>또 <strong>SEQ 넘버</strong>와 <strong>ACK 넘버</strong>를 통해서 데이터 흐름 속에서 <strong>데이터들의 순서를 파악</strong>할 수 있기 때문에 신뢰성이 높아진다.</p>\n</li>\n<li>\n<p>인터넷은 신뢰성을 갖추지 못하기 때문에 <strong>종단간의 신뢰성 있는 Byte Stream</strong>을 전송하도록 설계되었다.</p>\n</li>\n<li>\n<p>연결을 유지하며 <strong>1:1 통신</strong>을 한다. 그렇기에 브로드캐스팅과 같은 시스템에선 적합하지 않다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 513px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACHElEQVQoz12SiY6jMAyGef8HW61GI/Wm3Dc0QGkLtJ2WQr9dZ6azR5DlYMW/P8cxAM7nC8fjidOp5XYfJETX9ZRVTZpmNM1Bx57AND15jJM2HXs+dfy1DPkN4pStZWPZDn6UkBQ74jTDCyOCOCHOCm1BkpKrkrysCfNSi32Lfu0N2WRZhrlZs1zMWZtbVmuTHz/ftBfS46EhjkJcx6YqFV3bUlcV0zT9IyifFnyMI7nas3Iz3KJj4Sne1iHroMaKG7L6QtMPXO9PhvHJ+CX0v6Am3O8bnDBlvg1ZuylzM8D0M5xIYYUFSytiZgbftrQj3CgjyXckacZtGL7vT0SNuq51y7ZtEYUhQeDjeS6u65BlKUrtsC1Lx3zfI4pCoiiiKArSvKC7XLler7Rt+0lYVZX+OZ/P9H1P23aEYchms8F1Xe1t28bzPMqyou06uq6j7zvyvODycWOxmGNZ1qvlvT5wOBw4nU44jsNsNmM+n7NYLEjTVHeQJIn2n2K9BtgpxantKEul84dhwIjjWCcLiYitViuWyyXv7++66uPx4H6/s9vtaJpGm3Q1jqOmNS1b55mmqQsaSinEgiDA930tJoTS4na71dchJoQv2jzP9dNRZUWhKo7HI9KpdGhIxdvtpoNyWIYkCUIh+7Is9RCEVihlGAIgdyiCH/cHfy9DepdE8SIqJkki8KKWoYioELzOCIgUe07Tn4f9+9n8Apapf/QQHrtLAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP Header\"\n        title=\"TCP Header\"\n        src=\"/static/953498754a2a0c8bd1a6bf477a853ae6/267f6/1.png\"\n        srcset=\"/static/953498754a2a0c8bd1a6bf477a853ae6/e9ff0/1.png 180w,\n/static/953498754a2a0c8bd1a6bf477a853ae6/f21e7/1.png 360w,\n/static/953498754a2a0c8bd1a6bf477a853ae6/267f6/1.png 513w\"\n        sizes=\"(max-width: 513px) 100vw, 513px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>TCP Header</p>\n</li>\n</ul>\n<h3 id=\"tcp-연결-과정\" style=\"position:relative;\"><a href=\"#tcp-%EC%97%B0%EA%B2%B0-%EA%B3%BC%EC%A0%95\" aria-label=\"tcp 연결 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 연결 과정</h3>\n<p>TCP는 통신을 시작하기전에 연결 수립이 필수적이다. 이것을 통해서 상대방과의 세션을 수립하여 통신의 정확성을 획득할 수 있다.</p>\n<p>클라이언트는 서버에 접속을 요청하고 서버는 요청을 수락하는 ack와 flag가 설정된 패킷을 클라이언트에게 발송한다.</p>\n<ol>\n<li>클라이언트가 서버에 접속을 요청하는 SYN(a)이 설정된 패킷을 보낸다. 이때 클라이언트는 <code class=\"language-text\">SYN_SENT</code></li>\n<li>서버가 클라이언트의 요청인 SYN(a)를 받고 클라이언트에게 요청을 수락한다는 ACK(a+1)과 SYN(b)이 설정된 패킷을 보낸다. 서버는 <code class=\"language-text\">SYN_RCVD</code> 상태</li>\n<li>클라이언트는 서버의 수락 요청에 대한 응답인 ACK(a+1)과 SYN(b) 패킷을 받고, ACK(b+1)을 서버로 보내면 연결이 성립된다. 클라이언트는 <code class=\"language-text\">ESTABLISHED</code> 상태가 되고, 서버는 ACK을 받으면 <code class=\"language-text\">ESTABLISHED</code> 상태가 된다.</li>\n</ol>\n<p>이 과정에서 SYN이나 ACK가 dropped 된다면, 재전송(retransmission)이 일어난다. 만약 3번 과정에 ACK가 drop된다면 그 다음에 데이터를 보낼때 ACK도 같이 담아서 보내면서(piggy-backing) 연결을 수립한다.</p>\n<h3 id=\"2-way-handshake으로-부족한가\" style=\"position:relative;\"><a href=\"#2-way-handshake%EC%9C%BC%EB%A1%9C-%EB%B6%80%EC%A1%B1%ED%95%9C%EA%B0%80\" aria-label=\"2 way handshake으로 부족한가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2 way handshake으로 부족한가?</h3>\n<p>부족하다. TCP는 양방향성 connection이기 때문에, 양쪽의 통신 수립이 필수적이다. 클라이언트와 서버가 있다고 했을때, 클라이언트가 서버에게 SYN을 보내고, 서버가 ACK와 SYN만 보낸다고 하면, 서버 입장에선 제대로 연결되었는지 확인이 불가능하다. 서버의 ACK와 SYN에 대한 클라이언트의 응답인 ACK가 필요하니 3 way handshaking을 해야한다.</p>\n<blockquote>\n<p>💡 초기에 클라이언트에서 보내는 SYN 넘버는 ISN이라는 난수를 생성한다. 그 이유는 이전의 seq와 순차적인 정보를 전송하면, 서버가 판단하기에 이전 연결에서 보내는 정보라고 인식 할 수 있기 때문이다.</p>\n</blockquote>\n<blockquote>\n<p>💡 SYN flooding attack 이라는 공격이 있는데, 간단히 서버에 대해서 SYN 패킷만 무수히 보내는 것을 의미한다. 이것이 왜 유용하냐면, SYN 패킷을 보내면, 서버는 연결을 수립하는 과정이라고 생각해서 SYN/ACK 패킷을 보내고 ACK를 기다리는 half-open 상태에 돌입한다. 이 상태에서 서버는 클라이언트에 대한 정보를 가지고 있어야 하기때문에, 접속자(혹은 접속을 시도하려는) 사람의 정보를 저장하는 Backlog Queue가 꽉 차게 되고(정상적으로 연결이 수립되면 삭제하지만 그렇지 않으니) Backlog Queue가 꽉 차게 되어서 다른 연결 요청 정보 저장이 불가능해서 정상 Client들이 연결을 수립할 수 없게 된다.</p>\n</blockquote>\n<blockquote>\n<p>해결 방법으로는 Backlog Queue를 늘리는 것이 있지만 임시적인 해결책이다. 또 한가지 방법 중 하나는 방화벽에서 동일 클라이언트 IP에 대한 SYN 임계치를 설정해두는 방법이다.</p>\n</blockquote>\n<h3 id=\"tcp-연결-해제-과정\" style=\"position:relative;\"><a href=\"#tcp-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C-%EA%B3%BC%EC%A0%95\" aria-label=\"tcp 연결 해제 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 연결 해제 과정</h3>\n<p>4 way handshake를 통해 TCP는 연결을 해제한다.</p>\n<ol>\n<li>클라이언트가 서버에게 연결을 종료하겠다는 FIN 패킷을 보낸다.</li>\n<li>서버는 클라이언트의 요청에 대한 응답으로 ACK 패킷을 보낸다.</li>\n<li>서버는 자신의 통신이 끝날때까지 기다린다 . <code class=\"language-text\">CLOSE_WAIT</code> 단계다. → Socket Hang UP 에러 발생가능</li>\n<li>처리해야할 통신이 모두 끝났다면 FIN 패킷을 보낸다.</li>\n<li>클라이언트가 FIN에 대한 응답으로 ACK 패킷을 보낸다.</li>\n<li>클라이언트의 ACK 패킷을 받은 서버는 소켓을 닫는다.</li>\n<li>클라이언트가 서버로부터 앚기 받지 않은 데이터가 있을 수 있으니 기다리는 과정을 거친다. <code class=\"language-text\">TIME_WAIT</code> 단계다.</li>\n</ol>\n<blockquote>\n<p>💡 [에러 발생]\n클라이언트에서 FIN 패킷 전송 후 ACK 패킷을 기다리는 FIN_WAIT1과 서버의 ACK 패킷을 받은 후 FIN 패킷을 기다리는 FIN_WAIT2 에러 발생으로 인해 Time out이 되면 스스로 연결을 종료한다.\n그러나, CLOSE_WAIT은 Application이 close()를 적절하게 처리하지 못하면 CLOSE_WAIT 상태로 계속 기다리게 되어 Socket Hang Up 에러가 발생할 수 있다.</p>\n</blockquote>\n<h3 id=\"tcp-상태-다이어그램\" style=\"position:relative;\"><a href=\"#tcp-%EC%83%81%ED%83%9C-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8\" aria-label=\"tcp 상태 다이어그램 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 상태 다이어그램</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 101.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAACJElEQVQ4y22UVw4CMQxEc/97UD7gENyAPxAICZbe29KL0bM0yJRIUbKJPTMum2Rf4/l8vvf3+922260Nh0Pr9Xp2PB5ttVpZnud2u938nnm5XOx8PrtPikACw2Gz2dh6vbbD4eBnrIvFwp0ZrBA8Hg//Zg/JX0CcUQYoE3aMtRfpdDq10+n0joZ9ElCcGoAA3O12rd/vO5EAUYbKH0D7MxQGBrvdziaTiecRcAHKTt/KZUKFAAgDJePx2MNhkhsN9oPBwNrttoPjqxxfr1ebz+eWuJjNZg6y3+9tuVx6RTGEYDQaWafT8TMm9yjBh6JRKCLgnGjegITEQTRiogoAFOCEQkjIKxFwxko7feSQHMSBOhRjCCiAkEKICICw+e5hrzI5xAhjAGJOyVer1bJms2mNRuMjp7HdNJMOUUOfAajWAZgwqCQKyavuYnvFkdQ/qNMgZ1SMQqFczuSWsLmDjCpDpOltgwPJp10UMknHmT1OkYgoKB73FIMi4cvKXSJUgFQxVVXsqMGY9TtMUkEa8EcEwB4yzgDiFBURFoYoIi1M3QMuYtpO/j8hwxhfEMDoOZqbaFRlhNAF+BKBejYRtxobBr11KJB6FS2Sca83ESIAvSixn3DIssyrq39USlCB2vgi6R1Qgch5igbxSQKEIsEOAXtI+OafJgV6zlAHGf7pX6NqTwoqlYoVCgUrlUpWrVZdCcogrtfrVi6XfRaLRavVavYCDkkC0QwH7JEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/14d915aaafcbca805f0c03c7697ec75e/c5bb3/10.png\"\n        srcset=\"/static/14d915aaafcbca805f0c03c7697ec75e/e9ff0/10.png 180w,\n/static/14d915aaafcbca805f0c03c7697ec75e/f21e7/10.png 360w,\n/static/14d915aaafcbca805f0c03c7697ec75e/c5bb3/10.png 680w\"\n        sizes=\"(max-width: 680px) 100vw, 680px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>CLOSED, LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSING, CLOSE-WAIT, LAST-ACK 등 상태가 존재한다.</li>\n<li>CLOSED : 연결이 존재하지 않을 때</li>\n<li>LISTEN : 서버에서 SYN이 오는 것을 기다리는 상태.</li>\n<li>SYN-SENT: SYN을 보내고 ACK을 기다리는 상태(클라이언트)</li>\n<li>SYN-RCVD: SYN을 받고 SYN+ACK을 보낸상태(서버)</li>\n<li>ESTABLISHED: ACK을 받게 되면 서버 클라이언트 각각 이 상태로 들어섬</li>\n<li>FIN-WAIT-1: FIN을 클라이언트 쪽에서 보냈을 떄 ACK을 기다리는 상태</li>\n<li>FIN-WAIT-2: 첫번째 FIN에 대한 ACK을 받고 다음 FIN이 날라 올 때까지 기다리는 상태</li>\n<li>CLOSE-WAIT: 첫번째 FIN을 받고 ACK을 보낸 뒤 보낼 데이터들을 보내고 ACK을 받는 상태</li>\n<li>LAST-ACK: 전송이 완료되고 서버쪽에서는 FIN을 보내고 ACK을 기다리는 상태</li>\n<li>TIME-WAIT: FIN이 오고 ACK을 보내준 뒤 일정 시간동안 기다림</li>\n<li>CLOSING: 클라이언트 쪽은 TIME-WAIT이 종료 된 후, 서버쪽은 ACK이 도착한 후 종료된 상태를 의미한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABMUlEQVQoz3WRXU+lMBRF+f9/z4zOg6LOABdooV9QoLRdpvca44y6k52+9Oycs3ZljKauX5ilJntPdAvJe9Q0EY4DUqIoxIhzjs/KOf/zFlVt2/D4WCOEhpxI50k+T6wQBGOI1hKVwg8jo5xYlgU5jsQQPsI+uwohsK4r1liIkXQc5G2je37BTxPJOaKUrL3k4fcTD/f3iKEE7nynahwG/jQtshs4m4ZT6+tWqmk4tL6eX1Ac245S6oYB8GbCyZ7l3U50mP4vVeEiZ8Xcj8RyinXkfUeNgvN9+MYw0zQdl67DGEvwDicuOHm5BhevSlJJKWnbjmnW18HCsGy1SEmwlrQsJGvx/YDWhpQSx779fLIQI3d3v5hne4P834dcWo6RY914ql+p65p98+QUvxRSSnkDnUYcwMJ/QLQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/7b08b665fced5355c0a253de440d426a/37523/2.png\"\n        srcset=\"/static/7b08b665fced5355c0a253de440d426a/e9ff0/2.png 180w,\n/static/7b08b665fced5355c0a253de440d426a/f21e7/2.png 360w,\n/static/7b08b665fced5355c0a253de440d426a/37523/2.png 720w,\n/static/7b08b665fced5355c0a253de440d426a/302a4/2.png 1080w,\n/static/7b08b665fced5355c0a253de440d426a/229ad/2.png 1356w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"tcp의-신뢰성을-위한-방법들\" style=\"position:relative;\"><a href=\"#tcp%EC%9D%98-%EC%8B%A0%EB%A2%B0%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95%EB%93%A4\" aria-label=\"tcp의 신뢰성을 위한 방법들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP의 신뢰성을 위한 방법들</h2>\n<h3 id=\"흐름-제어\" style=\"position:relative;\"><a href=\"#%ED%9D%90%EB%A6%84-%EC%A0%9C%EC%96%B4\" aria-label=\"흐름 제어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>흐름 제어</h3>\n<p><strong>송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법이다.</strong></p>\n<p>수신측이 너무 지나치게 많은 패킷을 받지 않도록 조절하는것이 목적이고, 기본적인 개념은 수신측이 송신측에게 자신의 상태를 피드백한다는 것이다.</p>\n<ul>\n<li>\n<p>수신측이 송신측보다 데이터 속도가 빠르면 문제 없지만, 느릴때 문제가 생김.</p>\n</li>\n<li>\n<p>수신측의 제한된 저장용량를 초과한 이후,즉 버퍼 오버 플로우 후에 도착하는 데이터는 손실될 가능성이 있으며, 손실되면 불필요한 응답과 데이터 전송이 빈번하게 오고감.</p>\n</li>\n<li>\n<p>이를 해결하기 위해서 송신 측의 데이터 전송량을 수신측에 따라서 조절해야한다.</p>\n</li>\n<li>\n<p>해결 방법</p>\n<ul>\n<li><strong>Stop and Wait</strong> : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법. 그렇기에 비효율적이다.\n<ul>\n<li>Timeout을 설정하고, 그 Timeout 안에 ACK를 받지 못하면 실패한것으로 간주, 같은 프레임을 재전송한다.</li>\n<li>만약 이 Timeout이 너무 짧으면, ACK와 상관없이 계속 다시 보낼것이다.</li>\n</ul>\n</li>\n<li><strong>Sliding Window</strong> : Stop and wait의 비효율성을 개선한 기법으로, 수신측에서 설정한 window 크기 만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게하는 방식이다.  (윈도우 크기 = 가장 최근 ACK로 응답한 프레임 수 - 이전에 ACK 프레임을 보낸 프레임 수)\n<ul>\n<li>\n<p>3 way handshaking을 할 때 송신측이 수신측의 window size에 맞게 자신의 window size를 조절한다. TCP 헤더안에 있으니..</p>\n</li>\n<li>\n<p>수신측에서 설정한 윈도우 크기만큼의 세그먼트를 확인 응답없이 보낼 수 있게 하여 동적으로 흐름을 제어하는 방식.</p>\n</li>\n<li>\n<p>송신측이 ACK 를 수신하지 않았더라도 여러개의 패킷들을 보낼 수 있다. (window size만큼 한번에 보내는방식)</p>\n</li>\n<li>\n<p>0,1,2,3,4,5,6가 윈도우 사이즈에 맞을때, 0,1을 보내면 윈도우는 2,3,4,5,6 으로 변한다.</p>\n</li>\n<li>\n<p>ACK를 받게 된다면, 0,1이 정상적으로 수신되었음을 알게되고 윈도우는 옆으로 두칸 이동해(slide) 2,3,4,5,6,7,8로 변한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACkUlEQVQoz4WQ22sTCRSH5y+1CGq9LGotLagPrs+7srAVFi9tbdKmKKu1mUw0tMlOJzGXSeaeuSepaSYsug+rlsLulsy3OC7I7st+cOBwzseB8xPSNCWdpXxGURRkWc7609NTZrOUbP+f4ouOJElomvbVT1ME/mEGXL9zl+Vv75LOZvwfn05OmLu2wPcr9/81F9zxiIJWZ1tTWKmVEJt1/GjAYHzEaDzmw4ffOTk+5vjjR/7640/afp+C3mCrK7NSFal0WgTxkOjtmPFkgtCxLb558Zi53QecKT5ktfYKVTNRuj1UTSeIQhLb5q2uM00SSorMxZ3HnC0+Ym73IYWDfdpdnYNOF820EJLpr/zckFmU8lwt5diq17D8ECOI6PsBQRQRhxG+63E0neL5IYV6lRtSnmviBi9adUwvQPMC/HiAcDieUGo3WSjnuVzOMS+ukVP26fsxRt8limMGrkdgWUymCbbjstNucLWcy/zL4jrPGjK2F+L4AYIbhiitDnekAhdK65wrrvLd6+d0NANV13F9H81yaPX0LKNOT0NutblZ2sz888VVfqy8pN0zvrwcDIaouslPe0Xmi2tcKT1hSczT0A1M2yGMY4aeR2TbJEmCqhuohsUPlR0u7K5m/i1xi6ZuYrsewvBoguH5NE2T25VnXCxvsChton/OJIyJh0N+8zzeOU52UHdcnCDiQNdYerXNpfIGN6VClns4GCLEo0PahonT99hu1JiX1lmQcuxpXXq2TRhFHHoesWUzSRJ6poVq2Zm/dlDhvLTGsrRJtdfDcF0Ey/PZb7yh3urwUv6FRTHHUinPvWqR50qV0WBIf3SIHoS8e/+eRkel1mzxpq3ytLrHgrjBspjn3t4uYlPhb9dw4YUey658AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/a7fa182ff65a69990bb3a15d30f0c098/37523/3.png\"\n        srcset=\"/static/a7fa182ff65a69990bb3a15d30f0c098/e9ff0/3.png 180w,\n/static/a7fa182ff65a69990bb3a15d30f0c098/f21e7/3.png 360w,\n/static/a7fa182ff65a69990bb3a15d30f0c098/37523/3.png 720w,\n/static/a7fa182ff65a69990bb3a15d30f0c098/a0209/3.png 725w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"혼잡-제어\" style=\"position:relative;\"><a href=\"#%ED%98%BC%EC%9E%A1-%EC%A0%9C%EC%96%B4\" aria-label=\"혼잡 제어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>혼잡 제어</h3>\n<p>송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법.</p>\n<ul>\n<li>\n<p>송신측이 네트워크를 통해서 데이터를 전달할때, 라우터가 만약 <strong>데이터가 너무 몰려서(혼잡할때) 모든 데이터를 처리할 수 없게 되고</strong>,</p>\n</li>\n<li>\n<p>송신 측은 다시 데이터를 보내고, 혼잡을 가중시켜서 <strong>오버플로우나 데이터 손실</strong>을 일으키게 된다.</p>\n</li>\n<li>\n<p>그 과정에서 혼잡을 피하기 위해서 <strong>강제로 송신측의 데이터 전송속도를 줄이는데</strong>, 이것을 혼잡제어라 한다.</p>\n</li>\n<li>\n<p>해결방법</p>\n<ul>\n<li><strong>AIMD (Additive Increase / Multiplicative Decrease)</strong>\n<ul>\n<li>\n<p>처음에는 패킷을 하나씩 보내고, <strong>문제없이 도착하면 window size를 1씩 증가</strong>시켜가며(additive increase) 전송하는 방법</p>\n</li>\n<li>\n<p>만약 <strong>패킷 전송에 실패하거나 일정 시간(timeout)을 넘으면, window size를 절반으로 감소</strong>시킨다.</p>\n</li>\n<li>\n<p>이 방식은 fair 한데, 여러 개의 호스트가 네트워크름 공유할때, 처음 보내는 쪽이 1부터 보내기에 불리하지만 나중에는 평형한 상태를 맞추기 때문.</p>\n</li>\n<li>\n<p>하지만 초기에 1씩 보내기때문에 <strong>높은 대역폭을 충분히 사용하지 못하고</strong> , 혼잡상황을 <strong>미리 감지 못해 혼잡이 일어나야지만 대역폭을 줄이는 방식</strong>.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 571px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABS0lEQVQoz4VSa2/DIAzM//+HzYc066Q90oeSAMG8fJOBZmnaaUiWrcOcz8YNjyMQI7xSsNMEeA8mWg3/xOJhLcAMHA5oEAImrXG5XuG8hxyu9lfMe5xr1PdogigjglYKzrlNAme/t0yziTOeUnnXdWje2xbkPaK07WjVYgLj5hKwU3F1CTaW2KWqLKWi9nhEM5xOGM5nfA8DBlMU6sCYfSFVgbFUAsGEMKSCn6kUtKEqFMKPrkOq1QdloaM8LAkXSviyKRPOgUGRsyrBdS02eYaLG8JT2+I2jtDThE9FmALWccsDaU+UUFUpXvBc0FWcNy1/dkfMSkHNMwz9fsp9ZuJ94ofPesrZzlB+ucw1wREBuzV5dZ7wO7EQ5qUEEEKA1jqvDhE9mLUWxpgnfL03BkuMZQ95WUpF5qxyb9KWEL71fS7Gr/JCQKwt/wBHqV6ZrwSuSAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/181e79cc6fd911904f2e6f2182b505dc/17d73/4.png\"\n        srcset=\"/static/181e79cc6fd911904f2e6f2182b505dc/e9ff0/4.png 180w,\n/static/181e79cc6fd911904f2e6f2182b505dc/f21e7/4.png 360w,\n/static/181e79cc6fd911904f2e6f2182b505dc/17d73/4.png 571w\"\n        sizes=\"(max-width: 571px) 100vw, 571px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ul>\n</li>\n<li><strong>Slow Start</strong>\n<ul>\n<li>\n<p>AIMD 방식이 전송 속도를 올리는데 있어서 오래걸리는 단점(1씩 증가하기 때문에)이 있기에 이것을 개선하는 방식.</p>\n</li>\n<li>\n<p>AIMD와 마찬가지로 1개의 패킷을 보내면서 시작하지만, <strong>문제없이 도착하면 window size를 2배로 늘려준다.</strong></p>\n</li>\n<li>\n<p>혼잡현상이 발생하면, window size를 1로 떨어트림.</p>\n</li>\n<li>\n<p>처음에는 네트워크에서 혼잡을 유발하는 window size를 알 수 없지만, 한번 혼잡현상이 발생하면 <strong>최대 수용량에 대한 유추</strong>가 가능해지기에, 그 window size의 <strong>절반까지는 이전처럼 2배</strong>로 증가하되, <strong>그 이후부터는 완만하게 1씩 증가시키는 방식</strong>을 택함.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABOUlEQVQ4y32T3a6CMBCE+/7PRngAbpALEiQq8iMoIHvyNRmznKBNNgzTdnZ32gYzs2maLMsyO51O1nUdlG3bZt/Gr7nwfr9tGAa73+/W931cDOcDzvO/RKPg+Xy2y+Vi8zzbuq62LMsuXq+XjeMYE/OVoEQ9DgAEy7KMi0ngxeAQJBEDTgJeSMIB8Hw+Y7ts9BkJeD8QPPJUVgQyqyoJyjfmaNP7xxrvLTZRkDoIVJDnudV1HTd7Dx+PRwxvATfCz/uKPy2rFWXxlYjT0D+VSWx3KCIwnzvIl9CJg48O6ZuXQcoI0AJ+gNkElrgq4p+2NU8If66NBPGQxQgLX69Xu91usXqwv/xqv21bq6pqL6hT48UURREPCgwHTpLE0jSNif6/FIQpaOeh94EFhHjapLqmaXZP7+hi/wGkevyCQ2w6eQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/b5a0f766ca5141b8507f01d57bef6c5a/37523/5.png\"\n        srcset=\"/static/b5a0f766ca5141b8507f01d57bef6c5a/e9ff0/5.png 180w,\n/static/b5a0f766ca5141b8507f01d57bef6c5a/f21e7/5.png 360w,\n/static/b5a0f766ca5141b8507f01d57bef6c5a/37523/5.png 720w,\n/static/b5a0f766ca5141b8507f01d57bef6c5a/84cc5/5.png 898w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>임계값(ssthresh)단계에서 부터는 <strong>혼잡회피</strong>(Congestion Avoidance)를 사용한다.</p>\n</li>\n</ul>\n</li>\n<li><strong>혼잡 회피 (Congestion Avoidance)</strong>\n<ul>\n<li>window size가 임계값에 도달한 이후부터는 조만간 혼잡이 발생해 데이터 손실 발생 확률이 커지기 때문에 조심스럽게 접근한다.</li>\n<li>window size를 linear하게 1씩 증가시키는 방법을 사용.</li>\n<li>만약 혼잡이 발생했을 경우에, window size를 1로 줄이고, 임계값을 손실 발생했을때의 window size(W)의 절반인 W/2로 줄임.</li>\n</ul>\n</li>\n<li><strong>Fast Retransmit (빠른 재전송)</strong>\n<ul>\n<li>수신측은 순서대로 잘 도착한 마지막 패킷의 다음 번호를 ACK로 보내기 때문에, <strong>중간에 손실이 있을시에는 중복된 ACK</strong>를 받게 된다.</li>\n<li>이것을 감지하면, 문제가 되는 순번의 패킷을(<strong>SR</strong>) 재전송 해줄수 있다.(혹은 문제 지점부터 싹 다시보내거나,<strong>GBN</strong>)</li>\n<li><strong>3 ACK Duplicated</strong>, 즉 송신 측이 <strong>3번 이상 중복</strong>된 승인 번호를 받으면 혼잡이라고 인식한다.</li>\n<li>이때는 <strong>설정된 타임아웃이 지나지 않아도</strong> 해당 패킷을 재전송할 수 있다. (GBN or SR)</li>\n<li>이 방법으로 설정한 타임아웃 시간이 지나서야 대처하는 <strong>기존의 방법보다 낭비되는 시간을 줄일 수 있다.</strong></li>\n</ul>\n</li>\n<li><strong>Fast Recovery</strong> (빠른 회복)\n<ul>\n<li>TCP Tahoe : 초기 버전으로 타임아웃이 되거나 3 dup ack가 발생시 W를 1로 줄이고 slow start로 들어간다.</li>\n<li>TCP Reno : 개선 버전이다. Tahoe가 무조건 W를 1로 줄이기에 대역폭을 온전히 사용 못할 수 있다. 그렇기에 <strong>3 Dup ACK는 조금 덜한 혼잡이라고 본다.</strong>\n<ul>\n<li>3 Dup ACK : 현재 W의 절반으로 W를 줄이고, 1씩 linear하게 증가시킨다. 이때 임계점을 현재 W의 절반으로 설정한다.</li>\n<li>Timeout : Tahoe와 마찬가지로 W를 1로 줄이고 slow start 한다. 임계점을 수정하지 않는다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"오류-제어\" style=\"position:relative;\"><a href=\"#%EC%98%A4%EB%A5%98-%EC%A0%9C%EC%96%B4\" aria-label=\"오류 제어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>오류 제어</h3>\n<p>기본적으로 TCP는 ARQ(Automatic Repeat Request), <strong>재전송 기반 오류제어</strong>를 사용한다. 뭔가 오류가 생기면, 송신측이 수신측에게 해당 데이터를 다시 전송하는 방법이다.</p>\n<p>그렇지만 이 재전송이라는 작업 자체가 했던 일을 다시 해야하는 비효율적인 방법이기 때문에, 이 재전송 과정을 최대한 줄일 수 있는 방법을 사용한다.</p>\n<p><strong>오류가 발생했다는것은 어떻게 알까?</strong></p>\n<ul>\n<li>NACK(부정 응답) : 더 명확해보이지만, 수신측에서 ACK/NACK를 선택하는 추가적인 과정이 필요하다.</li>\n<li>ACK가 오지 않음 : 수신측이 아예 데이터를 받지 못해 ACK를 못 보내거나, 수신 측이 제대로 응답했지만 ACK가 유실(lose)되는 경우</li>\n<li>중복된 ACK\n<ul>\n<li>\n<p>송신측이 SEQ 2를 가지는 데이터를 이미 보냈는데도, 수신 측에서 이번엔 2번을 보내달라고 하면 문제가 생겼음을 알 수 있다.</p>\n</li>\n<li>\n<p>중복된 ACK 한 두번으로는 판단하지 않고, 3번 정도 받았을때 오류로 판단. 그 이유는 TCP가 중복된 ACK를 받앗을때 패킷 로스인지, 세그먼트들의 순서가 reordering 되는건지 명확히 알 수 없기 때문에 3번까지 보는것. 순서가 뒤집히는 이유는 TCP 아래 계층에서 라우팅 하는 단계에서 다른 경로를 택할수도 있기 때문.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEElEQVQoz32Sy03EUAxFj/Py/xANhP8CFkhIg1iwASqgByqgFjqhCZZUQStIIMeOEp4mY+lKdmJf+9oPZjsFnoCedTsDHoHr6YPEGTnQADVIgJMAVQZBotxF0MkiFvbbAFTKX1qfAigFgtYmllOsNDL7An4N8gbDK5R348DkiZFWLkJRAle6FmXNdhG+O+knyAsMH9D+QP0NB1qTQiXQutRD4EZ3KfPEe6Vr905xD0c6pUAhkCa218wP08ckEjuF+Zcbmypzsma+2Sg9cbJE7H/upZNvhItOrRfFMlKxwm4h+VyBQeOL8WUI9GKJG+DYuytBtkCo/Qh+9XiQf/4WeACegVsnk+kd7ihuuhVCHfUPpiwPGu3xgg8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/1ae8dfe469955be626d9d833c383aa80/6af66/6.png\"\n        srcset=\"/static/1ae8dfe469955be626d9d833c383aa80/e9ff0/6.png 180w,\n/static/1ae8dfe469955be626d9d833c383aa80/f21e7/6.png 360w,\n/static/1ae8dfe469955be626d9d833c383aa80/6af66/6.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ul>\n</li>\n<li><a href=\"https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/\">해결 방법</a>\n<ul>\n<li>Stop and wait : 흐름 제어때도 나왔엇지만, 제대로 받았다는 응답이 올때까지 대기하고 그 다음 데이터를 보내는 방식.\n<ul>\n<li>\n<p>아주 기본적으로 오류 제어가 가능하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 120%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAAEPElEQVQ4y4VVbUscVxR+7p0Zd3Vf3N3UrHHNatJYNWlppCURRNTahn4t5IOQkn5JG1JB0hQhKZQoBJovxZImqaCiICkkLOtLpKxkV2Zd3cUJtuAL6GxcHcEfEDFf2uiUMzNr12SlFy535r6ce87zPOdc4L9WD+AzAK0ACrKTDofDGOOyjHQ6DVVVMT8/T1PM2vIhgAsAGgE05NhDIYAggHcExozd1EVRNBZ1XTfGmupqvNFsAI4CCAAoPrDCAJfVndYoCZyTRSG7p9Tvz+4FZ6aTEuf0X4Q8zQXAzhgTGCByxpw11dVegmBwcPDzX+/do5AKPmlpsdE6dTokmgadLI9BN3kjCKZDwePHMTw8jMnJSYyMjLi7u7uLrNBtRgSMURQE1QlyPp+HzizYLS0tBm5ra2snlpaWajVNO7m1tfXuyspKzerqasDaLwicFzKghAFH8nlItxwNBoMUivTV5cvOTCbzNJPJLCeTyb9SqdSfsiyvRCKRAUsJ4nfXr5MHgoX5W+2IFbaBu8/jYbu7u3Zd1+3T09NFiUSiMJ1O21VVLaivr889d6hBDzOpFzhjBKQw0N+P3t5ehEIhjI+P45eeHuO/rKzMOMBNiRFB7rykEMgWY/TtLg8E6AL70NDQuXA4fIpwbWhokHiOVhnADvPQldWcwLkxcevmTTudGRsbO9fX1/cREVd39qyPM+a2LnVYgvYepkPR5XKh6/ZtdHV1YXFxEcvLy5BlGfF4HOFwGKOjo0a0dpstK/iDsqFZKx2clQD/+epVg5Tv29vF9fX1bzOZzF1FUe4sLCzckWX57tTUVHtzUxOlnOR2uyl8Ww6ZyE30UiMnz5yheCXqay9e/LipaQPK3Nxvs7OzD2VZHohGoz98eekS+cHq6uoIP+ktDP1mufH+xFiJDjD94kVJn5srXIvHkXn+HMqjR5h+9gx/RCKYmJhAW1ubWRkKjMIk5hosY2a18DsAt15aKr0C7K9u3Dj1dzj8zSZQ+LK5+cjLysrAyrVrtiFNE54+fix0dnbmhnfAYDmADxhQbTDFuTDt94Po1F+/FnWA61VVXAeK/6FvKnpFRfuSyWcw9ya3APicnLu4CbITDgdhyT9OpSRd13nt+fP7oDNLixaneUkh2RAhTBIE8ZjXK75/+jRtFENPnnzR39fXQkSVBwKUUQVWDme78zBhS9wSdUVFBR4+eICenp7sOs9WbnodmCluKl8n/7d8VQSDxoSqqq5EIuFVFMW9t7fnUlW1eGFx0XGrowOd9++jq6MDVpb48hmkmuYJlpcbGvz6yhWntrExtbGxsakoSlpRFHVmZmYrGo3+bunU5vV4JMaYeFguHwNQkg3vvaoqrmmaZ2dnx5dMJr2hUMgbi8V8kUjE1dTY+Gb5ylttjIdGtJ6A2poaaJqG7e1tpJJJegYQi8UQiUTwaWureav5nuyT8i8i/kEjJwSK5wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/d56b1d2af5a3dbf6de16fd6ecc8c5243/6af66/7.png\"\n        srcset=\"/static/d56b1d2af5a3dbf6de16fd6ecc8c5243/e9ff0/7.png 180w,\n/static/d56b1d2af5a3dbf6de16fd6ecc8c5243/f21e7/7.png 360w,\n/static/d56b1d2af5a3dbf6de16fd6ecc8c5243/6af66/7.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>하지만 흐름 제어에 sliding window 방법을 사용하다면 데이터를 연속적으로 보내기 위함인데, 이런 방식으로 오류 제어를 사용하면, 그 이점을 잃는다.</p>\n</li>\n</ul>\n</li>\n<li><strong>Go Back N (GBN)</strong>\n<ul>\n<li>\n<p>데이터를 <strong>연속적</strong>으로 보내다가, <strong>어느 데이터부터 오류가 발생했는지 검사</strong>하는 방식.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 133.33333333333331%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFF0lEQVRIx5VVb0wTZxx+rn+uPdr7VwRtKozWjYLAWCJbZkSnzAQXTRazbF/clxljtsws8+OW+cEok1iJftGMGROIjI2FxgU0gEANRyCBpkVWikv4I51FF6eJdahAte/yXu/YoW7J3uSXe++995577vc8v98LALUAtgN4F4AF/2+wAN4DsBVADYA36WIhgBIAnud38zyvXs+ePcvU19ejsbERgUDAuIUBsBbAawB8APL1By4AZgCc9lV1yLKsXk+dOoUjR46gpaUFe/bseRlTEwCbccENQATgBCBoc9HhcFCKbDAYfLupqcl1+/Zt1NbWMi8BtGvvrgxKm9cW6dVBw+VySQCsHR0dXxw/fvx1+qIgCJL+XAsY3l3FUDAwVEHdbrfKMBKJfNLV1eWn4GvWrOENe3WgSgCSEVDSFOYM9EWNIdvb2/t5Q0NDOZ3n5uY6tec6oF0TVTQCyivZNZlACKHBEEJosi0tLS01J0+epC5wer1e2ePxyDabTTAwfQHQ1dTUpE7WrVuHeDyO9vZ2RKNRDCoKfrl0Cc3NzRgYGEAwGEQ4HKZbzbIsW7U/22gEZLQvqaOmpga/3bhR3tPT887ExMSWRCJRPT4+vm1gYGDr3Nxc9cTERPWv4+PVHR0dqmAej8eiibNKFC/LsrzdbqceZPv7+3++fPnyn7FY7Obk5GRCUZREd3d34vr164mrV68m+vr6fm9tba2iqVEUhVkFaM5S3GDXKJds3kzzZyKEWAkhrBY2Gnfv3mVTqZS+hr179xp9mLXQgexC3opqDKMrbXmQFQc/dXWhvqEBBw8exPfnz+PRo0c4evSoWklURM0dWUBitWIbsDbDMM5BgC8G+FybzSlynIi8PKo+19zW9vE3x469StPxxqZNVmXfPuYzSWJgNusdwmwwObAZWDsPOBKAgzAMTxjGqUZ+Pk8Ay83+/k9bA4FSKoLI85KmqG4Zyu4Vo7CqW/T61SvFAQg/ulziB4Al09t7gAQCJQRgiSTRDzoI4PwWELYAdg9QxgESp6OZqbGlbOXs2rGDrfD7c4rLyji2uJgucj+0t39Zd+aMWsvbi4pcnQUFQrCoyPmX2y0Ss5kjQMn7gPiRsVK06kAymcTo6Cgi0Si+u3gRjc3NeDA/T1mrymq+tWnBaVGxYmyqEsuyroWFBQooEEKKCCEFhJDCkZGRQkVRCtva2tz37t3zzMzOrk/eurWeEJKNZ8/Wf7hzJ/Wux2QyZXPodDpRUVGROzU1heXl5a+XlpZIJpN5kkql0teuXUuHw+F0KBR6GovFng4PD6enp6fThJD08vIySafTf4yNjdHmbJcliV/5X1EUafth4/H4V7FYjIyOji4MDw8vRqPRxVgstnhjcnKJzkOh0GIkElns6+t7oijKs8HBwXlCCFXaIoriP6VntVppJ7E/fPgw7/79+5Wzs7NlTx4/Ls1kMqWpVKosmUz679y5s3FmZqZ8bGysPBwOl0/G4xVDQ0OlWl7tJpNpVS3n5+Tk6J3aajj9aAlibm7OQa8jIyOgXenChQsIhUIYGhqCz+ejOnDPNwfVh7IsC36/XygoKJC8Xq9YVVVFleM6OzsP1dXVqbaprKwUfD6fsHv3bvbw4cNmjaF1VaUYGqzRCoLWsW1Xrlw5dPr06TI1+bKs/4leCHRe+kKD/beTnDIIBoNvnThxgp65rM1mW1VRAHIAlD8PKP4X4Llz57B//371XhAE41ls1zrgBr2W/wYX1/Gyu6WsjgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/fd76c98eb405aa86b06b058d9687e54d/6af66/8.png\"\n        srcset=\"/static/fd76c98eb405aa86b06b058d9687e54d/e9ff0/8.png 180w,\n/static/fd76c98eb405aa86b06b058d9687e54d/f21e7/8.png 360w,\n/static/fd76c98eb405aa86b06b058d9687e54d/6af66/8.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>데이터를 연속적으로 보낸 후 한개의 ACK 혹은 NACK(오류 제어에선 설명의 간단함을 위해서 NACK로 사용)만으로 오류 파악이 가능하니, 슬라이딩 윈도우와 찰떡 (sliding window가 네트워크 대역폭의 이용률을 높이기 위해서 다른 프레임을 보내기전에 ACK를 요구하지 않는데 )</p>\n</li>\n<li>\n<p>만약 4번 데이터에서 에러를 감지하면, 수신측은 4번 데이터 이후 받은 모든 데이터를 폐기후 송신측에 알리는 방식이다.</p>\n<blockquote>\n<p>왜 데이터들을 다 폐기할까?</p>\n</blockquote>\n<blockquote>\n<p>수신자의 버퍼관리가 간단하다. 결국에 수신자도 상위 계층에 데이터를 전달하는 입장인데, 순서가 잘못 넘어온 데이터에 대해서(n+1만 오고, n은 오지 않음) 버퍼링을 할 필요가 없기 때문이다.</p>\n</blockquote>\n</li>\n<li>\n<p>송신측은 5번까지 이미 전송을 했지만, 4번 데이터에서 에러가 났다는것을 알았기에 4번으로 되돌아가서(Go Back) 다시 전송해야 한다.</p>\n</li>\n<li>\n<p>ACK이 누적적(cumulative)이다.</p>\n</li>\n<li>\n<p>SR에 비해서 구현이 간단하지만, GBN의 특성상 같은 데이터가 계속 오갈 수 있으니 대역폭을 효율적으로 사용하지 못한다.</p>\n</li>\n<li>\n<p>또 SR에 비해서 버퍼사이즈를 크게 잡을 수 있는데 시퀀스 넘버가 n비트일때 <code class=\"language-text\">2^n-1</code>개의 window 사이즈를 가질 수 있다. 왜 1을 빼냐면,</p>\n</li>\n</ul>\n</li>\n<li><strong>Selective Repeat (SR)</strong>\n<ul>\n<li>\n<p><strong>오류가 난 데이터만</strong> <strong>선택적인 재전송</strong>을 의미한다. GBN이 stop and wait에 비하면 효율적이지만, 에러가 발생하면 그 이후 정상적으로 받은 데이터를 모두 폐기처분하니, 재전송해야하는 비효율이 아직 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 153.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAYAAADnTu3OAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGeElEQVRIx3VWbWxT5xV+ju3rj9jX38QhWVPclQQWUKtuYlvYplWsVG2nIrUVICoBZrAJjR9TpK4wTQWGUCYSZSAxijQFMRBOGholdj5sYxu7xrFjO76245AoMCPB8iM/2NYAmwQsvtN7fR0M217p6L733nOf8/E+55wLAt4jop8AeIcANeRFADRqNc6fP4+nT59ieXkZ5XJZkpqlBfBTAt4koq0EfA9E5CCiV4hoFRGxe7y6erUE2NjYKH114sQJ6ujoQH9/Pza3t9cCMjULAWuI6BtEZJYAANiISE1EeiLSKBgwQG1tbVVAHDp0CKIoYrVsrCry4lhA0k7BXhA1EJFJBjTKexPP80amePXq1TfPf/55PQNcv369cgWQqDZ0fcXnijf1RMQTkaFG9KvsdhMA1cjIyKGTJ09uZB+aTCZzrZ5SoWCoVgCGFUAADtkrXvaQib6xsZEHoM4Jwl6fz9fCQltlt/Oynr7qBIDXABhrk2smQMHyV5NLo73ioXp8fPyXnZ2dG9jeZrMZaqNREOkArAfA1wJaqhuNRiMlXxaWYqX7ypVNPT09DhZWa2urxel0mnVaLTNmUlQ8/P+AO3fuxOTkJC5fvixdmXg8Hly8eBEBv196PjIyIuk2v/SSihkEsO5FQCn+ewsLuNDbi1wu96PR0dGPC4XC9lKptD2TyewMh0I7bt++vSOTyexIpVLbv+jvr2cpeMXpVFHlhA21gN9UqVTWVXY7qxQuHA73jo+Pl2ZmZgqzs7PFG7HYzLVr12by+XyRXUOhUNHtdm+cn5+XUiNTpkIb2eeX6wDTX1Uq6dlelwuvv/EGjh49ikuXLknE3r17NyKRCP7Q04Njx46hq6sLR44cAccxTkO3AogKbexyDowg0kOj4UGke2ftWuXbra2qf549S7XhLFe8ql11K4AiEd4DHCKR4QkR/zER/zbH6V/nOCNsNnZY2j8PDPys47PPWhkJrE6n5gcWi7JFqVRCqZQwrICUR8nqRSK0APV/JDL8iUgvEvEMXBKHgxcB7utI5MBX3d0MkPsWz7MGYJQPshIRsPbZKcuVAiKTrFAVU4fNJpXe3/3+/WJXV6sIqEWLZcWgn4g/S6T9MdBmBYzWKqACMMvA2ECkWE3E6YlUaGhgVFBf/vLLg590drLWo603Gs0HiAwfEelDREaRSPeAaN1mgP9hLbH1ejmncoXIQtL9gwf633/6qe7A+++rt777rtbW0mLWOBwmKcxKyP9dyxs3bMDp06fxu+PHceHCBYyNjSEajSKbzSKRSGBgYAButxtX3G509/TgVx0dkvE1gFLHmgtgUNQAWvfv368YHh5mH60ZHh4eCgQCI8lk0jM9Pe1NJpPeUCjkjUaj3kwmMzQ6OhrxeDy/YIAffvABpyDiX6yUNovZ3MQUBEH4/q1bt4YzmcxgPp8fLBQKg+l0ejAWiw3mcrnBVCp1NZvN+kql0idPnjyptGuOe0ZsVWWOWMfGxjgGWC6Xf/v48WMxk8ncz+VyS4lEYimfzy9dv359aXZ2dmlqaurrxcXFf4miWNqzZw/jqbJOp7M+5yERrWtoaGhkky0QCPwmGAyKOUH4x82bNx8yEQThUTwefxiLxR76/f6leDz+OBgMzv3t/n1u165dMBgMuudGAICGOp2ODRlFX1+f4d/LyzZRFC2PHj2ylstl68LCAn/37l1rNpu1M4lEIna/z2etzikiqntxprBaNnEcZ5YZX1VQszSEw+HmZDKpYGOU9cVz586hs7Pzf9ey3C3M1TcMYHN7O7f1rbdU3920iSnVeTyeX586dYqVHt/U1GRrbm7WO51OrZa1d7nRrwAeO35cIva2bdsYDxVer5cRGvfu3SO510lG9u3bp9iyZYuqvb1d5XA4eIvFYrJaLGbeYGCE/s5zHVuj0VjOnDkjtftYLCb1wO7ubgwNDSGTyWBiYgJerxd9fX0S+bu7unD48GGpJzJjao6zrZwyKy/WIH0+37fn5uYK09PTQjAYFAKBgHRNJBJCLpcTCoWCJOFwWIhGo7mJiYmpQCDwl3A4fJKxr6mp6bmZ0nrw4MHXFhcX99y5c8clCILrxo0brmKx6GL3pVLJNT8/75qbnXWl0+nq+72Tk5M/T6fT7GdHZTabn/HQaDQa2F8WmxEzMzPsVKVw4/E4isUiCoUCslNTSKVS8Pv90ihgtc72vb29sFqt7FdEyyj4HyJ4pBLfSDVHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/6b0a57c890dd50ed0bc71f39ea3826c8/6af66/9.png\"\n        srcset=\"/static/6b0a57c890dd50ed0bc71f39ea3826c8/e9ff0/9.png 180w,\n/static/6b0a57c890dd50ed0bc71f39ea3826c8/f21e7/9.png 360w,\n/static/6b0a57c890dd50ed0bc71f39ea3826c8/6af66/9.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>문제가 있는 데이터만 재전송하니 효율적이고 만능처럼 보이지만, 버퍼에 데이터들이 연속적이지 않다는 문제점이 있다.</p>\n</li>\n<li>\n<p>위 예시에서 데이터는 <code class=\"language-text\">0,1,2,3,5</code> 가 들어있다가 4를 재전송 받게 되면, <code class=\"language-text\">0,1,2,3,5,4</code> 의 데이터가 들어있다.</p>\n</li>\n<li>\n<p>기존의 버퍼 안에서 데이터를 정렬할 수 없으니, <strong>별도의 버퍼</strong>를 두어서 그 안에서 재정렬을 해줘야 한다.</p>\n</li>\n<li>\n<p>GBN에 비해서 재전송이 적다는 점에서 효율적이지만, 추가적인 로직이 필요해서 복잡하고, 별도의 버퍼를 관리하는데 드는 비용이 있다.</p>\n</li>\n<li>\n<p>ACK이 각각(individual)이다. (사진상으로는 안그런것처럼 보이지만)</p>\n</li>\n<li>\n<p>시퀀스 넘버가 n비트 일때 <code class=\"language-text\">2^(n/2)</code>개 이하의 window size로 제한되어 있다. 만약 <code class=\"language-text\">2^(n/2)</code>이라고 해보자. 그럼 뒤의 절반이 왔을때, 나머지 앞 절반이 안오면 뒤의 절반을 추가 버퍼에 가지고 있을텐데, 안 온 부분에 대해서</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"udp\" style=\"position:relative;\"><a href=\"#udp\" aria-label=\"udp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UDP</h2>\n<p><strong>비연결형</strong> 서비스를 지원하는 전송계층 프로토콜이다. 사전에 연결 설정을 하지 않은 <strong>데이터그램 방식</strong>으로 데이터를 전달한다.\n별도의 <strong>연결을 수립하지 않고</strong> 보내기 때문에, 각각의 패킷은 서로 다른 경로를 통해서 전송될 수 있고 각각은 독립적이고 그렇기에 패킷에 <strong>순서를 부여하진 않는다</strong>.</p>\n<p>실제로 UDP 헤더 부분을 보면 아래와 같이 받는 포트와 보내는 포트 정보, UDP 길이, checksum으로만 구성되어 있는 8Byte 구조이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAxklEQVQY031QywqEMAzs/3+XHgS96cmDq+AT7Cqira06y2QR9rBYCEkz08mkalkWbNuGfd/R9z3qukbbtmDfe495ntE0jeDDMKAsS+Gwp7XGcRySyTvPE8oYA+ecRJqmSJIEcRyj6zohG2uwrqvUWZYhCAJEUYQwDFFVFa7rAjWI8a4283XnvBNnnJznOcZxFIfE7G6lpkPijFf5ElfsW2sxTZMMVVz36XCdoigeOfdgHkV1NqjO/Bv8Ew7Ub/0Xv99RjDUFP+dVf1O7Fq+kAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/65aaeaa3dad7457ddaa7e1ec70cc801a/37523/11.png\"\n        srcset=\"/static/65aaeaa3dad7457ddaa7e1ec70cc801a/e9ff0/11.png 180w,\n/static/65aaeaa3dad7457ddaa7e1ec70cc801a/f21e7/11.png 360w,\n/static/65aaeaa3dad7457ddaa7e1ec70cc801a/37523/11.png 720w,\n/static/65aaeaa3dad7457ddaa7e1ec70cc801a/a0209/11.png 725w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>UDP는 TCP와 달리 흐름제어, 오류제어 , 손상된 세그먼트에 대한 <strong>재전송을 하지 않는다.</strong></li>\n<li>오직 Checksum 필드를 통해서 <strong>최소한의 오류만 검출</strong>하기 때문에 신뢰성이 TCP에 비해서 낮은 편이지만, 이 때문에 TCP에 비해서 <strong>속도가 빠르다.</strong></li>\n<li>그렇기에 신뢰성 보다는 <strong>연속성이 중요한 서비스</strong> , 예를 들어 실시간 서비스에서 자주 사용된다.</li>\n<li>TCP가 소켓을 open해서 통신하는 구조에 반해서 UDP는 오직 IP를 기반으로만 데이터를 전송한다.</li>\n<li>흐름제어가 없기 때문에, 패킷이 제대로 전송되었는지, 오류가 없는지는 확인할 수 없다.</li>\n</ul>\n<p>또 대표적으로 UDP를 사용하는 서비스가 DNS인데(모든 DNS가 UDP만 쓰는것은 아니다.) 아래 이유로 사용된다.</p>\n<ul>\n<li>3way handshake와 같은 연결 수립 과정이 없기 때문에, <strong>연결 설정에 드는 비용이 없어 빠르다</strong>.</li>\n<li>연결 상태를 유지하는 TCP의 특성상 버퍼에 대한 정보,혼잡제어 정보, seq,ack 번호와 같은 정보를 저장해야하기에  <strong>UDP가 더 많은 클라이언트를 수용할 수 있다.</strong></li>\n<li><strong>DNS의 레코드는 일반적으로 작아서</strong> UDP 세그먼트에 어울린다. (50-550 Byte)</li>\n<li>UDP가 신뢰성이 없긴 하지만, DNS가 더 상위계층(application layer)의 프로토콜이니 <strong>만약 응답이 오지 않는 경우에서는 다시 전송하도록 지시할 수 있다.</strong></li>\n</ul>\n<p>단, DNS의 응답의 크기가 512Byte 보다 크거나, zone transfer(DNS 레코드를 primary에서 secondary로 옮기는 작업)을 할때에는, 데이터의 정합성 검사를 위해서 TCP를 사용한다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#tcp\">TCP</a></p>\n<ul>\n<li><a href=\"#tcp-%EC%97%B0%EA%B2%B0-%EA%B3%BC%EC%A0%95\">TCP 연결 과정</a></li>\n<li><a href=\"#2-way-handshake%EC%9C%BC%EB%A1%9C-%EB%B6%80%EC%A1%B1%ED%95%9C%EA%B0%80\">2 way handshake으로 부족한가?</a></li>\n<li><a href=\"#tcp-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C-%EA%B3%BC%EC%A0%95\">TCP 연결 해제 과정</a></li>\n<li><a href=\"#tcp-%EC%83%81%ED%83%9C-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8\">TCP 상태 다이어그램</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#tcp%EC%9D%98-%EC%8B%A0%EB%A2%B0%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95%EB%93%A4\">TCP의 신뢰성을 위한 방법들</a></p>\n<ul>\n<li><a href=\"#%ED%9D%90%EB%A6%84-%EC%A0%9C%EC%96%B4\">흐름 제어</a></li>\n<li><a href=\"#%ED%98%BC%EC%9E%A1-%EC%A0%9C%EC%96%B4\">혼잡 제어</a></li>\n<li><a href=\"#%EC%98%A4%EB%A5%98-%EC%A0%9C%EC%96%B4\">오류 제어</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#udp\">UDP</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"February 05, 2022","title":"TCP와 UDP","categories":"네트워크","author":"weasel","emoji":"📓"},"fields":{"slug":"/tcp-and-udp/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/stack-and-queue/","nextSlug":"/array-and-linked-list/","prevSlug":"/tcp-and-udp/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}