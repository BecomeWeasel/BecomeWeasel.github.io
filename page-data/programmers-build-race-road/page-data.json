{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/programmers-build-race-road/",
    "result": {"data":{"cur":{"id":"66048345-c84e-5c3f-b3e2-0a3cfe60a3e9","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30.555555555555554%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlUlEQVQY0z2Q7U8SAQDG7z9rq7VVrg8tzSQFLkBgJxH0NtFmNZXVMQYrKaXR0JkeHAFx3AHeCyJKsda3/p5fu3Pzw7Pfh+flwyO0zDNcNc0RHeuCrjOlZY1p9IdceScjtOGE3vkfj2rPQR9N2S6UmPc/pvh1n+7pLy8ndJwLr3TQ0DjQDXYaFaq1Jvs/dH7a557cckVpki1+Jv+lgk8Mk8psEJKS5EtlwitP6TgT3C1B6Z6gaCZlpc4z7Q3r/2Q+GEWqxy0U3eJYG1A3bMKJFPd9fm7cuUuuVOaBX2QpEuew3SOSSHPU6aN0TYRgVCIYifMwHmP2eZrY3ltSWoaFgIgYW0GMSfiCITLvsrzezpF4sUry1RrXbt5i5t4sgeU412/PeBSjEkLdsGgPRuS+V5lfXyWhymz2ZY4aBo2+g2pY1HSTweQv2WKJ5SdpNt7nmVsMsBiKIu+UCUQl1J6NatgIbXuM7kzZ7dVY+y2zNfxERa2jn05pW+OrH92fXW7mCiRfZjhs6WzlPzL3aInC3jf0s8v8f6HdTNw+pBvIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"race road\"\n        title=\"race road\"\n        src=\"/static/4cbf0d6d188cbd80f46f5ba17c6ab6e1/37523/race-road.png\"\n        srcset=\"/static/4cbf0d6d188cbd80f46f5ba17c6ab6e1/e9ff0/race-road.png 180w,\n/static/4cbf0d6d188cbd80f46f5ba17c6ab6e1/f21e7/race-road.png 360w,\n/static/4cbf0d6d188cbd80f46f5ba17c6ab6e1/37523/race-road.png 720w,\n/static/4cbf0d6d188cbd80f46f5ba17c6ab6e1/00d43/race-road.png 1000w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"문제-제목\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%A0%9C%EB%AA%A9\" aria-label=\"문제 제목 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 제목</h3>\n<p><a href=\"https://programmers.co.kr/learn/courses/30/lessons/67259\">경주로 건설</a></p>\n<h3 id=\"문제-설명\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\" aria-label=\"문제 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 설명</h3>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/8326247c-0516-4faf-a2a5-4baacac9e202/image.png\" alt=\"\">\r\n건설회사의 설계사인 죠르디는 고객사로부터 자동차 경주로 건설에 필요한 견적을 의뢰받았습니다.\r\n제공된 경주로 설계 도면에 따르면 경주로 부지는 N x N 크기의 정사각형 격자 형태이며 각 격자는 1 x 1 크기입니다.\r\n설계 도면에는 각 격자의 칸은 0 또는 1 로 채워져 있으며, 0은 칸이 비어 있음을 1은 해당 칸이 벽으로 채워져 있음을 나타냅니다.\r\n경주로의 출발점은 (0, 0) 칸(좌측 상단)이며, 도착점은 (N-1, N-1) 칸(우측 하단)입니다. 죠르디는 출발점인 (0, 0) 칸에서 출발한 자동차가 도착점인 (N-1, N-1) 칸까지 무사히 도달할 수 있게 중간에 끊기지 않도록 경주로를 건설해야 합니다.\r\n경주로는 상, 하, 좌, 우로 인접한 두 빈 칸을 연결하여 건설할 수 있으며, 벽이 있는 칸에는 경주로를 건설할 수 없습니다.\r\n이때, 인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 직선 도로 라고 합니다.\r\n또한 두 직선 도로가 서로 직각으로 만나는 지점을 코너 라고 부릅니다.\r\n건설 비용을 계산해 보니 직선 도로 하나를 만들 때는 100원이 소요되며, 코너를 하나 만들 때는 500원이 추가로 듭니다.\r\n죠르디는 견적서 작성을 위해 경주로를 건설하는 데 필요한 최소 비용을 계산해야 합니다.</p>\n<p>예를 들어, 아래 그림은 직선 도로 6개와 코너 4개로 구성된 임의의 경주로 예시이며, 건설 비용은 6 x 100 + 4 x 500 = 2600원 입니다.\r\n<img src=\"https://images.velog.io/images/hsw0194/post/aef8054f-c65c-488a-b209-3d34dc644a2a/image.png\" alt=\"\">\r\n또 다른 예로, 아래 그림은 직선 도로 4개와 코너 1개로 구성된 경주로이며, 건설 비용은 4 x 100 + 1 x 500 = 900원 입니다.\r\n<img src=\"https://images.velog.io/images/hsw0194/post/714149fd-a102-4f9e-87eb-1029f4fe0ecb/image.png\" alt=\"\">\r\n도면의 상태(0은 비어 있음, 1은 벽)을 나타내는 2차원 배열 board가 매개변수로 주어질 때, 경주로를 건설하는데 필요한 최소 비용을 return 하도록 solution 함수를 완성해주세요.</p>\n<h4 id=\"제한-사항\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%ED%95%9C-%EC%82%AC%ED%95%AD\" aria-label=\"제한 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제한 사항</h4>\n<ul>\n<li>board는 2차원 정사각 배열로 배열의 크기는 3 이상 25 이하입니다.</li>\n<li>board 배열의 각 원소의 값은 0 또는 1 입니다.</li>\n<li>도면의 가장 왼쪽 상단 좌표는 (0, 0)이며, 가장 우측 하단 좌표는 (N-1, N-1) 입니다.</li>\n</ul>\n<p>원소의 값 0은 칸이 비어 있어 도로 연결이 가능함을 1은 칸이 벽으로 채워져 있어 도로 연결이 불가능함을 나타냅니다.</p>\n<ul>\n<li>board는 항상 출발점에서 도착점까지 경주로를 건설할 수 있는 형태로 주어집니다.</li>\n</ul>\n<p>출발점과 도착점 칸의 원소의 값은 항상 0으로 주어집니다.</p>\n<h3 id=\"예제-입출력\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5\" aria-label=\"예제 입출력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예제 입출력</h3>\n<p><strong>입력</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[[0,0,0],[0,0,0],[0,0,0]]\t\r\n[[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,1],[0,0,1,0,0,0,1,0],[0,1,0,0,0,1,0,0],[1,0,0,0,0,0,0,0]]\t\r\n[[0,0,1,0],[0,0,0,0],[0,1,0,1],[1,0,0,0]]\t\r\n[[0,0,0,0,0,0],[0,1,1,1,1,0],[0,0,1,0,0,0],[1,0,0,1,0,1],[0,1,0,0,0,1],[0,0,0,0,0,0]]\t</code></pre></div>\n<p><strong>입출력 예 #4</strong>\r\n<img src=\"https://images.velog.io/images/hsw0194/post/b1614d13-f782-4bbe-807e-86c1216d0580/image.png\" alt=\"\"></p>\n<blockquote>\n<p>붉은색 경로와 같이 경주로를 건설하면 직선 도로 12개, 코너 4개로 총 3200원이 듭니다.</p>\n</blockquote>\n<p>만약, 파란색 경로와 같이 경주로를 건설한다면 직선 도로 10개, 코너 5개로 총 3500원이 들며, 더 많은 비용이 듭니다.</p>\n<p><strong>출력</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">900\r\n3800\r\n2100\r\n3200</code></pre></div>\n<h3 id=\"풀이\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4\" aria-label=\"풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이</h3>\n<p>처음 든 생각은 카카오다운 문제였다. BFS/DFS와 같은 어렵지 않은 탐색 풀이를 요구하지만 , naive하지 않고 여러가지 제약을 주고 <del>문제가 귀엽고</del> 문제 설명이 굉장히 친절하다는 것이다. 예시도 굉장히 많고 각각의 예시에 대해서 설명이 나와있기 때문에 코너케이스 방어에 쉽고 논리구조 쌓기가 수월하다.</p>\n<p><strong>그렇다고 마냥 쉬운 문제는 아니다.</strong></p>\n<h4 id=\"사고의-과정\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EA%B3%A0%EC%9D%98-%EA%B3%BC%EC%A0%95\" aria-label=\"사고의 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사고의 과정</h4>\n<p>문제 독해를 천천히 해보면, 최단경로를 구하는 문제처럼 포장을 해놓았다. 하지만 바로 위에 언급한 <strong>입출력 #4</strong>를 보면 파란색 경로가 최단경로임을 알 수 있지만, 최단경로가 아닌 빨간색 경로가 가장 적은 비용으로 목표지점에 도달할 수 있는 경로다. naive하게 최단경로를 구하는 문제는 아닌것이다.</p>\n<p>그렇다고 <a href=\"https://www.acmicpc.net/problem/1967\">트리의 지름</a> 같은 최장경로 문제일까? <strong>전혀 아니다.</strong> 최소한 우리가 구하는 경로는 최단경로에 근접하지만, 그 안에서 비용을 고민해야 하는 문제다.</p>\n<p>문제내에 명시된 비용의 제약사항은 아래와 같다.</p>\n<blockquote>\n<p>인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 직선도로라고 합니다. 또한 두 직선 도로가 <strong>서로 직각으로 만나는 지점을 코너</strong>라고 부릅니다.</p>\n</blockquote>\n<p>쉬운 말로 바꾸면, 경주로가 계속 <strong>오른쪽으로 가다가 위,아래 방향</strong>으로 바꾸면 되면 코너가 생긴다는 것이다. (<strong>왜 왼쪽이 제외되었는가는 아래에서 설명하겠다.</strong>) 다시 말해서 탐색의 방향이 전환되는 시점에서 코너가 생긴다는 것이고, 직전의 탐색의 방향이 중요하니 기록 할 필요가 있다.</p>\n<blockquote>\n<p>이걸 본 순간 바로 떠오른 비슷한 문제가 있다. 백준의 <a href=\"https://www.acmicpc.net/problem/1726\">로봇</a>이라는 문제인데, 단순히 탐색이 아닌 이전 탐색에서의 방향이 지금의 탐색의 명령개수에 영향을 주는 문제다.</p>\n</blockquote>\n<h4 id=\"visit-배열에-이전-방향이-포함되어야하나\" style=\"position:relative;\"><a href=\"#visit-%EB%B0%B0%EC%97%B4%EC%97%90-%EC%9D%B4%EC%A0%84-%EB%B0%A9%ED%96%A5%EC%9D%B4-%ED%8F%AC%ED%95%A8%EB%90%98%EC%96%B4%EC%95%BC%ED%95%98%EB%82%98\" aria-label=\"visit 배열에 이전 방향이 포함되어야하나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>visit 배열에 이전 방향이 포함되어야하나?</h4>\n<p>직전 탐색의 방향이 중요하다는 것은, 직전 탐색에서의 상황이 단순 <strong>x,y</strong>좌표가 아니라 <strong>상,하,좌,우</strong>인 방향 역시 포함한다는 것이다. <a href=\"https://velog.io/@hsw0194/%EB%B0%B1%EC%A4%80-16922-%EB%A1%9C%EB%A7%88%EC%88%AB%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0\">일차원 DFS 탐색에 관한 이전 글</a>에서 명시한 내용 중에서 <em>BFS와 DFS든 노드의 방문여부 배열의 차원을 구성하는것은 노드를 방문할때의 상황의 개수에 따라 나뉘어 진다는것</em> 이라는 부분이 있다.</p>\n<p>그러면 (x,y)를 방문했는지 체크하는 visit 배열이 직전 방향까지 포함한 3차원이여야 할것같다.</p>\n<blockquote>\n<p><code class=\"language-text\">visit[y][x][prev_dir]</code> =이전 방향이 prev_dir인 상태로 (x,y)를 방문했는지</p>\n</blockquote>\n<p>아마 탐색할때 이런 식으로 검사하면 같은 방향 접근시 중복 방문을 막을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">if</span> <span class=\"token number\">0</span><span class=\"token operator\">&lt;=</span>ny<span class=\"token operator\">&lt;</span>n <span class=\"token keyword\">and</span> <span class=\"token number\">0</span><span class=\"token operator\">&lt;=</span>nx<span class=\"token operator\">&lt;</span>n <span class=\"token keyword\">and</span> board<span class=\"token punctuation\">[</span>ny<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nx<span class=\"token punctuation\">]</span><span class=\"token operator\">!=</span><span class=\"token number\">1</span> <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> visit<span class=\"token punctuation\">[</span>ny<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">dir</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\r\n    visit<span class=\"token punctuation\">[</span>ny<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">dir</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token boolean\">True</span>\r\n    q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ny<span class=\"token punctuation\">,</span>nx<span class=\"token punctuation\">,</span><span class=\"token builtin\">dir</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h4 id=\"확실하게-틀리는-반례\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%8B%A4%ED%95%98%EA%B2%8C-%ED%8B%80%EB%A6%AC%EB%8A%94-%EB%B0%98%EB%A1%80\" aria-label=\"확실하게 틀리는 반례 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확실하게 틀리는 반례</h4>\n<p><strong>문제 해결!!!</strong> 이면 참 좋겠지만, 예시조차 통과하지 못한다. 그 이유는 아래와 같다.\r\n<img src=\"https://images.velog.io/images/hsw0194/post/a09fb254-5c56-4a89-9dec-a028d894ac3c/%EA%B7%B8%EB%A6%BC2.png\" alt=\"\">\r\n위의 그림에서 파란색 경로와 빨간색 경로가 있다고 할때 빨간색 경로가 최소비용을 가지는 경로다. 주의 깊게 봐야할 부분은 초록색 박스를 친 부분이다.</p>\n<p>만약 파란색 경로가 빨간색 경로보다 먼저 수행된다고 한다면 , <strong>(3,1)에서 (3,2)</strong> 으로 내려올때 <code class=\"language-text\">visit[2][3][up]</code>의 값은 <code class=\"language-text\">False</code>에서 <code class=\"language-text\">True</code>로 바뀌게 된다. <strong>(3,2)</strong> 를 위에서 아래로 내려오는 방문은 추후 탐색에서 방문 불가능한 상태인것이다.</p>\n<p>그런데 빨간색 경로는 정확하게 <strong>(3,2)</strong> 로 내려오는 경로를 포함하고 있다. <code class=\"language-text\">visit[2][3][up]</code>을 체크하게 되는데, 이전 탐색인 파란색 경로에서 이미 <code class=\"language-text\">True</code>로 저장했기 때문에 방문할수 없게 되는 것이다. <strong>최소 비용</strong>이 아닌 경로가 미리 방문했기 때문에 <strong>최소 비용</strong>을 가지는 경로가 정상적인 탐색을 진행할 수 없게 되는 것이다.</p>\n<h4 id=\"그러면-어떻게\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%AC%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C\" aria-label=\"그러면 어떻게 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그러면 어떻게?</h4>\n<p>그러면 어떻게 해야하는 걸까 ? 모든 가능한 경로마다 방문했던 좌표를 기록해야 하나? 그러면 확실하게 답을 구할 수 있다. 파란색이 방문한 <strong>(3,2)</strong> 와 빨간색이 방문한 <strong>(3,2)</strong> 는 다르기 때문이다. 하지만 공간 복잡도가 지수만큼 증가하기에 적절하지 않다.</p>\n<p>문제를 다시 천천히 읽어보면, 각각의 좌표들에 대해서 <strong>최소 비용</strong>경로로 접근해야하는 것이다. 위의 예시를 다시 보면, <strong>(3,2)</strong> 를 방문할때 빨간색 경로의 비용과 파란색 경로의 비용을 비교하면 빨간색 경로의 비용이 더 적다. 그 말은 이미 파란색 경로에서 <strong>(3,2)</strong> 를 방문했더라도, 빨간색 경로가 더 적은 건설비용을 계산 할 수 있으면 <strong>(3,2)</strong> 를 재방문하게 해야 한다. <strong>조건적인 재방문을 허용할 필요가 있고 <code class=\"language-text\">visit</code> 배열을 재정의해야 한다.</strong></p>\n<h4 id=\"visit-배열의-dp적-특성\" style=\"position:relative;\"><a href=\"#visit-%EB%B0%B0%EC%97%B4%EC%9D%98-dp%EC%A0%81-%ED%8A%B9%EC%84%B1\" aria-label=\"visit 배열의 dp적 특성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>visit 배열의 DP적 특성</h4>\n<blockquote>\n<p><code class=\"language-text\">visit[y][x]</code> = (x,y)를 방문했을때의 비용, (x,y)를 방문할때 비용이 visit[y][x]보다 작거나 같으면 재방문 가능</p>\n</blockquote>\n<p>이렇게 정의하고 다시 문제를 보자. 모든 노드들간의 간선이  <strong>양의 가중치를 갖는</strong> 그래프에서의 <strong>DP와 BFS</strong>문제로 볼 수 있다.</p>\n<p>결국에 문제의 핵심은 <strong>(y,x)로 도착하는 최소 비용</strong> 경로가 새로 있다면, 중복 방문을 허용하는 아이디어다. 위에 살짝 언급한 아래 사례는 visit 배열의 특성을 생각하면 자명하게 풀린다.</p>\n<blockquote>\n<p>경주로가 계속 오른쪽으로 가다가 위,아래 방향으로 바꾸면 되면 코너가 생긴다는 것이다. (왜 왼쪽이 제외되었는가는 아래에서 설명하겠다.)</p>\n</blockquote>\n<p><strong>오른쪽</strong>으로만 가다가 <strong>왼쪽</strong>으로 방향을 트는 것은 , 왔던 곳을 되돌아 가는 것이고, <strong>모든 좌표끼리의 이동은 양의 가중치</strong>를 갖기 때문에 되돌아 갈때는 왔던 것보다 무조건 큰 비용을 갖기 때문에 왼쪽 방향으로 이동을 고려할 필요가 없는 것이다.</p>\n<p><strong><code class=\"language-text\">visit[y][x]</code>의 비용보다 같을때도 중복 방문을 허용</strong>해야 하는 이유가 뭘까?\r\n간단히 생각해서 최소비용 경로가 무조건 <strong>(3,3)</strong> 을 방문해야 한다고 해보자. <strong>(3,3)</strong> 을  직선으로 방문할때가 있고, 꺾어서 방문할때가 있다. 만약 <strong>(3,3)</strong> 을 방문하기 전까지의 둘의 비용이 같다고 할때 ,먼저 꺾어서 방문하게 되는 경우에는 추후에 추가적으로 코너 건설 비용이 500만큼 더 들기 때문에 <strong>최소 비용</strong> 거리가 아닐 수 있다. 그렇기에 비용이 같을때 방문을 막게 된다면 일직선으로 <strong>(3,3)</strong> 을 방문하는 최소비용 거리를 구할수 없다.</p>\n<p>나머지 부분은 단순 구현이기 때문에 설명은 생략한다.</p>\n<h3 id=\"풀이코드\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4%EC%BD%94%EB%93%9C\" aria-label=\"풀이코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\r\n<span class=\"token keyword\">def</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n    n<span class=\"token operator\">=</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">)</span>\r\n    answer <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span>\r\n    <span class=\"token comment\"># 최단거리가 최소값이 아닐 수 있다. 하지만 근접하게 풀어야한다.</span>\r\n    \r\n    dy<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\r\n    dx<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\r\n    \r\n    q<span class=\"token operator\">=</span>deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token comment\"># visit 배열을 모두 INF로 채움</span>\r\n    visit<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">float</span><span class=\"token punctuation\">(</span><span class=\"token string\">'inf'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\r\n    \r\n    q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n    \r\n    <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\r\n        y<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">,</span>cost<span class=\"token punctuation\">,</span>prev_dir<span class=\"token operator\">=</span>q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n        \r\n        <span class=\"token comment\"># 도착했다면</span>\r\n        <span class=\"token keyword\">if</span> y<span class=\"token operator\">==</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token keyword\">and</span> x<span class=\"token operator\">==</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\r\n            answer<span class=\"token operator\">=</span><span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>answer<span class=\"token punctuation\">,</span>cost<span class=\"token punctuation\">)</span>\r\n            <span class=\"token keyword\">continue</span>\r\n            \r\n        \r\n        <span class=\"token keyword\">for</span> k <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n            <span class=\"token comment\"># 이전 방향과 다르다면 코너 건설비용이 추가로 듬</span>\r\n            curve_cost<span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token keyword\">if</span> prev_dir<span class=\"token operator\">==</span>k <span class=\"token keyword\">else</span> <span class=\"token number\">500</span>\r\n            \r\n            new_cost<span class=\"token operator\">=</span>cost<span class=\"token operator\">+</span><span class=\"token number\">100</span><span class=\"token operator\">+</span>curve_cost\r\n\r\n            ny<span class=\"token punctuation\">,</span>nx<span class=\"token operator\">=</span>y<span class=\"token operator\">+</span>dy<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>x<span class=\"token operator\">+</span>dx<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span>\r\n            \r\n            <span class=\"token comment\"># (nx,ny) 방문시 이전 방문보다 적은 비용으로 방문하면</span>\r\n            <span class=\"token keyword\">if</span> <span class=\"token number\">0</span><span class=\"token operator\">&lt;=</span>ny<span class=\"token operator\">&lt;</span>n <span class=\"token keyword\">and</span> <span class=\"token number\">0</span><span class=\"token operator\">&lt;=</span>nx<span class=\"token operator\">&lt;</span>n <span class=\"token keyword\">and</span> board<span class=\"token punctuation\">[</span>ny<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nx<span class=\"token punctuation\">]</span><span class=\"token operator\">!=</span><span class=\"token number\">1</span> <span class=\"token keyword\">and</span> new_cost<span class=\"token operator\">&lt;=</span>visit<span class=\"token punctuation\">[</span>ny<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\r\n                visit<span class=\"token punctuation\">[</span>ny<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nx<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>new_cost\r\n                q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ny<span class=\"token punctuation\">,</span>nx<span class=\"token punctuation\">,</span>new_cost<span class=\"token punctuation\">,</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token comment\"># 초기 출발시에는 방향이 없으니 무조건 코너를 돌게 하는데</span>\r\n    <span class=\"token comment\"># 불필요하게 500의 초과 비용이 발생하니 빼줘야함</span>\r\n    <span class=\"token keyword\">return</span> answer<span class=\"token operator\">-</span><span class=\"token number\">500</span>\r\n</code></pre></div>\n<blockquote>\n<p>백준 난이도로 환산하면 골드4 정도로 보인다.</p>\n</blockquote>\n<blockquote>\n<p>아주 깔끔하고 재밌는 문제였다. 30~40분 내로 풀이하면 적절하다.</p>\n</blockquote>\n<blockquote>\n<p>bottom up DP로 풀어도 충분히 답이 나올것같다.</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%A0%9C%EB%AA%A9\">문제 제목</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\">문제 설명</a></p>\n<ul>\n<li><a href=\"#%EC%A0%9C%ED%95%9C-%EC%82%AC%ED%95%AD\">제한 사항</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%98%88%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5\">예제 입출력</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%92%80%EC%9D%B4\">풀이</a></p>\n<ul>\n<li><a href=\"#%EC%82%AC%EA%B3%A0%EC%9D%98-%EA%B3%BC%EC%A0%95\">사고의 과정</a></li>\n<li><a href=\"#visit-%EB%B0%B0%EC%97%B4%EC%97%90-%EC%9D%B4%EC%A0%84-%EB%B0%A9%ED%96%A5%EC%9D%B4-%ED%8F%AC%ED%95%A8%EB%90%98%EC%96%B4%EC%95%BC%ED%95%98%EB%82%98\">visit 배열에 이전 방향이 포함되어야하나?</a></li>\n<li><a href=\"#%ED%99%95%EC%8B%A4%ED%95%98%EA%B2%8C-%ED%8B%80%EB%A6%AC%EB%8A%94-%EB%B0%98%EB%A1%80\">확실하게 틀리는 반례</a></li>\n<li><a href=\"#%EA%B7%B8%EB%9F%AC%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C\">그러면 어떻게?</a></li>\n<li><a href=\"#visit-%EB%B0%B0%EC%97%B4%EC%9D%98-dp%EC%A0%81-%ED%8A%B9%EC%84%B1\">visit 배열의 DP적 특성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%92%80%EC%9D%B4%EC%BD%94%EB%93%9C\">풀이코드</a></p>\n</li>\n</ul>\n</div>","excerpt":"문제 제목 경주로 건설 문제 설명 \r\n건설회사의 설계사인 죠르디는 고객사로부터 자동차 경주로 건설에 필요한 견적을 의뢰받았습니다.\r\n제공된 경주로 설계 도면에 따르면 경주로 부지는 N x N 크기의 정사각형 격자 형태이며 각 격자는 1 x 1 크기입니다.\r\n설계 도면에는 각 격자의 칸은 0 또는 1 로 채워져 있으며, 0은 칸이 비어 있음을 1은 해당 칸이 벽으로 채워져 있음을 나타냅니다.\r\n경주로의 출발점은 (0, 0) 칸(좌측 상단)이며, 도착점은 (N-1, N-1) 칸(우측 하단)입니다. 죠르디는 출발점인 (0, 0) 칸에서 출발한 자동차가 도착점인 (N-1, N-1) 칸까지 무사히 도달할 수 있게 중간에 끊기지 않도록 경주로를 건설해야 합니다.\r\n경주로는 상, 하, 좌, 우로 인접한 두 빈 칸을 연결하여 건설할 수 있으며, 벽이 있는 칸에는 경주로를 건설할 수 없습니다.\r\n이때, 인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 직선 도로 라고 합니다.\r\n또한 두 직선 …","frontmatter":{"date":"July 15, 2021","title":"프로그래머스 - 경주로 건설 (2020 카카오 인턴쉽)","categories":"PS","author":"weasel","emoji":"📓"},"fields":{"slug":"/programmers-build-race-road/"}},"next":{"id":"d5a78525-948d-54d9-b633-ee04f090a3e9","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 719px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjElEQVQoz31SO47bMBTUIbbIAXKcRZogVZA27XZ7jXRp9xKB+1zApWHIsGUItCTDkvWzKEqUNME8mI7WcPKAwaMovnnzhvSmaQKj73vEcYzdbgelFMqyhPvHrLWW/f1+jyhSyLIWSv1Cmn5CEHyFUp9R1y/w5oSHwwHr9Rqr1QppmgqRgzEGQRDIvzDcI0lKKLVAnn+B739HGH6D1q/wcA0WHY9HQVVVGIZB9sdxlO8sy5DnuTS21sKYFl034T48FrKIaJoGRVFIYdu2uFwuQsBMCzgBLdlutzidTlchdoYBXl3X4l0UReITCZMkESIWLZdL8c4pnoeza772uq4TBSQmqIwjOYXMbERwdFpCpWzsiObE3rwjjXeKuZ4HFXJs2sJMIfcqhdBtWNtjHHtoTaUFrO3e3TItoKrz+SyknOK/hMYM0BqI41YyzzvfeIaj+74vnm42m9sEDwjHK2GINP2JIPiBpnmDMQv8PTvdXsIc/yAcrg/7N6bpA6rqI7R+grXPcBd7X/Tolh3hH4izTHKPcv51AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image\"\n        title=\"image\"\n        src=\"/static/3ced1b2df8c525ffaec0ce9aa709fff6/073e9/image.png\"\n        srcset=\"/static/3ced1b2df8c525ffaec0ce9aa709fff6/e9ff0/image.png 180w,\n/static/3ced1b2df8c525ffaec0ce9aa709fff6/f21e7/image.png 360w,\n/static/3ced1b2df8c525ffaec0ce9aa709fff6/073e9/image.png 719w\"\n        sizes=\"(max-width: 719px) 100vw, 719px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>글이 매우 복잡하고 깁니다. 양해 부탁드립니다.</p>\n</blockquote>\n<blockquote>\n<p>틀린 정보나 이해가 가지 않는 부분은 댓글 남겨주시면 참고하겠습니다.</p>\n</blockquote>\n<h3 id=\"handlermapping의-역할\" style=\"position:relative;\"><a href=\"#handlermapping%EC%9D%98-%EC%97%AD%ED%95%A0\" aria-label=\"handlermapping의 역할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HandlerMapping의 역할</h3>\n<p>Spring MVC에 대해서 공부하던 중, <code class=\"language-text\">HandlerMapping</code>이 request를 처리하기에 적절한 handler를 찾아온다는 설명을 들었다.\r\n좀 더 찾아보니 <em><code class=\"language-text\">HandlerMapping</code>은 <strong>request의 URL과 매칭되는 handler</strong>를 선택하는 역할을 수행한다</em> 는 것을 보았다.</p>\n<p>request의 URL만 보고 어떻게 찾아온다는 것일까? 그리고 <em>찾아진</em> handler는 method인데 어떠한 방식으로 가져온다는 것일까?</p>\n<p>한가지만 기억하고 가자.\r\n<strong>HandlerMapping은 원하는 handler를 찾아오는 역할을 수행한다.</strong></p>\n<h3 id=\"spring-mvc-request-flow\" style=\"position:relative;\"><a href=\"#spring-mvc-request-flow\" aria-label=\"spring mvc request flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring MVC Request flow</h3>\n<p><code class=\"language-text\">HandlerMapping</code>의 역할에 대해서 살펴보기 전에 Spring MVC에서 request가 어떠한 순서로 처리되는지 먼저 보아야 한다.\r\n<img src=\"https://images.velog.io/images/hsw0194/post/8e1df081-c5d5-4c7c-8a33-699b3d6f6e9e/image.png\" alt=\"처리 순서\"></p>\n<ol>\n<li>먼저 <code class=\"language-text\">front-controller</code>의 역할을 하는 <code class=\"language-text\">DispatcherServlet</code>이 request를 받는다.</li>\n<li><strong><code class=\"language-text\">DispatcherServlet</code>은 적절한 controller를 선택하는 일을 <code class=\"language-text\">HandlerMapping</code>에게 요청한다.</strong></li>\n<li><strong><code class=\"language-text\">HandlerMapping</code>은 적합한 controller를 선택한다.</strong></li>\n<li><code class=\"language-text\">DispatcherServlet</code>은 선택된 controller의 비즈니스 로직 실행 작업을 <code class=\"language-text\">HandlerAdapter</code>에게 위임한다.</li>\n<li><code class=\"language-text\">HandlerAdpater</code>가 controller의 비즈니스 로직을 호출하고 결과를 <code class=\"language-text\">ModelAndView</code> 객체에 담아서 <code class=\"language-text\">DispatcherServlet</code>이 에게 return한다.</li>\n<li><code class=\"language-text\">DispatcherServlet</code>이 <code class=\"language-text\">ViewResolver</code>를 이용하여 결과를 보여줄 View를 가져온다.</li>\n<li>View 객체에게 <code class=\"language-text\">DispatcherServlet</code>이 응답 결과 생성을 요청한다.</li>\n</ol>\n<p>이 긴 과정 속에서 이 글에서 살펴볼 과정은 2,3번이다. Request flow 순서대로 <code class=\"language-text\">HandlerMapping</code>에 대해서 알아볼 것이다.</p>\n<h3 id=\"dispatcherservlet\" style=\"position:relative;\"><a href=\"#dispatcherservlet\" aria-label=\"dispatcherservlet permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DispatcherServlet</h3>\n<p>먼저 <code class=\"language-text\">DispatcherServlet</code>에서 부터 출발해야한다. 상속구조부터 보면,</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DispatcherServlet</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">FrameworkServlet</span>\r\n\t\t\t↓\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FrameworkServlet</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HttpServletBean</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ApplicationContextAware</span>\r\n\t\t\t↓\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HttpServletBean</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HttpServlet</span>\r\n\t\t\t↓\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HttpServlet</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">GenericServlet</span></code></pre></div>\n<p>이렇게 상속구조를 통해 <code class=\"language-text\">DispatcherServlet</code>은 결국 <code class=\"language-text\">HttpServlet</code>을 상속함을 알 수 있다.\r\n그렇기 때문에 <code class=\"language-text\">DispatcherServlet</code>도 <code class=\"language-text\">Servlet</code>의 생명주기와 비슷하게 흘러감을 알 수 있다. (<code class=\"language-text\">init(),doGet(),doPost(),service() 등등</code>)</p>\n<p>실제로 디버깅을 해보면, <code class=\"language-text\">doService</code>가 호출된다. 그 후 <code class=\"language-text\">DispatcherServlet</code>은 <code class=\"language-text\">front-controller</code> 역할을 하기 때문에 <code class=\"language-text\">doDispatch</code>를 호출한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doService</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpServletResponse</span> response<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n\t<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\r\n\t<span class=\"token function\">doDispatch</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\t<span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">doDispatch</code>의 javadoc을 보면 Servlet의 <code class=\"language-text\">HandlerMapping</code>을 순서대로 처리하여 handler를 가져온다고 되어있다.</p>\n<blockquote>\n<p>Process the actual dispatching to the handler. The handler will be obtained by applying the servlet’s HandlerMappings in order. The HandlerAdapter will be obtained by querying the servlet’s installed HandlerAdapters to find the first that supports the handler class.</p>\n</blockquote>\n<p><code class=\"language-text\">doDispatch</code>의 실제 코드를 보면 아래처럼 request에 대해서 handler를 가져오는 <code class=\"language-text\">getHandler</code> 함수를 호출하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doDispatch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpServletResponse</span> response<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n\t<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\r\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n        <span class=\"token comment\">// Determine handler for the current request.</span>\r\n\tmappedHandler <span class=\"token operator\">=</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p><code class=\"language-text\">getHandler</code> 함수는 <code class=\"language-text\">DispatcherServlet</code>의 method로 아래와 같다. 이게 실제로 적절한 handler를 가져오는 방식인데 전혀 감이 안온다. 하나하나 풀이해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Nullable</span>\r\n<span class=\"token keyword\">protected</span> <span class=\"token class-name\">HandlerExecutionChain</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlerMappings <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HandlerMapping</span> mapping <span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlerMappings<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n      <span class=\"token class-name\">HandlerExecutionChain</span> handler <span class=\"token operator\">=</span> mapping<span class=\"token punctuation\">.</span><span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>handler <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> handler<span class=\"token punctuation\">;</span>\r\n      <span class=\"token punctuation\">}</span>\r\n    <span class=\"token punctuation\">}</span>\r\n  <span class=\"token punctuation\">}</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p><code class=\"language-text\">DispathcerServlet</code>은 처음 <code class=\"language-text\">init</code>되는 과정에서 여러가지 <code class=\"language-text\">handlerMapping</code>들을 등록하고 <code class=\"language-text\">List</code>를 통해 <code class=\"language-text\">handlerMappings</code>라는 이름으로 관리하고 있다. <code class=\"language-text\">handelrMappings</code>안에는 여러가지 <code class=\"language-text\">handlerMapping</code>들이 등록되어 있는 것이다.</p>\n</blockquote>\n<p>그러므로 아래 코드는 <em><code class=\"language-text\">DispatcherServlet</code> 안에 <code class=\"language-text\">handlerMapping</code>들이 등록되었다면</em> 이라는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlerMappings<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>등록되어있는 <code class=\"language-text\">HandlerMapping</code>들을 loop 하면서</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HandlerMapping</span> mapping <span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlerMappings<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n</code></pre></div>\n<p><strong><code class=\"language-text\">HandlerMapping</code>들에게 request에 맞는 handler를 가져오게하고,가져왔다면 그 handler를 return</strong>하는것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">  <span class=\"token class-name\">HandlerExecutionChain</span> handler<span class=\"token operator\">=</span>mapping<span class=\"token punctuation\">.</span><span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>handler<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token keyword\">return</span> handler<span class=\"token punctuation\">;</span></code></pre></div>\n<p>핵심 부분은 <strong><code class=\"language-text\">HandlerMapping</code>에게 request에 맞는 handler를 가져오는</strong> 부분이다. 이게 궁금해서 이 먼 길을 돌아온 것이다.</p>\n<p><code class=\"language-text\">DispatcherServlet</code>부분의 내용을 정리하자면,\r\n1.<code class=\"language-text\">doService</code>이 호출된다.\r\n2.<code class=\"language-text\">doService</code>내에서 <code class=\"language-text\">doDispatch</code>가 호출된다.\r\n3.<code class=\"language-text\">doDispatch</code>내에서 <code class=\"language-text\">getHandler</code>가 호출된다.\r\n4.<code class=\"language-text\">getHandler</code>내에서 등록된 <code class=\"language-text\">HandlerMapping</code> 중에서 request에 걸맞는 handler를 가져온다.</p>\n<blockquote>\n<p>이제 거의 다왔다.</p>\n</blockquote>\n<h3 id=\"handlermapping이-handler를-가져오는-과정\" style=\"position:relative;\"><a href=\"#handlermapping%EC%9D%B4-handler%EB%A5%BC-%EA%B0%80%EC%A0%B8%EC%98%A4%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"handlermapping이 handler를 가져오는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HandlerMapping이 handler를 가져오는 과정</h3>\n<p><code class=\"language-text\">HandlerMapping</code>은 <code class=\"language-text\">interface</code>로 함수의 선언부만 가지고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">HandlerMapping</span> <span class=\"token punctuation\">{</span>\r\n\t<span class=\"token class-name\">HandlerExecutionChain</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>실제로 handler를 가져오는 <code class=\"language-text\">getHandler</code>는 추상 클래스인 <code class=\"language-text\">AbstractHandlerMapping</code>에 정의되어 있다.\r\n우리가 흔히 아는 <code class=\"language-text\">RequestMappingHandlerMapping,SimpleUrlHandlerMapping</code> 같은 것들의 부모(<em>바로 윗단계는 아니지만</em>)가 <code class=\"language-text\">AbstratHandlerMapping</code>이다.</p>\n<p>아래는 <code class=\"language-text\">AbstractHandlerMapping</code>의 <code class=\"language-text\">getHandler</code> 코드이다.\r\n<code class=\"language-text\">getHandlerInternal</code>을 통해서 handler을 찾아오고, <code class=\"language-text\">HandlerExecutionChain</code>을 return하는데,우리가 원하는건 handler를 찾아오는 방식이므로 <code class=\"language-text\">getHandlerInternal</code>을 봐야겠다.</p>\n<blockquote>\n<p><code class=\"language-text\">HandlerExecutionChain</code>은 간단하게 handler와 handler interceptor들을 모아놓은 것이다.\r\nHandler execution chain, consisting of handler object and any handler interceptors.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">HandlerExecutionChain</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token class-name\">Object</span> handler <span class=\"token operator\">=</span> <span class=\"token function\">getHandlerInternal</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n  <span class=\"token class-name\">HandlerExecutionChain</span> executionChain <span class=\"token operator\">=</span> <span class=\"token function\">getHandlerExecutionChain</span><span class=\"token punctuation\">(</span>handler<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n  <span class=\"token keyword\">return</span> executionChain<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">getHandlerInternal</code>은 <code class=\"language-text\">AbstractHandlerMapping</code>을 상속한 <code class=\"language-text\">AbstractHandlerMethodMapping</code>에 정의되어 있다.\r\n<code class=\"language-text\">AbstractHandlerMethodMapping</code>은 복잡하지만 이런 구조를 가지고 있다.\r\n<img src=\"https://images.velog.io/images/hsw0194/post/3753e0fe-6506-4414-9ee4-c41dc849a312/image.png\" alt=\"\"></p>\n<p>아래는 <code class=\"language-text\">getHandlerInternal</code>의 코드다. 이번에도 차근차근 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractHandlerMethodMapping</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractHandlerMapping</span> <span class=\"token punctuation\">{</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n<span class=\"token comment\">// Look up a handler method for the given request.</span>\r\n<span class=\"token keyword\">protected</span> <span class=\"token class-name\">HandlerMethod</span> <span class=\"token function\">getHandlerInternal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token class-name\">String</span> lookupPath <span class=\"token operator\">=</span> <span class=\"token function\">getUrlPathHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLookupPathForRequest</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mappingRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">acquireReadLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token class-name\">HandlerMethod</span> handlerMethod <span class=\"token operator\">=</span> <span class=\"token function\">lookupHandlerMethod</span><span class=\"token punctuation\">(</span>lookupPath<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>handlerMethod <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> handlerMethod<span class=\"token punctuation\">.</span><span class=\"token function\">createWithResolvedBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n  <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mappingRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">releaseReadLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>먼저 javadoc을 보면 <em>주어진 request에 대한 handler method를 찾습니다.</em> 라고 되어있다. 동작원리의 핵심적인 부분인것이다.</p>\n<blockquote>\n<p>Look up a handler method for the given request.</p>\n</blockquote>\n<p><code class=\"language-text\">lookupPath</code>는 현재 servlet mapping 안에서의 검색경로인데, request 요청을 분석해서 얻을 수 있다. 그리고 <strong><code class=\"language-text\">mappingRegistry</code>에 대한 ReadLock을 가져오고 있다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> lookupPath <span class=\"token operator\">=</span> <span class=\"token function\">getUrlPathHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLookupPathForRequest</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mappingRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">acquireReadLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">lookupPath</code>를 바탕으로 <code class=\"language-text\">lookupHandlerMethod</code>를 통해서 <strong>적절한 <code class=\"language-text\">handlerMethod</code>를 가져온 후 return 한다</strong>, 이 <code class=\"language-text\">handlerMethod</code>가 바로 우리가 직접 Controller 안에 정의한 함수인것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token class-name\">HandlerMethod</span> handlerMethod <span class=\"token operator\">=</span> <span class=\"token function\">lookupHandlerMethod</span><span class=\"token punctuation\">(</span>lookupPath<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>handlerMethod <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> handlerMethod<span class=\"token punctuation\">.</span><span class=\"token function\">createWithResolvedBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>정리해보자면, <code class=\"language-text\">DispatcherServlet</code> 함수 안에서 <code class=\"language-text\">handlerMapping</code>이 여러 과정을 거쳐서 <strong>적절한 <code class=\"language-text\">handlerMethod</code></strong> 를 가져온다는것은 알 수 있다.</p>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/96c33f73-1c61-47c2-920f-965fdadc0bff/Untitled%20Diagram%20(1).jpg\" alt=\"\"></p>\n<p><strong>그러나 궁금증이 더 남아있다. url에 해당하는 적절한 method를 구별하는 방법과, method를 가져오는 것이 여전히 궁금하다.</strong>\r\n각각 <strong>MappingRegistry</strong>와 <strong>Reflection</strong>이 답이다.</p>\n<p>나머지 궁금증은 2편에서 마저 다루도록 한다.</p>\n<h3 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h3>\n<p><a href=\"https://bgpark.tistory.com/72\">Interceptor 사용법</a> : Request flow에 대해서 잘 정리되어 있었다.\r\n<a href=\"https://docs.spring.io/spring-framework/docs/4.3.2.RELEASE_to_4.3.3.RELEASE/Spring%20Framework%204.3.3.RELEASE/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.html\">AbstractHandlerMethodMapping javadoc</a>\r\n<a href=\"https://docs.spring.io/spring-framework/docs/4.3.2.RELEASE_to_4.3.3.RELEASE/Spring%20Framework%204.3.3.RELEASE/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.MappingRegistry.html\">MappingReigstry javadoc</a>\r\n<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/LinkedMultiValueMap.html\">LinkedMultiValueMap javadoc</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#handlermapping%EC%9D%98-%EC%97%AD%ED%95%A0\">HandlerMapping의 역할</a></li>\n<li><a href=\"#spring-mvc-request-flow\">Spring MVC Request flow</a></li>\n<li><a href=\"#dispatcherservlet\">DispatcherServlet</a></li>\n<li><a href=\"#handlermapping%EC%9D%B4-handler%EB%A5%BC-%EA%B0%80%EC%A0%B8%EC%98%A4%EB%8A%94-%EA%B3%BC%EC%A0%95\">HandlerMapping이 handler를 가져오는 과정</a></li>\n<li><a href=\"#%EC%B6%9C%EC%B2%98\">출처</a></li>\n</ul>\n</div>","frontmatter":{"date":"June 09, 2021","title":"Spring MVC - HandlerMapping의 동작방식 이해하기 1편","categories":"Spring","author":"weasel","emoji":"📓"},"fields":{"slug":"/how-spring-handler-mapping-works-1/"}},"prev":{"id":"028bb303-76a6-5163-895b-4b535c55cf50","html":"<p><img src=\"/9146a4d3298760c2e7e49595184e1975/spring-logo-9146a4d3298760c2e7e49595184e1975.svg\" alt=\"\"></p>\n<blockquote>\n<p>본 글은 <a href=\"https://dimitr.im/spring-interface\">Do I need an interface with Spring boot?</a>을 번역한 글입니다.</p>\n</blockquote>\n<blockquote>\n<p>잘 쓰여진 글을 정리 하는 겸 한글로 공유하고 싶어서 번역했습니다.</p>\n</blockquote>\n<h2 id=\"들어가면서\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B4%EC%84%9C\" aria-label=\"들어가면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가면서</h2>\n<p>Spring boot를 사용하다보면, 종종 <code class=\"language-text\">service</code> (<code class=\"language-text\">@Service</code> annotation을 붙인 bean)을 사용하게 된다. 인터넷 상의 많은 예시에서, 사람들이 <code class=\"language-text\">service</code>들을 위해서 <code class=\"language-text\">interface</code>를 사용하는 걸 볼 수 있을것이다. 예를 들어서 , 우리가 todo 어플리케이션을 만든다고 할때, <code class=\"language-text\">TodoService</code>라는 <code class=\"language-text\">interface</code>와 <code class=\"language-text\">TodoServiceImpl</code>이라는 구현체를 만들때가 있다.</p>\n<p>이 포스트에서, 우리는 왜 그런 것을 하는지와 필요한가에 대해서 알아볼 것이다.</p>\n<h2 id=\"짧은-결론은\" style=\"position:relative;\"><a href=\"#%EC%A7%A7%EC%9D%80-%EA%B2%B0%EB%A1%A0%EC%9D%80\" aria-label=\"짧은 결론은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>짧은 결론은</h2>\n<p>짧은 결론은 꽤나 간단하다. ** <code class=\"language-text\">interface</code>를 만들 필요 없다. ** <code class=\"language-text\">service</code>를 만든다고 하면, class의 자체의 이름을 <code class=\"language-text\">TodoService</code>라고 하고 <code class=\"language-text\">autowire</code>를 통해서 bean들에 주입하면 된다. 예를 들어서 이런 코드가 있다고 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// TODO: Implement</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token annotation punctuation\">@Component</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">;</span>\r\n    \r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>service <span class=\"token operator\">=</span> service<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span> </code></pre></div>\n<p>위에 있는 예시는 <code class=\"language-text\">@Autowired</code>를 이용한 field injection을 사용하던 생성자 주입을 사용하던간에 <strong>작동</strong>할 것이다.</p>\n<h2 id=\"그럼-왜-신경써야할까\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%99%9C-%EC%8B%A0%EA%B2%BD%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C\" aria-label=\"그럼 왜 신경써야할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그럼 왜 신경써야할까?</h2>\n<p>만약, 우리가 그게 필요하지 않다면… 왜 그런 방식(<code class=\"language-text\">inteface</code>를 이용한 방식)을 종종 쓰곤 할까? 음, 첫 번째 이유는 사실 좀 역사적인것이다. 하지만 그걸 살펴보기 전에 , Spring에서 annotation이 어떻게 작동하는지를 설명해야만 한다.</p>\n<p>만약 <code class=\"language-text\">@Cacheable</code>같은 annotation을 사용한다고 하면, cache에서 결과를 얻을것이라고 예상할 수 있다. Spring에서 그것이 작동되는 방식은 bean들을 위한 proxy를 만들고 그 proxy들에 필요한 로직을 추가해주는것이다. 원래 스프링은 JDK dynamic proxies를 사용했다. 이 dynamic proxies는 오직 <code class=\"language-text\">interface</code>들만을 위해서 만들어졌고, 이것이 예전에는 <code class=\"language-text\">interface</code>를 작성해줘야 했던 이유다.</p>\n<p>그러나, 10여 년 전부터 , Spring이 CGLIB proxying도 지원하기 시작했다. 이 proxy들은 <strong>별도의</strong> <code class=\"language-text\">interface</code>를 필요로 하지 않는다. 심지어 Spring 3.2 버전부터는 CGLIB가 Spring에 내장되어 있어서 별도로 추가해줄 필요도 없다.</p>\n<h2 id=\"느슨한-결합\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9\" aria-label=\"느슨한 결합 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>느슨한 결합</h2>\n<p>아마 두 번째 이유는 두 class 간의 느슨한 결합을 만들기 위해서 일 것이다. <code class=\"language-text\">interface</code>를 사용함으로써, <code class=\"language-text\">service</code>에 의존하는 class는 더 이상 <code class=\"language-text\">service</code>의 구현에 의존하지 않게 된다. 이것이 <code class=\"language-text\">service</code>를 독립적으로 사용할 수 있게 해준다. 예를 들어서 이런 코드가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token annotation punctuation\">@Service</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoServiceImpl</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// TODO: Implement</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token annotation punctuation\">@Component</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">;</span>\r\n    \r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>service <span class=\"token operator\">=</span> service<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러나 위의 예시에서, 개인적인 의견으로 <code class=\"language-text\">TodoFacade</code>와 <code class=\"language-text\">TodoServiceImpl</code>이 함께 한다고 생각한다. 여기서 <code class=\"language-text\">interface</code>를 추가하는건 추가적인 복잡도를 늘릴 수 있다. 개인적으로, 그만한 가치는 없어 보인다.</p>\n<h2 id=\"여러-방식의-구현\" style=\"position:relative;\"><a href=\"#%EC%97%AC%EB%9F%AC-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84\" aria-label=\"여러 방식의 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>여러 방식의 구현</h2>\n<p>느슨한 결합이 유용한 부분은 여러 가지 구현체를 가질 때이다. 예를 들어서 TodoService가 두 가지 구현체를 가진다고 해보자. 하나는 todo 리스트를 메모리에서 가져오는 것이고, 하나는 DB와 같은 곳에서 가져오는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token annotation punctuation\">@Service</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InMemoryTodoServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// TODO: Implement</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token annotation punctuation\">@Service</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DatabaseTodoServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// TODO: Implement</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token annotation punctuation\">@Component</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">;</span>\r\n    \r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>service <span class=\"token operator\">=</span> service<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런 경우에선 느슨한 결합이 매우 유용한데, <code class=\"language-text\">TodoFacade</code>가 todo가 메모리에 저장되어 있는지 DB에 저장되어 있는지 알 필요 없기 때문이다. 그건 <code class=\"language-text\">Facade</code>의 책임이 아니라 어플리케이션 설정의 책임이다.</p>\n<p>원하는 것에 따라서 구현방식은 달라진다. 만약에 <code class=\"language-text\">TodoFacade</code>가 모든 구현체를 호출해야 한다면, <code class=\"language-text\">collection</code>을 주입해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Component</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">TodoService</span><span class=\"token punctuation\">></span></span> services<span class=\"token punctuation\">;</span>\r\n    \r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TodoService</span> services<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>services <span class=\"token operator\">=</span> services<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약 구현체 중에 하나가 99%의 상황에서 사용되고 나머지들은 아주 특수한 경우에만 사용된다면, <code class=\"language-text\">@Primary</code>를 사용해라.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Primary</span>\r\n<span class=\"token annotation punctuation\">@Service</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DatabaseTodoServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// TODO: Implement</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">@Primary</code>를 사용함으로써, Spring container에게 <code class=\"language-text\">TodoService</code>에 의존성 주입을 해야할때, 이 구현체를 사용하라고 알려주는 것이다. 만약 다른 걸 사용해야 한다면, <code class=\"language-text\">@Qualifier</code>를 사용하거나 특정 구현체를 주입함으로써 <strong>명시적으로</strong> 설정해야 한다. 개인적으로 난 이런 방식을 분리된 <code class=\"language-text\">@Configuration</code> class에서 사용하는데, 그렇지 않으면 , <code class=\"language-text\">TodoFacade</code>를 또 다시 구현체에 관한 정보들로 오염시키기 때문이다.</p>\n<p>예시 코드를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoConfiguration</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token annotation punctuation\">@Bean</span>\r\n    <span class=\"token comment\">// Using @Qualifier</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token function\">todoFacade</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Qualifier</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"inMemoryTodoService\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    \r\n    <span class=\"token annotation punctuation\">@Bean</span>\r\n    <span class=\"token comment\">// Or by using the specific implementation</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token function\">todoFacade</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InMemoryTodoService</span> service<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"제어의-역전\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84\" aria-label=\"제어의 역전 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제어의 역전</h2>\n<p>느슨한 결합의 또 다른 방식은 <strong>IoC</strong> 혹은 <strong>제어의 역전</strong>이다. 개인적으로 서로에게 의존하는 여러 가지 module을 사용할 때 제어의 역전이 유용했다. 예를 들어서 <code class=\"language-text\">OrderService</code>와 <code class=\"language-text\">CustomerService</code>가 있다고 해보자. Customer는 자신의 profile을 삭제할 수 있고 그때 pending 상태의 order들은 취소되어야 한다. <code class=\"language-text\">interface</code> 없이 구현했다면, 이런 방식으로 할것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderService</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">cancelOrdersForCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// TODO: implement</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token annotation punctuation\">@Service</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomerService</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">OrderService</span> orderService<span class=\"token punctuation\">;</span>\r\n    \r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CustomerService</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">OrderService</span> orderService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>orderService <span class=\"token operator\">=</span> orderService<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    \r\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">deleteCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        orderService<span class=\"token punctuation\">.</span><span class=\"token function\">cancelOrdersForCustomer</span><span class=\"token punctuation\">(</span>customerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token comment\">// TODO: implement</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 한다면, 상황은 매우 나빠질 수 있다. 어플리케이션 내부의 domain들이 모두 결합되게 되고, 결과적으로 강하게 결합된 어플리케이션을 만들게 될것이다.</p>\n<p>그러는 대신에, <code class=\"language-text\">CustomerDeletionListener</code>라는 <code class=\"language-text\">interface</code>를 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">CustomerDeletionListener</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">void</span> <span class=\"token function\">onDeleteCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token annotation punctuation\">@Service</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomerService</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CustomerDeletionListener</span><span class=\"token punctuation\">></span></span> deletionListeners<span class=\"token punctuation\">;</span>\r\n    \r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CustomerService</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CustomerDeletionListener</span><span class=\"token punctuation\">></span></span> deletionListeners<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deletionListeners <span class=\"token operator\">=</span> deletionListeners<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    \r\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">deleteCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        deletionListeners<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>listener <span class=\"token operator\">-></span> listener<span class=\"token punctuation\">.</span><span class=\"token function\">onDeleteCustomer</span><span class=\"token punctuation\">(</span>customerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token comment\">// TODO: implement</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token annotation punctuation\">@Service</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderService</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">cancelOrdersForCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// TODO: implement</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token annotation punctuation\">@Component</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderCustomerDeletionListener</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">CustomerDeletionListener</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">OrderService</span> orderService<span class=\"token punctuation\">;</span>\r\n    \r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">OrderCustomerDeletionListener</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">OrderService</span> orderService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>orderService <span class=\"token operator\">=</span> orderService<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    \r\n    <span class=\"token annotation punctuation\">@Override</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onDeleteCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        orderService<span class=\"token punctuation\">.</span><span class=\"token function\">cancelOrdersForCustomer</span><span class=\"token punctuation\">(</span>customerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>예시를 보면, 제어의 역전이 일어난 것을 볼 수 있다. 첫 번째 예시에서 우리가 <code class=\"language-text\">OrderService</code> 안에 있는 <code class=\"language-text\">cancelOrderForCustomer()</code>를 바꾸면, <code class=\"language-text\">CustomerService</code> 역시 바뀌어야 한다. 이 말은 <code class=\"language-text\">OrderService</code>가 제어되고 있다는 것을 말한다.</p>\n<p>두 번째 예시에서는 <code class=\"language-text\">OrderService</code>가 제어되고 있지 않다. 우리가 <code class=\"language-text\">cancelOrderForCustomer()</code>를 변화시키면, 다른 module의 일부인 오직 <code class=\"language-text\">OrderCustomerDeletionListener</code>만 바뀌어야 한다. 이것은 <code class=\"language-text\">CustomerService</code>가 제어하고 있음을 말한다. 또, 두 <code class=\"language-text\">service</code>들은 느슨하게 결합되어 있기 때문에, 하나가 다른 하나에 직접적으로 의존하고 있지 않다.</p>\n<p>비록 두 번째 방법이 복잡도를 더 늘리긴 하지만 (<code class=\"language-text\">class</code>와 <code class=\"language-text\">interface</code>가 각각 한개씩 늘었으니) domain들이 서로 결합되지 않게 해준다. 리팩토링 하기가 쉬워지는 것이다. 이 <code class=\"language-text\">listener</code>는 <code class=\"language-text\">event-driven</code>한 구조로 리팩토링 될 수 있다. domain-driven modular design이나 MSA같은 구조로 리팩토링하기 쉽게 해주는 것이다.</p>\n<h2 id=\"test\" style=\"position:relative;\"><a href=\"#test\" aria-label=\"test permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Test</h2>\n<p>마지막으로 말하고 싶은 건 테스트다. 몇몇 사람들은 dummy 구현체를 가지기 위해서 (여러 구현체를 가질 수 있으니) <code class=\"language-text\">interface</code>가 필요하다고 주장하곤 한다. 하지만 <strong>Mockito</strong>같은 mocking 라이브러리가 이 문제를 해결해 준다.</p>\n<p>단위 테스트를 작성할 때, <code class=\"language-text\">MockitoExtension</code>을 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@ExtendWith</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MockitoExtension</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacadeTest</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoFacade</span> facade<span class=\"token punctuation\">;</span>\r\n    <span class=\"token annotation punctuation\">@Mock</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">;</span>\r\n    \r\n    <span class=\"token annotation punctuation\">@BeforeEach</span>\r\n    <span class=\"token keyword\">void</span> <span class=\"token function\">setUp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>facade <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    \r\n    <span class=\"token comment\">// TODO: implement tests</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 방법은 <code class=\"language-text\">service</code>가 무엇을 하는지 몰라도 <code class=\"language-text\">facade</code>를 적절히 테스트할 수 있게 해준다. <code class=\"language-text\">Mockito.when()</code>을 사용함으로써 <code class=\"language-text\">service</code> mock이 무엇을 반환하게 하는지 제어할 수 있고, <code class=\"language-text\">Mockito.verfiy()</code>를 사용함으로써 특정 method가 호출되었는지 확인할 수 있다.\r\n예시 코드다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\r\n<span class=\"token keyword\">void</span> <span class=\"token function\">findAll_shouldUseServicefindAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token class-name\">Todo</span> todo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Todo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token function\">when</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">.</span><span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenReturn</span><span class=\"token punctuation\">(</span>todo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token function\">assertThat</span><span class=\"token punctuation\">(</span>facade<span class=\"token punctuation\">.</span><span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">containsOnly</span><span class=\"token punctuation\">(</span>todo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token function\">verify</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>심지어 Spring container를 필요로 하는 통합 테스트를 작성할때도,<code class=\"language-text\">@MockBean</code> annotation을 이용해서 bean들을 mock할 수 있다. 실제 구현체가 있는 package를 탐색하지 않게 해라.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@ExtendWith</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SpringExtension</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token annotation punctuation\">@SpringBootTest</span><span class=\"token punctuation\">(</span>classes <span class=\"token operator\">=</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacadeTest</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token annotation punctuation\">@Autowired</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoFacade</span> facade<span class=\"token punctuation\">;</span>\r\n    <span class=\"token annotation punctuation\">@MockBean</span>\r\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러니까 대부분의 경우에서, 테스트 할때 <code class=\"language-text\">interface</code>는 필요하지 않다.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>만약 개인적으로 <code class=\"language-text\">interface</code>를 <code class=\"language-text\">serivce</code>에 사용해야 하냐는 질문을 받는다면, 내 대답은 <strong>아니오</strong>다. 유일한 예외는 제어의 역전을 사용하거나 여러개의 구현체를 신경써야 하는 경우다.</p>\n<p>만약의 경우를 위해서 <code class=\"language-text\">interface</code>를 만드는 게 좋지 않겠냐고 생각할 수 있다. 개인적으로 여전히 <strong>아니오</strong>다. 첫 번째로, “You aren’t going to need it”(YAGNI) 라는 원칙을 믿는다. <em>필요할지도 몰라</em> 라는 이유로 복잡성을 높일 이유는 없는데 , 일반적으로 <strong>필요하지 않기</strong> 때문이다. 두 번째로 필요한 경우라도 전혀 문제 없다. 대부분의 IDE들은 기존의 class에서 method만 추출해서 <code class=\"language-text\">interface</code>를 만들수 있게 해주고, 모든 코드들을 그 <code class=\"language-text\">interface</code>를 사용하게끔 순식간에 만든다.</p>\n<h3 id=\"참고하면-좋은-자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%9E%90%EB%A3%8C\" aria-label=\"참고하면 좋은 자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고하면 좋은 자료</h3>\n<p><a href=\"https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html\">JDK Dynamic Proxy와 CGLIB의 차이점은 무엇일까?</a>\r\n<a href=\"https://jusungpark.tistory.com/23\">퍼사드 패턴</a>\r\n<a href=\"https://swk3169.tistory.com/185\">느슨한 결합 vs 긴밀한 결합</a>\r\n<a href=\"https://medium.com/@gorali/how-mockito-works-7d3a2c77da71\">How Mockito Works?</a>\r\n<a href=\"https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&#x26;blogId=complusblog&#x26;logNo=221163007357&#x26;redirect=Dlog&#x26;widgetTypeCall=true&#x26;directAccess=false\">소프트웨어 개발 3대 원칙 : KISS,YAGNI,DRY</a></p>\n<blockquote>\n<p>스프링 부트에 <code class=\"language-text\">interface</code>가 필요한가에 대해서는 당연히 <strong>YES</strong>지만 이 글에선 <strong><code class=\"language-text\">service</code>에 <code class=\"language-text\">interface</code></strong> 가 필요한지, 정확히 말하면 <code class=\"language-text\">service</code>의 구현체가 필요한지에 대해서 논하고 있습니다.</p>\n</blockquote>\n<blockquote>\n<p>프로젝트를 시작하면서 Spring boot에서 구현체와 인터페이스를 구분해야하는지 고민이 많았는데 꽤나 자세하고 명쾌해서 도움이 되었습니다.</p>\n</blockquote>\n<blockquote>\n<p>소프트웨어공학 수업에서 배운 YAGNI를 실제로 보니까 반갑네요. 그냥 무지성으로 외웠는데..</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B4%EC%84%9C\">들어가면서</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A7%A7%EC%9D%80-%EA%B2%B0%EB%A1%A0%EC%9D%80\">짧은 결론은</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%99%9C-%EC%8B%A0%EA%B2%BD%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C\">그럼 왜 신경써야할까?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9\">느슨한 결합</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%97%AC%EB%9F%AC-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84\">여러 방식의 구현</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84\">제어의 역전</a></p>\n</li>\n<li>\n<p><a href=\"#test\">Test</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></p>\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%9E%90%EB%A3%8C\">참고하면 좋은 자료</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"July 15, 2021","title":"Spring Boot에서 interface를 사용해야 할까? (Do I need an interface with Spring boot?)","categories":"Spring","author":"weasel","emoji":"📓"},"fields":{"slug":"/do-i-need-an-interface-with-spring-boot/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.github.io","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/programmers-build-race-road/","nextSlug":"/how-spring-handler-mapping-works-1/","prevSlug":"/do-i-need-an-interface-with-spring-boot/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}