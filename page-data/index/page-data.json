{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"8dc426c1-6ea9-5b2f-9546-c7694d04fcb3","excerpt":"TCP 신뢰성 있는 데이터 전송을 지원하는 연결 지향형 전송계층 프로토콜로 3 way handshake로 연결을 수립하고 , 4 way handshake로 연결을 해제한다. 혼잡 제어, 흐름 제어, 오류 제어등을 통해 신뢰성을 보장하지만 이것때문에 UDP와 비교해서 속도가 느리다. 또 SEQ 넘버와 ACK 넘버를 통해서 데이터 흐름 속에서 데이터들의 순서를 파악할 수 있기 때문에 신뢰성이 높아진다. 인터넷은 신뢰성을 갖추지 못하기 때문에 종단간의 신뢰성 있는 Byte Stream을 전송하도록 설계되었다. 연결을 유지하며 1:1 통신을 한다. 그렇기에 브로드캐스팅과 같은 시스템에선 적합하지 않다.  TCP Header TCP 연결 과정 TCP는 통신을 시작하기전에 연결 수립이 필수적이다. 이것을 통해서 상대방과의 세션을 수립하여 통신의 정확성을 획득할 수 있다. 클라이언트는 서버에 접속을 요청하고 서버는 요청을 수락하는 ack와 flag가 설정된 패킷을 클라이언트에게 발송한다. 클라…","frontmatter":{"categories":"네트워크","title":"TCP와 UDP","date":"February 05, 2022"},"fields":{"slug":"/tcp-and-udp/"}}},{"node":{"id":"900d1f47-ef6d-5598-b1bb-f6ffd1f5c715","excerpt":"Stack 선형자료구조의 일종으로 LIFO의 특성을 가지고 있다. 가장 처음 들어간 원소가 가장 나중에 접근 가능 하고, 다시 말해서 호출 시에 가장 최근의 원소에 접근 할 수 있다. 의 공간복잡도를 가진다. 링크드 리스트를 이용한 구현과 배열을 이용한(정확히는 Dynamic Array) 두가지 버전이 있다. 링크드 리스트는 일관적인 시간복잡도 를 보여주는 대신에 추가적인 메모리 사용량(Node 구조를 유지하는데 드는)과 메모리 할당에 추가적인 비용이 들 수 있다. 조회 : Top에 있는 원소를 조회할때는 , 하지만 특정한 데이터를 찾고자 할때는 이다. 삽입 : 링크드 리스트를 이용한 구현에서는 단순히 기존의 Top 원소를 새 원소의  로 연결시켜주고  의 포인터에 새로운 원소를 연결시켜주면 되기 때문에 이다. 배열을 이용한 구현에서도 특정 상황(Dynamic array의 팽창)을 제외하고는 이니 이다. 삭제 : 링크드 리스트와 배열 모두 이다. 활용 Stack Usage : JV…","frontmatter":{"categories":"자료구조","title":"Stack과 Queue","date":"February 05, 2022"},"fields":{"slug":"/stack-and-queue/"}}},{"node":{"id":"37b121af-aaea-5b5c-96bd-dbe71d964439","excerpt":"Array 논리적 저장순서와 물리적 저장순서가 일치한다. 다시 말해서  와 다음에 오는  는 물리적으로 연결되어 있다.\n하지만, 하나의 Array의 크기가 너무 커 하나의 page(혹은 frame) 안에 다 못들어오는 경우에는 virtual adress는 연속적으로 이어져있지만, physical adress에서도 그렇다는 보장은 없다. 💡 하지만 physical adress와 virtual address에 관한 문제는 OS가 처리할 일이고 프로그래머에게 보이지 않는 추상계층이기에 우리가 깊게 생각할 필요는 없다고 생각한다. 또, 한번 사이즈가 정해지면 변할 수 없다. 이를 해결하는 방법이 Dynamic Array다. 조회 : 인덱스를 기반으로 한 접근이 가능하다. 인덱스를 알고 있다면 의 시간 내에 접근이 가능한데 , 이것을 Random Access라고 한다. 삽입 : Array의 특정 위치에 삽입을 할때는 원소를 넣고 끝나는 것이 아니라, 기존의 원소들을 shift 해주는 비용이…","frontmatter":{"categories":"자료구조","title":"Array와 Linked List","date":"February 04, 2022"},"fields":{"slug":"/array-and-linked-list/"}}},{"node":{"id":"970ad7e7-c529-5911-b5d5-ca08c1dcb821","excerpt":"Java 7의 JVM \n기존의 Java 7 까지의 Non Heap Area였던 Permanent Generation이 Native 영역인 Metaspace로 바뀌었다. 기존의 Permanent 영역에는 아래와 같은 정보들이 저장되었다. Class의 메타데이터 (바이트코드 포함) Method의 메타데이터 static 객체, static 상수 상수화된 String Object Class와 관련된 배열 객체 메타데이터 JVM 내부적인 객체들과 JIT의 최적화 정보 OOM 문제점 이런 많은것들이 PermG안에 있다보니 , String Constant Pool, static object, Class 메타 데이터들이 쌓여 OOM이 발생하곤 했다. PermG는 시작할때부터 크게 잡지 않는 이상 리사이징이 되지 않아 그런 문제가 발생하곤 했다. 좋은 글 Java 8의 JVM \nJava 8에서부턴 PermG 영역을 삭제하고 Metaspace 영역을 추가해 Native 메모리의 영역으로 이동시켰다.…","frontmatter":{"categories":"Java","title":"JVM의 Java 8에서의 변화","date":"January 13, 2022"},"fields":{"slug":"/jvm-change-in-java8/"}}},{"node":{"id":"a0255f2f-f9e3-5e68-8b8b-192aaa664f95","excerpt":"내부적으로 배열을 사용하여 조회,삽입,삭제 모두 안에 수행하기 위한 특별한 자료구조다. 배열의 인덱스를 유일하게(혹은 그에 가깝게) 지정하기 위해서 데이터와 연관된 고유한 숫자를 만들어낸 후 그것을 인덱스로 사용한다. 또 일반적으로 순서를 보장하지 않기 때문에, 순서, 관계가 있는 목적에는 적합하지 않다. Hash funciton 데이터에 연관된 고유한 값을 만들기 위해서 해시 함수를 사용한다. 이 해시 함수를 통해서 나온 결과값을 해시 값(혹은 해쉬 코드,해쉬)라고 하고 이것을 이용해 데이터에 대한 접근 연산을 수행한다. 가장 많이 쓰이는 해시 함수는 나머지 연산(modulo)를 이용한다. 키  를 어떤 정해진 수  로 나눈 나머지를  를 저장하는 버킷의 인덱스로 사용하는 것이다.\n→  일반적으로  는 적절히 큰 소수(prime number)를 사용하는데 이유는 다음과 같다. 만약 D를 소수가 아닌 값이라 하면, D의 모든 약수는 자신의 배수가 곧 키값이 된다. 해시충돌이 많이 …","frontmatter":{"categories":"자료구조","title":"Hash Table에 대해서 완전 자세하게 알아보자.","date":"January 10, 2022"},"fields":{"slug":"/hash-table/"}}},{"node":{"id":"52e5803d-bf0b-5f07-aa36-e75d5d721256","excerpt":"일단 프로세스 스케쥴링 알고리즘에 대해서 언급하기 전에, 프로세스의 상태와 Context-Switching에 대해서 알아야 한다. 여러가지 프로세스의 상태를 기반으로 전이(Transition)되며 이를 바탕으로 스케쥴링 알고리즘이 이루어진다. 프로세스의 상태  프로세스의 상태는 OS에 따라서 개수도 다르고, 명칭도 조금 다르지만, 가장 대표적인 그림은 위의 상태와 같다.  : 프로세스가 생성된 상태이다. 이때는 Readuy Queue 안에 들어 있지 않기 때문에 CPU를 받을 대상이 아니다.  : 프로세스가 CPU를 할당받기 위해 대기하는 상태이다. 보통 Ready Queue 안에 들어와있는 상태라고 얘기한다. 스케쥴링의 대상이 된다.  : 현재 CPU를 할당받아 작업중인 상태다. Single core 시스템에서는 1개다.  : 프로세스가 입출력이나 이벤트가 끝나기를 기다리는 상태이다.  : 프로세스가 종료된 상태다. 단 프로세스 구조체가 사라진 것은 아니다. 그림에서 프로세스의 …","frontmatter":{"categories":"운영체제","title":"프로세스 스케쥴링 알고리즘","date":"December 25, 2021"},"fields":{"slug":"/process-scheduling-algorithm/"}}},{"node":{"id":"d35d9a2d-dc83-5898-a8d1-3b9f7d2f1a79","excerpt":"프로세스란, 실행중인 프로그램을 의미한다.\n프로그램을 실행하기 위해서는 주소공간,파일,메모리 등이 필요한데 운영체제로부터 이런 것을 할당받은 프로그램을 프로세스라 한다. 프로그램은 어떤 작업을 수행하기 위한 파일로써 정적인 상태이고, 프로세스는 그 작업을 수행하는 동적인 상태다. 프로세스의 메모리 구조 프로세스는 아래 그림과 같은 메모리 구조를 띄고 있다.  프로세스는 각자 본인이 사용하는 메모리 영역과 레지스터 값을 가진다. 프로세스의 메모리 영역은 코드,데이터,힙,스택 영역으로 구성된다. 코드 : 사용자가 작성한 프로그램 함수들의 코드가 기계어 명령 형태로 변경되어 저장되는 공간 데이터 : 전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터를 저장하는 공간 스택 : 함수의 복귀주소와 지역변수,매개변수,반환값을 저장하는 공간. 재귀함수가 반복되거나 지역변수가 너무 많으면 stack overflow 발생. 가변적이다. 힙 : 프로세스 실행 중에 런타임에 할당되는 영역.…","frontmatter":{"categories":"운영체제","title":"프로세스와 쓰레드","date":"December 25, 2021"},"fields":{"slug":"/process-and-thread/"}}},{"node":{"id":"79ae2a8f-01d0-50f4-814c-5192b56de742","excerpt":"도전기? 후기? 어느단어를 써야할지 한참 고민하다가 도전기로 선택했습니다.\n도전기로 선택한 이유는 결과와 상관없이 공채의 모든 과정에서 배운점이 굉장히 많았거든요. 그런면에선 개발자 취준생인 저의 성장기도 맞는 것 같습니다. 글이 굉장히,매우 호흡이 깁니다. 적당히 스크롤 내려가면서 스킵하면서 읽어주세요.. 공채 얘기만 궁금하시면 뜬금없는 블라인드 공채 목차쯤부터 보시면 됩니다. 조금 늦은 시작 저는 서울 소재 H대학교에서 컴퓨터계열을 전공하다 3학년을 수료하고 20년도 초에 사회복무요원으로 입대하게 되었습니다.\n여러가지 사정들로 군 복무가 굉장히 늦어졌고, 3학년을 마칠때까지 아직 진로에 대해서 확실히 정하지 못했습니다. 분명 개발을 좋아하고 적당히 실력도 있었지만, 그만큼 컴퓨터공학에 대한 열정도 있어서 진학 후 연구도 하고 싶었습니다. 개발자와 진학 중 하나를 선택하기 위해서는 일단 군 문제 먼저 해결해야한다고 생각해 일단 복무를 시작했습니다. 그러던 중, 5월쯤 취업한 친한…","frontmatter":{"categories":"회고","title":"3학년의 2022 카카오 블라인드 공채 도전기","date":"December 16, 2021"},"fields":{"slug":"/junior-student-challege-to-kakao-2022/"}}},{"node":{"id":"b98e3e53-8195-5969-aa57-8c541f9543d1","excerpt":"GC를 수행하는 Garabage Collector는 아래와 같은 일을 한다. 메모리 할당 사용 중인 메모리 인식 미사용 메모리 인식 Stop-the-World 자바 애플리케이션은 GC 실행시 GC 실행 스레드를 제외한 모든 스레들르 멈추고, GC 완료 후 다시 스레드들을 실행 상태로 변경 Stop the World는 모든 애플리케이션 스레드들의 작업이 멈추는 상태 어떤 GC 알고리즘을 사용해도 Stop-the-World는 불가피하며 대개의 GC 튜닝이란 이 Stop-the-World 시간을 줄이는 것이다. 전제 가비지 컬렉터는 두가지 전제 조건 하에서 만들어졌다. 대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다. 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다. 이것을 ‘weak generational hypothesis’라고 하는데 이것을 살리기 위해서 Young 영역과 Old 영역으로 나누었다. Young 영역 (Young Generation 영역…","frontmatter":{"categories":"Java","title":"Java의 알쏭달쏭한 GC","date":"November 05, 2021"},"fields":{"slug":"/java-gc/"}}},{"node":{"id":"9f73b4bb-d5a7-5501-955c-6499d6b7bb91","excerpt":"MappingRegistry 는 아까 살펴본 의 내부 클래스다. 는 handler method에 대한 모든 mapping을 유지 관리하고 을 수행하는 method를 가지고 있고 동시성을 가진 접근을 가능하게 해주는 레지스트리다. A registry that maintains all mappings to handler methods, exposing methods to perform lookups and providing concurrent access. Package-private for testing purposes. 가장 중요한 부분이 handler method에 대한 모든 mapping을 유지 관리하고 을 수행하는 method를 가지고 있다는 것이다.  안에서  자료구조를 가진 멤버 변수들이 있다. 그 중에서이라는 자료구조를 사용한다. 이건 한개의 key에 여러 value들을 저장하는 을 으로 감싼 자료구조로 Spring이 만든 자료구조다. 은 의 자료구조인데, key는 을 …","frontmatter":{"categories":"Spring","title":"Spring MVC - HandlerMapping의 동작방식 이해하기 2편","date":"November 05, 2021"},"fields":{"slug":"/how-spring-handler-mapping-works-2/"}}},{"node":{"id":"0c7c2f80-6616-5510-8a2f-9b8b7d26fef4","excerpt":"정답률 0.95퍼의 무시무시한 문제다.  문제 제목 카드 짝 맞추기 문제 설명 \n게임 개발자인 베로니는 개발 연습을 위해 다음과 같은 간단한 카드 짝맞추기 보드 게임을 개발해 보려고 합니다.\n게임이 시작되면 화면에는 카드 16장이 뒷면을 위로하여 4 x 4 크기의 격자 형태로 표시되어 있습니다. 각 카드의 앞면에는 카카오프렌즈 캐릭터 그림이 그려져 있으며, 8가지의 캐릭터 그림이 그려진 카드가 각기 2장씩 화면에 무작위로 배치되어 있습니다.\n유저가 카드를 2장 선택하여 앞면으로 뒤집었을 때 같은 그림이 그려진 카드면 해당 카드는 게임 화면에서 사라지며, 같은 그림이 아니라면 원래 상태로 뒷면이 보이도록 뒤집힙니다. 이와 같은 방법으로 모든 카드를 화면에서 사라지게 하면 게임이 종료됩니다. 게임에서 카드를 선택하는 방법은 다음과 같습니다. 카드는 커서를 이용해서 선택할 수 있습니다. 커서는 4 x 4 화면에서 유저가 선택한 현재 위치를 표시하는 “굵고 빨간 테두리 상자”를 의미합니다…","frontmatter":{"categories":"PS","title":"프로그래머스 - 카드 짝 맞추기 (2021 카카오 블라인드 공채)","date":"September 16, 2021"},"fields":{"slug":"/programmers-flip-card/"}}},{"node":{"id":"ebd8884b-23b5-5248-869a-2e0428b7f545","excerpt":"문제 상황 백준 빵집를 풀때 이상한 점이 확실히 생겼다.  일반적으로 python에서 방문 여부를 확인하기 위해 과 중에 하나를 사용한다.\n같은 경우는 잘못된 접근 같은 행동에서 안전한 편이고 대부분의 기능에서 의 시간이 보장된다고 알고 있기 때문에 을 이용한 풀이를 종종했다. List에서는 미숙한 코드로 indexError를 경험할 수 있다. 이 문제는 naive 하게 을 사용하면 시간초과를 당한다. 처음엔 논리를 잘못 구성해 recursionDepth가 커져서 시간초과가 나는건가 라고 생각했지만 논리에는 문제가 없었다. 그래서 만을 로 바꿔주었더니 통과했다. 분명 도 똑같이 이고 에서는 도 이라고 알고 있는데 왜 차이가 나는 것일까? 이 이해 안되는 상황을 지금부터 알아보자. 메모리 사용량 먼저 간단하게 두 자료구조의 메모리 사용량을 비교해보았다. 아래 코드는 10000개의 행 , 500개의 열을 가진 2차원 board에서 사용되는 방문을 기록하는 일반적인 구현이다. 하나는 로…","frontmatter":{"categories":"Python","title":"Python 3의 Set 훔쳐보기","date":"August 07, 2021"},"fields":{"slug":"/secret-of-set-in-python/"}}},{"node":{"id":"7e6fc637-3537-5c6c-a4e5-2097e169e8ca","excerpt":"문제 제목 경주로 건설 문제 설명 \n건설회사의 설계사인 죠르디는 고객사로부터 자동차 경주로 건설에 필요한 견적을 의뢰받았습니다.\n제공된 경주로 설계 도면에 따르면 경주로 부지는 N x N 크기의 정사각형 격자 형태이며 각 격자는 1 x 1 크기입니다.\n설계 도면에는 각 격자의 칸은 0 또는 1 로 채워져 있으며, 0은 칸이 비어 있음을 1은 해당 칸이 벽으로 채워져 있음을 나타냅니다.\n경주로의 출발점은 (0, 0) 칸(좌측 상단)이며, 도착점은 (N-1, N-1) 칸(우측 하단)입니다. 죠르디는 출발점인 (0, 0) 칸에서 출발한 자동차가 도착점인 (N-1, N-1) 칸까지 무사히 도달할 수 있게 중간에 끊기지 않도록 경주로를 건설해야 합니다.\n경주로는 상, 하, 좌, 우로 인접한 두 빈 칸을 연결하여 건설할 수 있으며, 벽이 있는 칸에는 경주로를 건설할 수 없습니다.\n이때, 인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 직선 도로 라고 합니다.\n또한 두 직선 도로가 서로 …","frontmatter":{"categories":"PS","title":"프로그래머스 - 경주로 건설 (2020 카카오 인턴쉽)","date":"July 15, 2021"},"fields":{"slug":"/programmers-build-race-road/"}}},{"node":{"id":"5ca018d3-2146-5d17-ad98-699a8e12e7f0","excerpt":"본 글은 Do I need an interface with Spring boot?을 번역한 글입니다. 잘 쓰여진 글을 정리 하는 겸 한글로 공유하고 싶어서 번역했습니다. 들어가면서 Spring boot를 사용하다보면, 종종  ( annotation을 붙인 bean)을 사용하게 된다. 인터넷 상의 많은 예시에서, 사람들이 들을 위해서 를 사용하는 걸 볼 수 있을것이다. 예를 들어서 , 우리가 todo 어플리케이션을 만든다고 할때, 라는 와 이라는 구현체를 만들때가 있다. 이 포스트에서, 우리는 왜 그런 것을 하는지와 필요한가에 대해서 알아볼 것이다. 짧은 결론은 짧은 결론은 꽤나 간단하다. ** 를 만들 필요 없다. ** 를 만든다고 하면, class의 자체의 이름을 라고 하고 를 통해서 bean들에 주입하면 된다. 예를 들어서 이런 코드가 있다고 해보자. 위에 있는 예시는 를 이용한 field injection을 사용하던 생성자 주입을 사용하던간에 작동할 것이다. 그럼 왜 신경써야…","frontmatter":{"categories":"Spring","title":"Spring Boot에서 interface를 사용해야 할까? (Do I need an interface with Spring boot?)","date":"July 15, 2021"},"fields":{"slug":"/do-i-need-an-interface-with-spring-boot/"}}},{"node":{"id":"775850b9-bf7d-5165-a970-117498904ad5","excerpt":"글이 매우 복잡하고 깁니다. 양해 부탁드립니다. 틀린 정보나 이해가 가지 않는 부분은 댓글 남겨주시면 참고하겠습니다. HandlerMapping의 역할 Spring MVC에 대해서 공부하던 중, 이 request를 처리하기에 적절한 handler를 찾아온다는 설명을 들었다.\n좀 더 찾아보니 은 request의 URL과 매칭되는 handler를 선택하는 역할을 수행한다 는 것을 보았다. request의 URL만 보고 어떻게 찾아온다는 것일까? 그리고 찾아진 handler는 method인데 어떠한 방식으로 가져온다는 것일까? 한가지만 기억하고 가자.\nHandlerMapping은 원하는 handler를 찾아오는 역할을 수행한다. Spring MVC Request flow 의 역할에 대해서 살펴보기 전에 Spring MVC에서 request가 어떠한 순서로 처리되는지 먼저 보아야 한다.\n처리 순서 먼저 의 역할을 하는 이 request를 받는다. 은 적절한 controller를 선택하는 …","frontmatter":{"categories":"Spring","title":"Spring MVC - HandlerMapping의 동작방식 이해하기 1편","date":"June 09, 2021"},"fields":{"slug":"/how-spring-handler-mapping-works-1/"}}},{"node":{"id":"fab54913-676d-5548-a4f9-d4855a8db7cc","excerpt":"문제 제목 12904번 A와 B 문제 설명 수빈이는 A와 B로만 이루어진 영어 단어가 존재한다는 사실에 놀랐다. 대표적인 예로 AB (Abdominal의 약자), BAA (양의 울음 소리), AA (용암의 종류), ABBA (스웨덴 팝 그룹)이 있다. 이런 사실에 놀란 수빈이는 간단한 게임을 만들기로 했다. 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다. 문자열의 뒤에 A를 추가한다. 문자열을 뒤집고 뒤에 B를 추가한다. 주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오. 입력 첫째 줄에 S가 둘째 줄에 T가 주어진다. (1 ≤ S의 길이 ≤ 999, 2 ≤ T의 길이 ≤ 1000, S의 길이 < T의 길이) 출력 S를 T로 바꿀 수 있으면 1을 없으면 0을 출력한다. 예제 입출력 입력 출력 풀이 가장 먼저 생각난 풀이는 백트래킹을 사용해서 S가 T를 만드는 방법이였다.…","frontmatter":{"categories":"PS","title":"백준 12904 - A와 B","date":"March 30, 2021"},"fields":{"slug":"/12904-A-and-B/"}}},{"node":{"id":"38eb533d-218e-57a9-bff7-fb7a95946fca","excerpt":"본 글은 Strategy Design Pattern with in Spring Boot application.을 번역한 글입니다. 잘 쓰여진 글을 정리 하는 겸 한글로 공유하고 싶어서 번역했습니다. 전략 디자인 패턴은 실행 중에 알고리즘을 선택하게 해주는 행동 디자인 패턴이다. 전략 디자인 패턴의 의도는 다음과 같다 :\n“알고리즘 집합을 선언하고, 각각을 캡슐화하며 그것들을 교체가 가능하게 만든다. 전략 패턴은 알고리즘을 사용하는 유저와는 독립적으로 알고리즘을 다양하게끔 한다.” UML Class와 sequence diagram 전략 패턴의 다이어그램\n전략 디자인 패턴을 설명하고 다양한 언어로 그것을 구현하는 많은 글들이 시중에 있다.\n이 글의 목적은 스프링 부트 어플리케이션에서 전략 패턴을 어떻게 구현하는지 알려주는 것이다. 스프링 부트 스프링 부트는 Java microservice 개발의 실질적 표준이 되었다. 스프링 부트 어플리케이션에서 자주 쓰이는 디자인 패턴들을 어떻게 구…","frontmatter":{"categories":"Spring","title":"스프링 부트 어플리케이션의 전략 패턴(Strategy Design Pattern with in Spring Boot application)","date":"January 30, 2021"},"fields":{"slug":"/starategy-design-pattern-with-in-spring-boot-application/"}}},{"node":{"id":"5d077397-5291-5ba2-8fbc-ceb75966ec5d","excerpt":"운영체제 과제 4(double indirect inode) 테스트 환경 OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 운영체제 네번째 과제인 double indirect inode에 대한 내용입니다. 크게 fs.c안의 bmap , itrunc함수를 수정하고, fs.h와 file.h, param.h의 값을 조금 수정함으로써 double indirect inode를 구현합니다. 과제 명세 먼저 xv6의 기본적인 inode의 구조에 대한 간단한 구조입니다.\nimage dinode 구조체에서 direct block pointer는 12개가 존재하고, 1개의 indirect block pointer가 존재합니다. 그런 구조를 아래와 같이 수정해야합니다.\nimage dinode 구조체에서 direct block pointer가 11개로 바뀌고, 1개의 single indirect block pointer, 그리고 1개의 dobule indirect block pointer…","frontmatter":{"categories":"운영체제","title":"운영체제 과제 4 (Double indirect inode)","date":"June 21, 2019"},"fields":{"slug":"/os-xv6-double-indirect-node/"}}},{"node":{"id":"855c7bac-c3be-59d4-9b55-84e267962b13","excerpt":"운영체제 과제 3(LWP) 테스트 환경 OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 운영체제 세번째 과제인 Light-weight Process인 Thread에 대한 내용입니다. 크게 thread_create, thread_exit, thread_join을 통해 구현됩니다. thread 구현을 위한 proc 구조체 변경사항 image  등을 추가했습니다.\n그중에서  creator 멤버는 기존 proc 구조체의 parent와 비슷한 역할을 수행합니다. 이번 설계에서 process와 thread_create를 통해 생성된 thread는 parent-child 관계가 아니고 pid도 다르기 때문에 creator라는 포인터를 가짐으로써 최소한의 연결 관계를 유지해줍니다. 이 방식은 아래에서 다시 설명합니다. (단 프로세스의 경우에는 creator와 parent가 같다고 생각합니다.) 기본적인 Thread 기능 명세 먼저 Thread의 기본 명세는 다음과 같습니다.\ni…","frontmatter":{"categories":"운영체제","title":"운영체제 과제 3 (LWP)","date":"June 02, 2019"},"fields":{"slug":"/os-xv6-thread/"}}},{"node":{"id":"6b3dc350-65b2-5e76-bbc1-dbd475110e49","excerpt":"운영체제 과제 2(implementing simple schedulers on xv6) 테스트 환경 OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 운영체제 두번째 과제인 Implementing simple schedulers (FCFS,MLFQ) 에 대한 내용입니다. 크게 FCFS 정책과 MLFQ 정책을 사용하게끔 분기됩니다. FCFS 과제 명세 : 먼저 FCFS 스케쥴링의 명세는 다음과 같습니다.\nimage 먼저 생성(fork())된 프로세스가 먼저 스케줄링 되어야 한다. 스케줄링된 프로세스는 종료되기 전까지는 swithc-out 되지 않는다. 프로세스가 스케쥴링 된 이후 100ticks이 지날때까지 종료되거나 sleeping 하지 않으면 종료해야한다. 실행중인 프로세스가 sleeping으로 전환되면 다음 프로세스가 스케줄링된다. sleeping 상태이면서 먼저 생성된 P가 깨어나면 그 프로세스로 스케줄링 된다. 작동과정 설명 : 첫번째로 FCFS 스케쥴링 정…","frontmatter":{"categories":"운영체제","title":"운영체제 과제 2 (Implementing simple schedulers on xv6)","date":"April 28, 2019"},"fields":{"slug":"/os-xv6-scheduler/"}}},{"node":{"id":"ae05463a-541b-597c-acfd-185ccfe382cc","excerpt":"운영체제 과제 1 ( Simple User-level Unix Shell) 테스트 환경 : OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 : 운영체제 첫번째 과제인 Simple User-level Unix shell에 대한 내용입니다. 크게 interactvie mode와 batch mode로 나뉘어지고\n사용자가 입력한 명령 혹은 batch file을 읽어와서 명령을 수행하고 그 결과를 출력하는 프로그램입니다. 작동과정 설명 : Interactvie Mode 첫번째로 interactvie mode내에서의 작동 과정과 예시입니다.\n크게 사용자로부터 입력을 받아오고, 입력을 특정한 기준을 가지고 분할하여\nexecvp 함수를 사용하여 처리합니다. fgets() 함수를 통해 사용자에게 입력을 받습니다. strtok 함수를 사용하여 semi-colon과 space를 기준으로 raw한 입력을 유의미하게 분할합니다. 분할된 명령어들은 char* 이차원 배열에 저장됩니다. 명…","frontmatter":{"categories":"운영체제","title":"운영체제 과제 1 (Simple User-level Unix Shell)","date":"March 28, 2019"},"fields":{"slug":"/os-user-level-unix-shell/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"황성우","bio":{"role":"개발자","description":["기본기에 자신있는","내부구조에 관심 있는","능동적으로 성장하는"],"thumbnail":"profile.png"},"social":{"github":"https://github.com/BecomeWeasel","linkedIn":"https://www.linkedin.com/in/sungwoo-hwang/","email":"hsw0194@gmail.com"}}}}},"pageContext":{}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437","3350743975"]}