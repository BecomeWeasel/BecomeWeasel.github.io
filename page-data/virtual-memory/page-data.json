{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/virtual-memory/",
    "result": {"data":{"cur":{"id":"0606884e-0e00-5db9-977f-c93b84fcca9a","html":"<p><a href=\"https://becomeweasel.me/paging/\">이전편 : 페이징</a></p>\n<h2 id=\"가상-메모리-virtual-memory\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-virtual-memory\" aria-label=\"가상 메모리 virtual memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 메모리 (Virtual Memory)</h2>\n<p>가상 메모리는 논리적 메모리와 물리 메모리를 분리시켜, <strong>프로세스 전체가 메모리내에 올라오지 않아도 실행가능하도록 하는 기법이다.</strong></p>\n<p>물론 프로그램이 실행되기 위해서는 메모리에 프로세스가 올라와야 하는것은 맞다. 하지만 특정 부분을 실행할때는 그 부분만 메모리 위에 올라와있어도 구동이 된다.</p>\n<p>그렇기 때문에 논리적 주소공간은 실제 물리적 주소공간보다 훨씬 커도 된다. 왜냐면, 어차피 일부만 실행할때 필요하니까..\n그럼 가장 핵심적인 기술은 프로세스를 실행할때, 필요한 메모리를 불러오고(<strong>swapped in</strong>) 필요하지 않은 부분은 내리는(<strong>swapped out</strong>) 과정이 필요하다.</p>\n<p>가상메모리는 <strong>요구 페이징(Demand Paging)</strong> 이라는 기술로 구현된다.</p>\n<p>특정 페이지에 대한 수요가 있을때, 즉 페이지에 대한 참조 요청이 들어왔을때 페이지를 메모리로 불러오는것이다.\n다시 말해서 기존의 방법과는 다르게 가상 메모리 방식을 취하면, 시작할때부터 아무 메모리도 올라와있지 않아도 되고 필요할때만 불러오는 방식이다.</p>\n<p>프로그램에서 사용되는 일부분만 메모리에 적재하는 가상 메모리를 통해서 아래와 같은것들이 가능하다.</p>\n<ul>\n<li>시스템 라이브러리가 여러 프로세스 사이에 공유가 가능하다.\n프로세스 입장에서는 자신의 주소공간에 라이브러리가 올라와있다고 생각하지만, 실제로 라이브러리가 들어 있는 물리 메모리는 하나로 모든 프로세스에 공유되는 방식이다.</li>\n<li><strong>프로세스가 만들어질때 훨씬 더 효율적이다.</strong> 왜냐면, 실제로 프로세스를 만들때 필요한 모든 메모리를 할당해주는것이 아니라 <strong>필요할때만</strong> 주기 때문에 <strong>훨씬 가볍고 효율적이다.</strong>\n<ul>\n<li>예를 들어서 <code class=\"language-text\">fork</code> 를 해서 프로세스를 생성한다고 해보자.\n이때 메모리를 직접 주는것이 아니라 <strong>기존의 메모리를 그대로 사용하게끔만 하고 프로세스는 이것을 독립적인 메모리 공간으로 인식한다.</strong></li>\n</ul>\n</li>\n<li><strong>실제 물리 메모리보다 더 큰 메모리를</strong> 요구하는 프로세스를 구동시킬 수 있다.</li>\n<li><strong>더 많은 프로세스가 구동이 가능하다.</strong></li>\n</ul>\n<h2 id=\"요구-페이징-demand-paging\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95-demand-paging\" aria-label=\"요구 페이징 demand paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요구 페이징 (Demand Paging)</h2>\n<p>페이지를 메모리에 올릴때 오직 그것이 필요할때만 수행하는것을 요구 페이징이라고 한다.\n이것을 Lazy Swapper이라고도 하는것같다.(그 페이지 필요할때까지 절대 페이지를 메모리에 올리지 않는다)</p>\n<ul>\n<li><strong>적은 I/O</strong> : 전체 코드내에서 접근 안되는 주소공간은 가져올 필요가 없으니.</li>\n<li><strong>적은 메모리 사용량</strong></li>\n<li><strong>빠른 응답</strong> : 모든 페이지가 올라와있을 필요가 없으니 시작이 빠르다.</li>\n<li><strong>더 많은 유저</strong> : ”<em>논리적 메모리 >> 물리적 메모리</em> ” 이니 더 많은 프로세스를 수용가능하다.</li>\n</ul>\n<p>만약에 특정 페이지가 필요하다고 하자. 그럼 그 페이지를 참조해야하는데, 아래와 같은 분기를 가지게 된다.</p>\n<ul>\n<li>페이지에 대한 잘못된 참조 → 에러</li>\n<li>메모리에 올라와있지 않음 → 데이터를 메모리에 적재함</li>\n</ul>\n<p>그럼 이 올라와있지 않거나 올라와 있는것을 어떻게 구분할까?<br>\n논리주소와 물리주소를 변환할때 쓰였던 페이지 테이블을 이용해 페이지 테이블의 엔트리에 <strong>valid-bit</strong>를 부착해서 구분한다.</p>\n<p>만약 valid-bit가</p>\n<ul>\n<li>True면\n<ul>\n<li>현재 그 메모리를 가져온다.</li>\n</ul>\n</li>\n<li>False면\n<ul>\n<li><strong>Page Fault 발생</strong></li>\n<li>Page fault에 대한 처리를 하는데 일반적으로 페이지에 해당하는 프레임을 찾아서 로드시킨다.</li>\n</ul>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACKElEQVQ4y22Ta0/bMBiF+///EB+mTZTBRppCoWLQAglN0lx7yYUQ5/5McZquoFl69dqy/ejo+HhU1zVlWVJVlaxuXtcVTdMc10VR9D0X3FlbZk5MWRQUcq+vgTFq25ZhDPMsy9hstvLQ6Wiqisk65trNoKmHW5/OjPjPME2L8fiSMAwlNNxt5bwuSyZWiOJ+UJUlflpgJQX+e05ZVT0wCAKpqCvP89B1Hcf1uPh5JSFpmvKwstlGCbQN04XO3YtB8C5Q7YTFJpXd2EQ98OzsjCgKmc1mqKpKEPgYhsn3H+fEcSxtuHh18eIPaGuUxYpbbY33njPfCLQgRjF26MEBaFoWpu3wounYnkdZ19i2w6/fCkmSSKOvNA9fAhtung3meg9UrJBbzebbg8FbEPZAd22xmt8T22vy7QaKHHNtM764kgo74PjV6xU2NdfGjqn7jpcIzp8d7lcu46WNPgDj/Q4cCwKPJvBBZHjBBkVRpX9lWaAuV/j7qPfwzzP3S10qvNR85gfgUeHw8O1JAIQQOLZNA9TZB+nDHWW4p6orFHPHjZdKhbeB4C0UTN30n4ed6UNx6N3LdxVFkQy4zGDbymBP1hGqlyGKEiMSOEkue1ZUn3N4hAKLxYLpdMrj4yOu67JcLtE0jSjco9qRzGFbnwa7PTI+BXsAdmEevlz3KF1G5TfMc5m5iZ/TNrVUP9Rwd/QVdvoVv65FlvG0WvNkuuRC9FYcYAPwL2VC3fsCCtw3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/e2212896f80472ad709b5b1b0057a2b1/37523/1.png\"\n        srcset=\"/static/e2212896f80472ad709b5b1b0057a2b1/e9ff0/1.png 180w,\n/static/e2212896f80472ad709b5b1b0057a2b1/f21e7/1.png 360w,\n/static/e2212896f80472ad709b5b1b0057a2b1/37523/1.png 720w,\n/static/e2212896f80472ad709b5b1b0057a2b1/8bd7c/1.png 845w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n위 그림을 보면 B,D,E,F,G,H는 valid-bit가 invalid로 되어있다.<br>\n만약 이때 B나 F와 같은 페이지를 참조하려 하면 <strong>Page Fault</strong>가 일어나는 것이다.</li>\n</ul>\n<p>그럼 <strong>페이지 폴트</strong> (Page Fault)가 뭘까?</p>\n<h2 id=\"페이지-폴트-page-fault\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8-page-fault\" aria-label=\"페이지 폴트 page fault permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 폴트 (Page Fault)</h2>\n<p>페이지 폴트는 valid-bit가 invalid 인 곳에 MMU가 접근을 할때 HW trap을 발생시키면서 생긴다.</p>\n<p>valid-bit가 invalid 하다는 것은 현재 메모리안에 내가 원하는 페이지가 존재하지 않음을 의미하므로,<br>\n원하는 페이지에 해당하는 프레임을 메모리로 가져온 후 프로그램이 계속 동작되게끔 해야한다.<br>\n이것을 페이지 폴트 핸들링이라고 한다.</p>\n<h3 id=\"페이지-폴트-핸들링\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81\" aria-label=\"페이지 폴트 핸들링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 폴트 핸들링</h3>\n<p>페이지 폴트는 결국에 인터럽트이기 때문에 ISR을 수행하는 처리과정을 거친다.</p>\n<p>아래는 프로세스가 특정한 페이지를 참조하려고 했을때의 과정에 Page Fault 핸들링하는 과정이 추가된것이다.</p>\n<ol>\n<li>프로세스가 <strong>논리주소</strong> (p,d) 를 가지고 메모리에 접근하려고 시도한다.</li>\n<li><strong>TLB를 먼저 확인</strong>해서 p에 해당하는 프레임 번호 f가 있는지 확인한다.\n<ol>\n<li><strong>TLB Hit</strong>,있다면 바로 메모리로 접근해서 (f,d)를 가져온다.</li>\n<li><strong>TLB Miss,</strong> 없으니 이제 페이지 테이블을 참조해야 한다.</li>\n</ol>\n</li>\n<li><strong>(p,d)를 가지고 페이지 테이블에 접근한다.</strong>\n<ol>\n<li>페이지 테이블에 p에 해당하는 f가 valid하면, 메모리에 접근해서 로드한다.\n<ul>\n<li>이때 <strong>TLB 엔트리도 갱신된다.</strong></li>\n</ul>\n</li>\n<li>만약 valid하지 않다면 현재 메모리에 올라와있지 않다는 것 → Page Fault</li>\n</ol>\n</li>\n<li>운영체제가 메모리 접근할때의 주소를 확인한다.\n<ol>\n<li>잘못된 접근인가? 그러면 중지시켜야 한다.</li>\n<li>아니라면 진행.</li>\n</ol>\n</li>\n<li>물리 메모리에서 적절히 빈공간을 찾는다.\n<ol>\n<li>만약 이때 없다면, <strong>적절하게 다른 프레임을 교체시켜야 한다.</strong> 이 교체의 방식이 매우 중요한데, 잘 골라야 다음에 replace가 일어날 확률을 줄인다.</li>\n</ol>\n</li>\n<li>저장소에서 매치되는 페이지를 프레임에 올린다.\n<ol>\n<li><strong>이때 프로세스는 <code class=\"language-text\">wait</code> 상태인데, 저장소 접근 자체가 I/O 이기 때문이다. 컨텍스트 스위칭 발생.</strong></li>\n<li>I/O가 끝나면, 페이지 테이블 엔트리가 업데이트 되고, valid-bit가 valid로 설정된다. 이때도 컨텍스트 스위칭 발생할것같다.</li>\n<li><strong>프로세스는 레디큐로 옮겨진다. 그리고 일반적으로 스케쥴링되는것처럼 기다려야 한다.</strong></li>\n</ol>\n</li>\n<li>CPU를 다시 할당받게 되면 페이지 폴트 트랩 처리가 끝난다.</li>\n<li>페이지 폴트를 촉발시켰던 명령어부터 다시 수행한다. (PC를 증가시키지 않기 때문에. 만약 PC 증가시키면 그 명령어는 강제로 건너띄는것이다.)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 696px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAACpElEQVQ4y3VUi1LaUBTM//9FnbEfoKDQqlUjlJiENBiRRAgQ3i9FHkoCyXb26kWk0zOTIY9z9+zu3YuiqiqKxSJMw0A+n8P19RUMQ0floQxD16HfarAtE5l0CjfXlyg7NiyrCMf+g4eyg/L9He5KNjy3Al2/hYKdenl5wWg0wtPTE1ZhiLe3N8znc7RabZRKd/C8R0ynU8RxLPob9QZU9QbZTBZn5+dotVpQ+JHXZrPBYDBAr9dDvV5HEATiud1uYzabiZ4oisSQyWQCx3Fwlv2JnJrDj0wWB98OcHj4HUqSJODFGg6HqFQqAoiLCTIejwVzluxjaZqGX+eX4j4OYzi2g9PM6VdAgvi+j9fX1+1CSqYNUqb8rTfqSB2lsJgvkKwBy7CQPkl/eshGMqN/u2wIyCGr1eoLYLVWQyGvYTQcYdgbomTZSKXTUJbLJXiRFeVJwDAMxWL6R4ZywBawWoWW17CJ1nj0HmGZZHgCpdvtik3gDtFsLm42m3h+fhbe9ft9ASpZS+Cq7+N3roAkThA0gk9AgjFXtVpNSCaAYRhig/jMgZTLFKw3G0RCegL/3oGm5gR4J+jALtpI0UMyoUwpOWgG4pl5I2Mpk9/XcYxFrwsUVNSuLqAX9HfAVge2Zb8zlBLIgrI9zxPMyJCZJNBisRDvRuMx+o0GkskIFdfF5cUVojBCUA9g6iaOjo+hrNfrbWRYlEYfKZ3syZr3rlsRGXVdF9PZTATfcz0M+gMMegO0g7awRyEAi8CSLYG4MfKb8O9jMH85nCcoTmLs1xaQTbuA3CwJwggxj5TPiJG1X/OFJfRX7n6cJO9nWRq/e7R2K/z4o+BwAsoI7YLJd8r+GZUNu40Ekuzkidkv2auslvN/Qrt/L6LR6cA0TcH0f4OJ9RdOrgCAqwatNgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/2f4734fe442e726fab395b6a93b9a610/82158/2.png\"\n        srcset=\"/static/2f4734fe442e726fab395b6a93b9a610/e9ff0/2.png 180w,\n/static/2f4734fe442e726fab395b6a93b9a610/f21e7/2.png 360w,\n/static/2f4734fe442e726fab395b6a93b9a610/82158/2.png 696w\"\n        sizes=\"(max-width: 696px) 100vw, 696px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"쓰레싱-threshing\" style=\"position:relative;\"><a href=\"#%EC%93%B0%EB%A0%88%EC%8B%B1-threshing\" aria-label=\"쓰레싱 threshing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쓰레싱 (Threshing)</h2>\n<p>스레싱은 멀티프로그래밍 환경에서 페이지 폴트가 많이 일어나서 시스템이 아무런 작업도 하지 못하고 페이지를 메모리에서 가져오고 빼내는 과정만 반복해 CPU 이용률이 급격하게 떨어지는 현상이다.</p>\n<p>더 최악인 점은 CPU 이용률이 떨어지니, 레디큐에 프로세스를 올리는 Long-term scheduler가 판단하기를\n”CPU 이용률을 높이기 위해 멀티프로그래밍 정도를 올려야 함”이라고 판단하고 레디큐에 더 많은 프로세스를 올리면서 페이지폴트는 더 늘어간다.</p>\n<ul>\n<li>여기서 멀티프로그래밍 정도가 느는것과 페이지폴트가 무슨상관일까?\n<ul>\n<li>새로운 프로세스가 올라오면, Short-term scheduler가 새로운 프로세스에 CPU를 할당할 것이고, 이때는 initial page fault가 생기기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<p>결국 Swap-in,Swap-out만을 하느라 바쁘고, 프로세스는 Block 되며, CPU는 대부분의 상황에서 <strong>IDLE</strong> 상태다.</p>\n<blockquote>\n<p>I/O 작업만 하니까..</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABS0lEQVQoz2WRa2/iMBRE+/9/1fKpW22Xso7ygDSJHeK8gDQkYUEUOKvrqqXSjjS6liwfzfU83G43ROfzmbZtGceRYRj+8ygeR6ZpYrNpsbZgnRvn7aZ1DGE9fAIvlwvGGIqiYL1eO8vZiq3F5DmZ1mRZRmYKjO1RUYkfN2RFz4e+ASWFAOu6pqoql1ZAuYC1Jgl8Fr9fUIs/7i61B1TcszQjv/wdP55rDsf3O7BpGtI0dbMsS6Iowvd9wigiVIro6Set1timYdt1vLyOxMVEnA+Eac9i2fEc7O7A/X7/tarneSRJ4tJKmqZtCVcrat+jenpktww5ZIZTmnDabDm9w/V6ZZjOd6BIEiqlHFRSypSVS2sJggDfU+TxCms0HP9yOx2FxHc5oFj+azabMZ/P3eM4jtE6I00Tl1Zareqaru/p3t64ftXw0e6n/wF+nwqm/nfotAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/fcbecb569fce34f2614a5907b36464b2/37523/thresing.png\"\n        srcset=\"/static/fcbecb569fce34f2614a5907b36464b2/e9ff0/thresing.png 180w,\n/static/fcbecb569fce34f2614a5907b36464b2/f21e7/thresing.png 360w,\n/static/fcbecb569fce34f2614a5907b36464b2/37523/thresing.png 720w,\n/static/fcbecb569fce34f2614a5907b36464b2/6029f/thresing.png 906w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 그림처럼 MPD를 계속 올리다보니 스레싱이 발생하고, 그러면 더 MPD를 올리게되고 페이지폴트는 더 자주일어나면서 CPU 이용률은 급감한다.</p>\n<p>결국에 자주 접근되는 페이지가 메모리에 올라와있지 않으면 이런 많은 페이지 폴트가 생기는데,<br>\n그렇기 때문에 각 프로세스가 필요로 하는 <strong>최소 프레임의 개수만큼은 보장</strong>을 해주어야 한다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-virtual-memory\">가상 메모리 (Virtual Memory)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95-demand-paging\">요구 페이징 (Demand Paging)</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8-page-fault\">페이지 폴트 (Page Fault)</a></p>\n<ul>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81\">페이지 폴트 핸들링</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%93%B0%EB%A0%88%EC%8B%B1-threshing\">쓰레싱 (Threshing)</a></p>\n</li>\n</ul>\n</div>","excerpt":"이전편 : 페이징 가상 메모리 (Virtual Memory) 가상 메모리는 논리적 메모리와 물리 메모리를 분리시켜, 프로세스 전체가 메모리내에 올라오지 않아도 실행가능하도록 하는 기법이다. 물론 프로그램이 실행되기 위해서는 메모리에 프로세스가 올라와야 하는것은 맞다. 하지만 특정 부분을 실행할때는 그 부분만 메모리 위에 올라와있어도 구동이 된다. 그렇기 때문에 논리적 주소공간은 실제 물리적 주소공간보다 훨씬 커도 된다. 왜냐면, 어차피 일부만 실행할때 필요하니까..\n그럼 가장 핵심적인 기술은 프로세스를 실행할때, 필요한 메모리를 불러오고(swapped in) 필요하지 않은 부분은 내리는(swapped out) 과정이 필요하다. 가상메모리는 요구 페이징(Demand Paging) 이라는 기술로 구현된다. 특정 페이지에 대한 수요가 있을때, 즉 페이지에 대한 참조 요청이 들어왔을때 페이지를 메모리로 불러오는것이다.\n다시 말해서 기존의 방법과는 다르게 가상 메모리 방식을 취하면, 시작할…","frontmatter":{"date":"January 28, 2022","title":"운영체제의 메모리 훔쳐보기 2편 - 가상 메모리(Virtual Memory)","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/virtual-memory/"}},"next":{"id":"37b121af-aaea-5b5c-96bd-dbe71d964439","html":"<h2 id=\"array\" style=\"position:relative;\"><a href=\"#array\" aria-label=\"array permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array</h2>\n<p>논리적 저장순서와 물리적 저장순서가 일치한다. 다시 말해서 <code class=\"language-text\">a[2]</code> 와 다음에 오는 <code class=\"language-text\">a[3]</code> 는 물리적으로 연결되어 있다.\n하지만, 하나의 Array의 크기가 너무 커 하나의 page(혹은 frame) 안에 다 못들어오는 경우에는 <strong>virtual adress는 <em>연속적</em>으로 이어져있지만, physical adress에서도 그렇다는 보장은 없다.</strong></p>\n<blockquote>\n<p>💡 하지만 physical adress와 virtual address에 관한 문제는 OS가 처리할 일이고 프로그래머에게 보이지 않는 추상계층이기에 우리가 깊게 생각할 필요는 없다고 생각한다.</p>\n</blockquote>\n<p>또, 한번 사이즈가 정해지면 변할 수 없다. 이를 해결하는 방법이 Dynamic Array다.</p>\n<ul>\n<li>조회 : 인덱스를 기반으로 한 접근이 가능하다. 인덱스를 알고 있다면 <code class=\"language-text\">O(1)</code>의 시간 내에 접근이 가능한데 , <strong>이것을 Random Access</strong>라고 한다.</li>\n<li>삽입 : Array의 특정 위치에 삽입을 할때는 원소를 넣고 끝나는 것이 아니라, 기존의 원소들을 shift 해주는 비용이 생기기 때문에 <code class=\"language-text\">O(n)</code>의 비용이 든다.</li>\n<li>삭제 : 삽입과 마찬가지로 shift의 비용 때문에 <code class=\"language-text\">O(n)</code>이 소요된다. 만약 shift를 해주지 않는다면 삭제를 한 곳에 빈 공간이 생기게 될것이고, contiguous한 Array의 특성이 깨진다.</li>\n</ul>\n<h2 id=\"arraylist\" style=\"position:relative;\"><a href=\"#arraylist\" aria-label=\"arraylist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ArrayList</h2>\n<p>Java 기준으로 primitive만 저장 할 수 있는 Array와는 다르게 Object도 가능하다. ArrayList에 add를 사용하여 primitive한 데이터를 집어넣을때는 Auto-boxing이 사용된다. 또 제네릭이 사용 가능하다.</p>\n<p>하지만 가장 큰 차이점은 <strong>ArrayList는 Dynamic Array라는 것이다.</strong> ArrayList는 내부적으로 Array와 사이즈 정보를 가지고 있다.</p>\n<p>Array의 초기 사이즈가 고정되어 있고 늘어나지 않는것에 비해서, ArrayList는 add를 이용해서 원소를 삽입하다가 원소가 가득차게 되면, 내부적인 Array의 크기를 두배 혹은 1.5배 정도로 늘여서 기존의 원소들을 다 옮기게 된다.</p>\n<p>이 과정에서의 시간 복잡도를 고민해보면, 기존 원소의 개수가 0개이고 사이즈가 <code class=\"language-text\">n</code>개라고 해보자.\n이때 <code class=\"language-text\">n</code>번의 add를 할때까지 내부 Array는 가득차지 않고 각각의 삽입연산의 시간복잡도는 <code class=\"language-text\">O(1)</code>이다.</p>\n<p>하지만 한번 더 add를 한다면 내부 Array를 두배로 늘리고 , 기존의 <code class=\"language-text\">n</code>개의 원소들을 모두 옮겨야 하니 <code class=\"language-text\">O(n)</code>의 시간이 소요된다.\n<code class=\"language-text\">n+1</code>번의 add에 걸리는 시간복잡도가 <code class=\"language-text\">O(1)*n+O(n)</code>이니, 평균적인 시간 복잡도는 <code class=\"language-text\">(O(1)*n+O(n))/(n+1)=O(1)</code>이 되는 것이다.</p>\n<p>이것을 분할 상환(Amortized Analysis)라고 한다.</p>\n<h2 id=\"linkedlist\" style=\"position:relative;\"><a href=\"#linkedlist\" aria-label=\"linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList</h2>\n<p>LinkedList는 불연속적인 데이터들의 집합이다. LinkedList는 Node라고 불리는 내부구조들의 chain으로 구성되어 있는데 구조는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\tNode<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이처럼 Node는 원소와 그 다음 Node를 가리키는 포인터로 구성된다. 각각의 원소들은 오직 자기 다음에 오는 Node의 정보만을 가리키고 있는 것이다.(Singly Linked List 기준). 물론 <code class=\"language-text\">next</code> 라는 포인터를 하나 더 유지하는 메모리 사용량도 무시할 순 없다.</p>\n<p>이것을 이용하여 삽입과 삭제를 <code class=\"language-text\">O(1)</code>만에 할 수 있다. 삽입을 할때는 단순히 <code class=\"language-text\">next</code> 만 교체하면 되고, 삭제 역시 마찬가지다.</p>\n<ul>\n<li>조회 : k번째 원소를 찾기 위해서는  <code class=\"language-text\">O(k)</code>만큼의 시간이 소요된다.</li>\n<li>삽입 : 동작 자체만으로는 <code class=\"language-text\">O(1)</code>이 걸리지만, 원하는 위치를 찾기 위해 LinkedList를 순회해야 하기 때문에 평균적으로 <code class=\"language-text\">O(n)</code>이 소요된다. 단, 맨 앞에 삽입하는 경우는 <code class=\"language-text\">O(1)</code>이 소요된다.</li>\n<li>삭제 : 삽입과 동일. 맨 앞 삭제는 <code class=\"language-text\">O(1)</code>, 맨 뒤 삭제는 <code class=\"language-text\">tail</code> 에 대한 정보가 있어도 <code class=\"language-text\">O(n)</code>이 걸리는데 그 이유는 마지막 원소를 가리키는 직전 원소를 찾기 위해 <code class=\"language-text\">O(n)</code>의 시간이 걸리기 때문이다.</li>\n</ul>\n<p>그럼에도 LinkedList가 중요한 이유는 Tree 구조를 이해할때 필수적이기 때문이다.</p>\n<h3 id=\"doubly-linked-list\" style=\"position:relative;\"><a href=\"#doubly-linked-list\" aria-label=\"doubly linked list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Doubly Linked List</h3>\n<p>앞서 살펴본 Linked List는 일반적으로 Singly Linked List를 지칭하는 말이다. Singly Linked List는 아래처럼 다음 원소를 가리키는 <code class=\"language-text\">next</code> 포인터 하나만을 가지고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\tNode<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이에 반해서 Doubly Linked List는 <code class=\"language-text\">next</code> 포인터와 그 직전 원소를 가리키는 <code class=\"language-text\">prev</code> 포인터 역시 가지고 있는 아래와 같은 구조를 띈다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\tNode<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n\tNode<span class=\"token operator\">*</span> prev<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또 일반 Singly Linked List와는 다르게 헤드 역시 Node로 이루어져 있다.</p>\n<ul>\n<li>\n<p>삽입 : new_node를 삽입하는 과정인데 살펴볼 필요가 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 465px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.222222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABgUlEQVQoz4WS/0sbQRDF7///SwqWqASvKBYFf4jWREETiTa2NWnOYBPvS27vdmf37lPuUuR6sXRgWGb3zePNm/UARAxP0ynL1aoqKcvyLdvRfHsvvZJNUxIlFNZtERRlSeEchdYURcH/wqv4VskrZ+NzepNLLr5dcT655Hh0RhRHGBHyJEHPA3KtEWN4jUL636/pPfZr/MXjgMPhKT9fAjy1TrmffWVn0OXT/Qn+wwl+r8PHqwN+LZeIteg0JV8s0GLQuebH/ImD3i7+8Aj/4ZT9m0M+XHeZLeZ4lUznHGIFYwURIVs8o1VWj1ARWqORMMQ6V2O1MaggQHS+6bFS39cjv2c8eY7Jsn/6ZLTGpQpantZLaW6uCqVU7RliidcRt9MRt7O7TU5H9CcDXJrilGJd4Vqb95rsza1WhLPJkP3+Ht3xMd3xZ/wbn86XDhLFVUONpfW9vLbk+vxTW2cJXp5RkhGrhDhLyEX/hWlbtqWwOX4UhgTzgExlW169KWsp/A3KKwBoS6V3QwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/9ec5b65f5a55161515d9d75b9fab7e31/9ff85/insert.png\"\n        srcset=\"/static/9ec5b65f5a55161515d9d75b9fab7e31/e9ff0/insert.png 180w,\n/static/9ec5b65f5a55161515d9d75b9fab7e31/f21e7/insert.png 360w,\n/static/9ec5b65f5a55161515d9d75b9fab7e31/9ff85/insert.png 465w\"\n        sizes=\"(max-width: 465px) 100vw, 465px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>new_node의 <code class=\"language-text\">prev</code>가 before을 가리키게 한다.</li>\n<li>new_node의 <code class=\"language-text\">next</code>가 before의 <code class=\"language-text\">next</code>를 가리키게 한다.</li>\n<li>before의 <code class=\"language-text\">next</code>의 <code class=\"language-text\">prev</code>가 new_node를 가리키게 한다.</li>\n<li>before의 <code class=\"language-text\">next</code>가 new_node를 가리키게 한다.</li>\n</ol>\n<p>이 과정에서 순서에 유의해야 하는데, 1번은 언제 일어나도 상관이 없다.\n하지만 2번,3번의 경우 4번보다 먼저 일어나야 하는데, 그렇지 않으면 before의 <code class=\"language-text\">next</code>가 가리키는 node를 접근 할 방법이 없어지기 때문이다. 또 당연히 첫 순서로 실행되어서는 안된다.</p>\n</li>\n<li>\n<p>삭제 : removed node를 삭제하려는 과정이다. removed의 이중 연결을 해제해주고, removed의 <code class=\"language-text\">next</code>와 <code class=\"language-text\">prev</code>를 서로 연결시켜준다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 541px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABa0lEQVQoz22Rb2/TMBDG8/2/CS/QJKatK7QrDE0MOtqmqhqgjEY04c3+FM1JY59j/1AcOrrSR3qsO/vu/NxdBOCcwxiD1jqwMhpTWwLqGlNVSKWDHeI96J34JteICW9RLZZJOuNo0qGTDDhLBrz6fMybURfE4axgqyrQWwEjpGnC6bTL6bxPZ37Oy9EJL4bHbFRJpDcVSfaNi8UV1/mUDz+u6Y37LPKvoAUvQqUUWhX4RoVYVtkN/VGP4Srm088J779/JM4TalsTsQfRhvXdQ7D90/EXvnWstdzf3nEIkfeehs0cG5j1GjWJsUq1ySKIMYgItbU479FZhponuLoO/21rNIzYudjaRaEoHhVxOuNk2uN8cUkvueBo3KEbv0X9fgyLYK9YUMizjv4VLYuS0c2Us9mAq2zM5XLI6y/viFcJzjr2hTy1fKjYFlYsD7f3reOez2o3btf+T2HLdht5/ovlMqUsNwfbO6TwD4qGsVHFw3W4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/3ff309f03e3a9cc570591c2c2562a1a0/9d576/remove.png\"\n        srcset=\"/static/3ff309f03e3a9cc570591c2c2562a1a0/e9ff0/remove.png 180w,\n/static/3ff309f03e3a9cc570591c2c2562a1a0/f21e7/remove.png 360w,\n/static/3ff309f03e3a9cc570591c2c2562a1a0/9d576/remove.png 541w\"\n        sizes=\"(max-width: 541px) 100vw, 541px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>removed의 prev가 removed의 <code class=\"language-text\">next</code>를 가리키게 한다.</li>\n<li>removed의 next가 removed의 <code class=\"language-text\">prev</code>를 가리키게 한다.</li>\n</ol>\n<p>두 연산은 순서를 바꿔도 상관이 없다.</p>\n</li>\n<li>\n<p>조회 : Doubly Linked List에는 <code class=\"language-text\">prev</code> 포인터가 있기 때문에, 최악의 경우 <code class=\"language-text\">O(n)</code>이 소모되었던 Singly Linked List와는 다르게 <code class=\"language-text\">O(n/2)</code>의 시간 안에 찾을 수 있다. 찾으려는 원소의 인덱스의 범위에 따라 <code class=\"language-text\">end</code>에서 <code class=\"language-text\">prev</code> 포인터를 이용해서 돌아가거나, <code class=\"language-text\">head</code>에서 <code class=\"language-text\">next</code> 포인터를 이용해 찾는 방법이다. 또, 직전 원소를 찾는 before도 쉽게 구현 할 수 있다.</p>\n</li>\n</ul>\n<p>이런 장점을 이용해서 연속적인 탐색과 접근에 유리하지만 , 구현이 상대적으로 복잡하고 <code class=\"language-text\">prev</code> 포인터를 유지해야 하기 때문에 메모리 사용량이 2배 정도 증가한다.</p>\n<p>하지만 사용성때문에 플레이리스트, 되돌리기와 같은 기능에 사용되는 자료구조다.</p>\n<h2 id=\"array-vs-linkedlist\" style=\"position:relative;\"><a href=\"#array-vs-linkedlist\" aria-label=\"array vs linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array vs LinkedList</h2>\n<p>일반론적인 얘기에서 조회는 <strong>Random Access</strong>를 지원하는 Array가 <code class=\"language-text\">O(1)</code>의 시간복잡도를 가지고 있어서 LinkedList보다는 빠르다.</p>\n<p>삽입과 삭제는 모두 LinkedList가 빠르다고 하지만 이유에 대해서 조금 더 면밀하게 살펴볼 필요가 있다.</p>\n<p><em>빠르다</em> 라고 하는 것은 삽입과 삭제 그 자체에 주목하는 부분이다.\n만약 바꿔야 할(삽입 혹은 삭제) 위치를 정확히 아는 상태에서는 Array보다 LinkedList가 항상 빠르다. 단순히 <code class=\"language-text\">next</code> 포인터만 변경해주면 되기 때문이다.</p>\n<p>평균적인 경우에서는 Linkedlist는 <code class=\"language-text\">O(n/2)</code>개의 원소들을 살펴보아야 하고, Array도 동일한 원소의 개수들을 shift 해줘야하니 비슷하다.</p>\n<p>그렇기 때문에 Usage에 따라 두 자료구조를 적절히 아래와 같이 선택해야 한다.</p>\n<ul>\n<li>삽입과 삭제가 빈번하게 일어나는 경우 →  <strong>LinkedList</strong></li>\n<li>데이터에 대한 접근(Access)가 빈번하게 일어나는 경우 → <strong>Array</strong></li>\n</ul>\n<h3 id=\"cache\" style=\"position:relative;\"><a href=\"#cache\" aria-label=\"cache permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cache</h3>\n<p>또 한가지 더 깊게 생각해보자면, <strong>캐싱</strong>과 연관이 있다. 정확히 말하면 <strong>Spatial Locality.</strong></p>\n<p>CPU가 일을 처리할때는 메모리에서 필요한 데이터를 로드하고, 일부를 캐싱한다. 그 캐시 안에 들어있는 요소들을 레지스터로 가져와서 일을 처리하는데, 이 과정에서 차이가 발생한다.</p>\n<p>LinkedList는 데이터들의 주솟값들이 서로 연속적이지 않기 때문에, loop를 돌때 (Iterator든 뭐든) 매번 다음 메모리 주소를 찾아야 하고 , CPU가 메모리에 계속적으로 접근해서 로드하는 과정이 생길 수 있다.</p>\n<p><strong>불필요한 오버헤드가 생기는 것이다.</strong></p>\n<p>반대로 배열은 연결된 데이터 구조를 가지기 때문에, 특정 영역에 존재하는 데이터들을 한번에 로드해와서 bulk들을 캐싱한다.\n그렇기에 loop를 돌때도 Array가 매우 크지 않으면 이미 캐시되어 있는 리소스들을 사용할 수 있게 되고 LinkedList와 비교했을 때 상대적으로 적은 메모리 접근이 일어나니 더 빠르다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#array\">Array</a></p>\n</li>\n<li>\n<p><a href=\"#arraylist\">ArrayList</a></p>\n</li>\n<li>\n<p><a href=\"#linkedlist\">LinkedList</a></p>\n<ul>\n<li><a href=\"#doubly-linked-list\">Doubly Linked List</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#array-vs-linkedlist\">Array vs LinkedList</a></p>\n<ul>\n<li><a href=\"#cache\">Cache</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 24, 2022","title":"Array와 Linked List","categories":"자료구조","author":"weasel","emoji":"📓"},"fields":{"slug":"/array-and-linked-list/"}},"prev":{"id":"900d1f47-ef6d-5598-b1bb-f6ffd1f5c715","html":"<h2 id=\"stack\" style=\"position:relative;\"><a href=\"#stack\" aria-label=\"stack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack</h2>\n<p>선형자료구조의 일종으로 LIFO의 특성을 가지고 있다. 가장 처음 들어간 원소가 가장 나중에 접근 가능 하고, 다시 말해서 호출 시에 가장 최근의 원소에 접근 할 수 있다. <code class=\"language-text\">O(n)</code>의 공간복잡도를 가진다.</p>\n<p>링크드 리스트를 이용한 구현과 배열을 이용한(정확히는 Dynamic Array) 두가지 버전이 있다. 링크드 리스트는 일관적인 시간복잡도 <code class=\"language-text\">O(1)</code>를 보여주는 대신에 추가적인 메모리 사용량(<em>Node 구조를 유지하는데 드는</em>)과 메모리 할당에 추가적인 비용이 들 수 있다.</p>\n<ul>\n<li>조회 : Top에 있는 원소를 조회할때는 <code class=\"language-text\">O(1)</code>, 하지만 특정한 데이터를 찾고자 할때는 <code class=\"language-text\">O(n)</code>이다.</li>\n<li>삽입 : 링크드 리스트를 이용한 구현에서는 단순히 기존의 Top 원소를 새 원소의 <code class=\"language-text\">next</code> 로 연결시켜주고 <code class=\"language-text\">head</code> 의 포인터에 새로운 원소를 연결시켜주면 되기 때문에 <code class=\"language-text\">O(1)</code>이다.</li>\n</ul>\n<p>배열을 이용한 구현에서도 특정 상황(Dynamic array의 팽창)을 제외하고는 <code class=\"language-text\">O(1)</code>이니 <code class=\"language-text\">amoritezd\\ O(1)</code>이다.</p>\n<ul>\n<li>삭제 : 링크드 리스트와 배열 모두 <code class=\"language-text\">O(1)</code>이다.</li>\n</ul>\n<h3 id=\"활용\" style=\"position:relative;\"><a href=\"#%ED%99%9C%EC%9A%A9\" aria-label=\"활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>활용</h3>\n<ul>\n<li>Stack Usage : JVM stack, 컴파일러에서 문법 체크(matching parentheses)</li>\n</ul>\n<blockquote>\n<p>💡 프로그램의 함수 호출과 실행 순서는 아래와 같으니</p>\n<ol>\n<li>스택프레임에 지역변수,매개변수,복귀주소등의 정보를 저장하고</li>\n<li>함수의 실행이 끝나면 stack frame의 top을 pop한 후 복귀 주소로 복귀한다</li>\n</ol>\n<p>가장 마지막에 호출된 함수를 가장 먼저 처리하고 복귀하는 후입선출의 구조를 처리하기 위해서 스택을 이용해서 관리한다.</p>\n</blockquote>\n<h2 id=\"queue\" style=\"position:relative;\"><a href=\"#queue\" aria-label=\"queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue</h2>\n<p>선형자료구조로 FIFO의 특성을 가지고 있다. 먼저 들어간 원소가 가장 먼저 나오는 구조를 가지고 있다. <code class=\"language-text\">O(n)</code>의 공간복잡도를 가진다.</p>\n<p>배열을 이용해 구현할때는 단순 배열보다 원형 구조 (circular queue)를 이용해서 구현한다. 혹은 링크드 리스트를 이용해서 구현할수 도 있는데 이때는 <code class=\"language-text\">head</code> 와 <code class=\"language-text\">tail</code> 에 대한 정보를 기록해야 한다.</p>\n<ul>\n<li>조회 : 가장 끝에 있는 원소를 조회할때는 <code class=\"language-text\">O(1)</code>.</li>\n<li>삽입 : 링크드 리스트를 이용한 구현해서는 <code class=\"language-text\">O(1)</code>. 동적 배열을 이용할때는 <code class=\"language-text\">amoritezd\\ O(1)</code>이다. 원형 배열을 이용할때는 <code class=\"language-text\">O(1)</code>.</li>\n<li>삭제 : 모두 <code class=\"language-text\">O(1)</code>.</li>\n</ul>\n<p>스택과 큐 모두 배열을 이용하거나 링크드 리스트를 이용해 구현가능한데, 배열을 사용하는 경우에는 Dynamic array의 팽창을 고려해야하기 때문에 최악의 경우에는 느리지만, 전반적인 성능이 좋다. 반대로 링크드 리스트를 이용한 구현에서는 일관된 성능(<code class=\"language-text\">O(1)</code>)을 보여주지만, 메모리 할당에 들어가는 추가적인 비용 때문에 런타임 성능이 낮을 수 있다.</p>\n<h3 id=\"활용-1\" style=\"position:relative;\"><a href=\"#%ED%99%9C%EC%9A%A9-1\" aria-label=\"활용 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>활용</h3>\n<ul>\n<li>Queue Usage : 스케쥴링,키보드 버퍼 → 두 개 모두 데이터 혹은 요청이 입력된 시간 순서대로 처리해야할 필요가 있을 경우에 사용한다.</li>\n</ul>\n<h2 id=\"문제들\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EB%93%A4\" aria-label=\"문제들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제들</h2>\n<ul>\n<li>\n<p><strong>두 개의 스택으로 큐를 구현하기</strong></p>\n<p>생각보다 엄청 간단하다. 두 개의 스택을 각각 <code class=\"language-text\">in</code>과 <code class=\"language-text\">out</code>으로 구분하고, A,B,C 세개의 데이터가 입력으로 주어진다고 해보자. 출력은 A,B,C가 나와야 한다.</p>\n<ol>\n<li><code class=\"language-text\">in</code> 에 A,B,C를 차례로 push. 그러면 <code class=\"language-text\">in</code> 에는 <code class=\"language-text\">[A,B,C]</code> 의 순서대로 데이터가 쌓일 것이다.</li>\n<li>그 후 <code class=\"language-text\">in</code> 의 데이터를 각각 pop하면 C,B,A의 순서대로 나올것이다. 그 후  <code class=\"language-text\">out</code> 으로 push해보자. <code class=\"language-text\">out : [C,B,A]</code></li>\n<li>이후 <code class=\"language-text\">out</code> 의 원소들을 순서대로 pop하면 출력은 A,B,C가 나오고 <code class=\"language-text\">out: []</code></li>\n</ol>\n  <aside>\n  💡 네. 2개의 스택을 이용하여 구현할 수 있습니다. Enqueue 연산은 첫번째 스택에 원소를 추가하면 됩니다. Dequeue 연산은 두번째 스택을 이용합니다. 우선 두번째 스택이 비어있다면 첫번째 스택이 빌 때까지 첫번째 스택의 원소를 pop하고 두번째 스택에 push하는 것을 반복합니다. 그리고 두번째 스택이 비어있지 않다면 두번째 스택의 원소를 pop하면 됩니다.\n  </aside>\n</li>\n<li>\n<p><strong>스택에서 min을 <code class=\"language-text\">O(1)</code>에 작동하도록 하기</strong></p>\n<p>일단 최소 요소를 기록하는 <code class=\"language-text\">minEle</code> 변수를 stack 내부에 구현한다. 그 후 아래와 같은 사고방식대로 접근한다.</p>\n<h3 id=\"삽입\" style=\"position:relative;\"><a href=\"#%EC%82%BD%EC%9E%85\" aria-label=\"삽입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삽입</h3>\n<ol>\n<li>만약 스택이 비어있다면 <code class=\"language-text\">x</code> 를 삽입할때, <code class=\"language-text\">minEle=x</code> 로 할당한다.</li>\n<li>그렇지 않다면, <code class=\"language-text\">x</code> 와 <code class=\"language-text\">minEle</code> 의 대소를 비교해야하는데 두가지 경우가 존재한다.\n<ol>\n<li><code class=\"language-text\">x</code>가 <code class=\"language-text\">minEle</code> 보다 크거나 같다면, 그냥 삽입한다.</li>\n<li><code class=\"language-text\">minEle</code> 보다 작다면, <code class=\"language-text\">2x-minEle</code> 를 스택에 삽입하고, <code class=\"language-text\">minEle</code> 를 <code class=\"language-text\">x</code> 로 초기화해준다.</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"삭제\" style=\"position:relative;\"><a href=\"#%EC%82%AD%EC%A0%9C\" aria-label=\"삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삭제</h3>\n<ol>\n<li><code class=\"language-text\">y</code> 가 <code class=\"language-text\">min</code> 보다 크거나 같으면, <code class=\"language-text\">y</code> 를 그냥 삭제한다. 여전히 최소값은 <code class=\"language-text\">minEle</code> 다. 그리고 그 값은 스택이 아닌 <code class=\"language-text\">minELe</code> 에 있다고 보는것이 맞다.</li>\n<li><code class=\"language-text\">y</code> 가 <code class=\"language-text\">minEle</code> 보다 작을 경우에, <code class=\"language-text\">minEle</code> 를 <code class=\"language-text\">2*minEle-y</code> 로 변경해준다.</li>\n</ol>\n<h3 id=\"원리\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EB%A6%AC\" aria-label=\"원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원리</h3>\n<p><code class=\"language-text\">minEle</code> 보다 작은 원소가 삽입될때 우리는 <code class=\"language-text\">2x-minEle</code> 를 삽입하는데, 언제나 그것은 <code class=\"language-text\">x</code> 보다는 작다는 것이다.</p>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#stack\">Stack</a></p>\n<ul>\n<li><a href=\"#%ED%99%9C%EC%9A%A9\">활용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#queue\">Queue</a></p>\n<ul>\n<li><a href=\"#%ED%99%9C%EC%9A%A9-1\">활용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%AC%B8%EC%A0%9C%EB%93%A4\">문제들</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"February 01, 2022","title":"Stack과 Queue","categories":"자료구조","author":"weasel","emoji":"📓"},"fields":{"slug":"/stack-and-queue/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/virtual-memory/","nextSlug":"/array-and-linked-list/","prevSlug":"/stack-and-queue/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}