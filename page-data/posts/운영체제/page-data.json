{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/운영체제",
    "result": {"pageContext":{"currentCategory":"운영체제","categories":["All","운영체제","네트워크","자료구조","Java","회고","Spring","PS","Python"],"edges":[{"node":{"id":"95b5f682-4b6d-53b8-b194-e0e45169e5dd","excerpt":"난 운영체제가 제일 재밌고 좋다. 최고👍 세마포어와 뮤텍스를 본격적으로 얘기하기에 앞서서 두 방법이 나오게 된 문제상황인 Race Condition과 Critical-Section을 먼저 소개한다. Race condition 두 개 이상의 프로세스가 공유 데이터에 대해서 동시에 접근하고 조작하려하는 상황을 의미한다. 즉 Race라는 뜻 그대로 하나의 자원을 놓고 서로 경쟁하려는 상태이다. 이 공유된 데이터의 마지막 값은 어느 프로세스가 마지막으로 끝내는지에 따라 달려있다. 만약 interleaved execution(서로 번갈가면서 명령어 수행시) 데이터의 무결성이 침해받는다. → 불확실성 이것을 예방하기 위해서, 동시에 진행되는 프로세스는 반드시 동기화가 되어야 한다. Critical-Section 이러한 문제를 임계구역(Critical-Section) 문제라고 한다. 임계구역이란 동일한 자원에 대해서 접근하는 영역을 의미한다.\n해결하기 위해서는, 한 프로세스가 임계구역에 진입해…","fields":{"slug":"/mutex-and-semaphore/"},"frontmatter":{"categories":"운영체제","title":"Mutex와 Semaphore","date":"February 05, 2022"}},"next":{"fields":{"slug":"/tcp-and-udp/"}},"previous":null},{"node":{"id":"52e5803d-bf0b-5f07-aa36-e75d5d721256","excerpt":"일단 프로세스 스케쥴링 알고리즘에 대해서 언급하기 전에, 프로세스의 상태와 Context-Switching에 대해서 알아야 한다. 여러가지 프로세스의 상태를 기반으로 전이(Transition)되며 이를 바탕으로 스케쥴링 알고리즘이 이루어진다. 프로세스의 상태  프로세스의 상태는 OS에 따라서 개수도 다르고, 명칭도 조금 다르지만, 가장 대표적인 그림은 위의 상태와 같다.  : 프로세스가 생성된 상태이다. 이때는 Readuy Queue 안에 들어 있지 않기 때문에 CPU를 받을 대상이 아니다.  : 프로세스가 CPU를 할당받기 위해 대기하는 상태이다. 보통 Ready Queue 안에 들어와있는 상태라고 얘기한다. 스케쥴링의 대상이 된다.  : 현재 CPU를 할당받아 작업중인 상태다. Single core 시스템에서는 1개다.  : 프로세스가 입출력이나 이벤트가 끝나기를 기다리는 상태이다.  : 프로세스가 종료된 상태다. 단 프로세스 구조체가 사라진 것은 아니다. 그림에서 프로세스의 …","fields":{"slug":"/process-scheduling-algorithm/"},"frontmatter":{"categories":"운영체제","title":"프로세스 스케쥴링 알고리즘","date":"December 25, 2021"}},"next":{"fields":{"slug":"/process-and-thread/"}},"previous":{"fields":{"slug":"/hash-table/"}}},{"node":{"id":"d35d9a2d-dc83-5898-a8d1-3b9f7d2f1a79","excerpt":"프로세스란, 실행중인 프로그램을 의미한다.\n프로그램을 실행하기 위해서는 주소공간,파일,메모리 등이 필요한데 운영체제로부터 이런 것을 할당받은 프로그램을 프로세스라 한다. 프로그램은 어떤 작업을 수행하기 위한 파일로써 정적인 상태이고, 프로세스는 그 작업을 수행하는 동적인 상태다. 프로세스의 메모리 구조 프로세스는 아래 그림과 같은 메모리 구조를 띄고 있다.  프로세스는 각자 본인이 사용하는 메모리 영역과 레지스터 값을 가진다. 프로세스의 메모리 영역은 코드,데이터,힙,스택 영역으로 구성된다. 코드 : 사용자가 작성한 프로그램 함수들의 코드가 기계어 명령 형태로 변경되어 저장되는 공간 데이터 : 전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터를 저장하는 공간 스택 : 함수의 복귀주소와 지역변수,매개변수,반환값을 저장하는 공간. 재귀함수가 반복되거나 지역변수가 너무 많으면 stack overflow 발생. 가변적이다. 힙 : 프로세스 실행 중에 런타임에 할당되는 영역.…","fields":{"slug":"/process-and-thread/"},"frontmatter":{"categories":"운영체제","title":"프로세스와 쓰레드","date":"December 25, 2021"}},"next":{"fields":{"slug":"/junior-student-challege-to-kakao-2022/"}},"previous":{"fields":{"slug":"/process-scheduling-algorithm/"}}},{"node":{"id":"5d077397-5291-5ba2-8fbc-ceb75966ec5d","excerpt":"운영체제 과제 4(double indirect inode) 테스트 환경 OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 운영체제 네번째 과제인 double indirect inode에 대한 내용입니다. 크게 fs.c안의 bmap , itrunc함수를 수정하고, fs.h와 file.h, param.h의 값을 조금 수정함으로써 double indirect inode를 구현합니다. 과제 명세 먼저 xv6의 기본적인 inode의 구조에 대한 간단한 구조입니다.\nimage dinode 구조체에서 direct block pointer는 12개가 존재하고, 1개의 indirect block pointer가 존재합니다. 그런 구조를 아래와 같이 수정해야합니다.\nimage dinode 구조체에서 direct block pointer가 11개로 바뀌고, 1개의 single indirect block pointer, 그리고 1개의 dobule indirect block pointer…","fields":{"slug":"/os-xv6-double-indirect-node/"},"frontmatter":{"categories":"운영체제","title":"운영체제 과제 4 (Double indirect inode)","date":"June 21, 2019"}},"next":{"fields":{"slug":"/os-xv6-thread/"}},"previous":{"fields":{"slug":"/starategy-design-pattern-with-in-spring-boot-application/"}}},{"node":{"id":"855c7bac-c3be-59d4-9b55-84e267962b13","excerpt":"운영체제 과제 3(LWP) 테스트 환경 OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 운영체제 세번째 과제인 Light-weight Process인 Thread에 대한 내용입니다. 크게 thread_create, thread_exit, thread_join을 통해 구현됩니다. thread 구현을 위한 proc 구조체 변경사항 image  등을 추가했습니다.\n그중에서  creator 멤버는 기존 proc 구조체의 parent와 비슷한 역할을 수행합니다. 이번 설계에서 process와 thread_create를 통해 생성된 thread는 parent-child 관계가 아니고 pid도 다르기 때문에 creator라는 포인터를 가짐으로써 최소한의 연결 관계를 유지해줍니다. 이 방식은 아래에서 다시 설명합니다. (단 프로세스의 경우에는 creator와 parent가 같다고 생각합니다.) 기본적인 Thread 기능 명세 먼저 Thread의 기본 명세는 다음과 같습니다.\ni…","fields":{"slug":"/os-xv6-thread/"},"frontmatter":{"categories":"운영체제","title":"운영체제 과제 3 (LWP)","date":"June 02, 2019"}},"next":{"fields":{"slug":"/os-xv6-scheduler/"}},"previous":{"fields":{"slug":"/os-xv6-double-indirect-node/"}}},{"node":{"id":"6b3dc350-65b2-5e76-bbc1-dbd475110e49","excerpt":"운영체제 과제 2(implementing simple schedulers on xv6) 테스트 환경 OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 운영체제 두번째 과제인 Implementing simple schedulers (FCFS,MLFQ) 에 대한 내용입니다. 크게 FCFS 정책과 MLFQ 정책을 사용하게끔 분기됩니다. FCFS 과제 명세 : 먼저 FCFS 스케쥴링의 명세는 다음과 같습니다.\nimage 먼저 생성(fork())된 프로세스가 먼저 스케줄링 되어야 한다. 스케줄링된 프로세스는 종료되기 전까지는 swithc-out 되지 않는다. 프로세스가 스케쥴링 된 이후 100ticks이 지날때까지 종료되거나 sleeping 하지 않으면 종료해야한다. 실행중인 프로세스가 sleeping으로 전환되면 다음 프로세스가 스케줄링된다. sleeping 상태이면서 먼저 생성된 P가 깨어나면 그 프로세스로 스케줄링 된다. 작동과정 설명 : 첫번째로 FCFS 스케쥴링 정…","fields":{"slug":"/os-xv6-scheduler/"},"frontmatter":{"categories":"운영체제","title":"운영체제 과제 2 (Implementing simple schedulers on xv6)","date":"April 28, 2019"}},"next":{"fields":{"slug":"/os-user-level-unix-shell/"}},"previous":{"fields":{"slug":"/os-xv6-thread/"}}},{"node":{"id":"ae05463a-541b-597c-acfd-185ccfe382cc","excerpt":"운영체제 과제 1 ( Simple User-level Unix Shell) 테스트 환경 : OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 : 운영체제 첫번째 과제인 Simple User-level Unix shell에 대한 내용입니다. 크게 interactvie mode와 batch mode로 나뉘어지고\n사용자가 입력한 명령 혹은 batch file을 읽어와서 명령을 수행하고 그 결과를 출력하는 프로그램입니다. 작동과정 설명 : Interactvie Mode 첫번째로 interactvie mode내에서의 작동 과정과 예시입니다.\n크게 사용자로부터 입력을 받아오고, 입력을 특정한 기준을 가지고 분할하여\nexecvp 함수를 사용하여 처리합니다. fgets() 함수를 통해 사용자에게 입력을 받습니다. strtok 함수를 사용하여 semi-colon과 space를 기준으로 raw한 입력을 유의미하게 분할합니다. 분할된 명령어들은 char* 이차원 배열에 저장됩니다. 명…","fields":{"slug":"/os-user-level-unix-shell/"},"frontmatter":{"categories":"운영체제","title":"운영체제 과제 1 (Simple User-level Unix Shell)","date":"March 28, 2019"}},"next":null,"previous":{"fields":{"slug":"/os-xv6-scheduler/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}