{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/운영체제",
    "result": {"pageContext":{"currentCategory":"운영체제","categories":["All","Spring","Python","운영체제","네트워크","자료구조","Java","회고","PS"],"edges":[{"node":{"id":"01585043-5594-5707-8533-9be6484f7713","excerpt":"이전편 : 가상 메모리 지역성 페이지 교체 알고리즘에 대해 언급하기 전에 먼저 지역성이라는 것에 대해서 알아야 한다. 시간 지역성 (Temporal Locality ) : 현재 참조된 메모리가 가까운 미래내에 참조될 가능성이 높음 loop,subroutine,stack 공간 지역성 (Spatial Locality) : 하나의 메모리가 참조되면 주변의 메모리가 참조될 가능성이 높음 Array 순회, 명령어의 순차실행 프로그램의 메모리 참조는 고도의 지역성을 가진다. 임의의 시간 Δt 내에 프로그램의 일부분만을 집중적으로 참조한다는 것이다. 이러한 지역성이 있기 때문에 적절한 페이지 교체 알고리즘이 중요하다. 왜 중요할까? 예를 들어서 주기적으로 두개의 페이지만 참조하는 로직이 있다고 해보자. 만약 그 두개의 페이지를 번갈아가면서 교체를 한다면, 페이지 폴트는 두 개의 페이지에 대해서 접근할때마다 계속 일어날 것이다. 이게 왜 위험하냐면, 불필요한 I/O 작업의 오버헤드도 있고, 그때…","fields":{"slug":"/page-replacement-algorithm/"},"frontmatter":{"categories":"운영체제","title":"운영체제의 메모리 훔쳐보기 3편 - 페이지 교체 알고리즘","date":"February 06, 2022"}},"next":{"fields":{"slug":"/mutex-and-semaphore/"}},"previous":{"fields":{"slug":"/GIL/"}}},{"node":{"id":"95b5f682-4b6d-53b8-b194-e0e45169e5dd","excerpt":"난 운영체제가 제일 재밌고 좋다. 최고👍 세마포어와 뮤텍스를 본격적으로 얘기하기에 앞서서 두 방법이 나오게 된 문제상황인 Race Condition과 Critical-Section을 먼저 소개한다. Race condition 두 개 이상의 프로세스가 공유 데이터에 대해서 동시에 접근하고 조작하려하는 상황을 의미한다. 즉 Race라는 뜻 그대로 하나의 자원을 놓고 서로 경쟁하려는 상태이다. 이 공유된 데이터의 마지막 값은 어느 프로세스가 마지막으로 끝내는지에 따라 달려있다. 만약 interleaved execution(서로 번갈가면서 명령어 수행시) 데이터의 무결성이 침해받는다. → 불확실성 이것을 예방하기 위해서, 동시에 진행되는 프로세스는 반드시 동기화가 되어야 한다. Critical-Section 이러한 문제를 임계구역(Critical-Section) 문제라고 한다. 임계구역이란 동일한 자원에 대해서 접근하는 영역을 의미한다.\n해결하기 위해서는, 한 프로세스가 임계구역에 진입해…","fields":{"slug":"/mutex-and-semaphore/"},"frontmatter":{"categories":"운영체제","title":"Mutex와 Semaphore","date":"February 05, 2022"}},"next":{"fields":{"slug":"/tcp-and-udp/"}},"previous":{"fields":{"slug":"/page-replacement-algorithm/"}}},{"node":{"id":"0606884e-0e00-5db9-977f-c93b84fcca9a","excerpt":"이전편 : 페이징 가상 메모리 (Virtual Memory) 가상 메모리는 논리적 메모리와 물리 메모리를 분리시켜, 프로세스 전체가 메모리내에 올라오지 않아도 실행가능하도록 하는 기법이다. 물론 프로그램이 실행되기 위해서는 메모리에 프로세스가 올라와야 하는것은 맞다. 하지만 특정 부분을 실행할때는 그 부분만 메모리 위에 올라와있어도 구동이 된다. 그렇기 때문에 논리적 주소공간은 실제 물리적 주소공간보다 훨씬 커도 된다. 왜냐면, 어차피 일부만 실행할때 필요하니까..\n그럼 가장 핵심적인 기술은 프로세스를 실행할때, 필요한 메모리를 불러오고(swapped in) 필요하지 않은 부분은 내리는(swapped out) 과정이 필요하다. 가상메모리는 요구 페이징(Demand Paging) 이라는 기술로 구현된다. 특정 페이지에 대한 수요가 있을때, 즉 페이지에 대한 참조 요청이 들어왔을때 페이지를 메모리로 불러오는것이다.\n다시 말해서 기존의 방법과는 다르게 가상 메모리 방식을 취하면, 시작할…","fields":{"slug":"/virtual-memory/"},"frontmatter":{"categories":"운영체제","title":"운영체제의 메모리 훔쳐보기 2편 - 가상 메모리(Virtual Memory)","date":"January 28, 2022"}},"next":{"fields":{"slug":"/array-and-linked-list/"}},"previous":{"fields":{"slug":"/stack-and-queue/"}}},{"node":{"id":"e48d5d5a-bf06-58d2-8af3-e6be8b866fd0","excerpt":"운영체제의 핵심 부분인 하나인 메모리 관리에 대해서 적겠다. 대략 3편으로 구성되며 페이징,가상메모리,페이지 교체 알고리즘 순이다. MMU CPU는 프로세스를 구동할 때 PC를 참조해서 다음 명령어를 메모리에서 가져온다. 명령어를 참고해 필요한 데이터가 있으면 메모리에서 가져오는데 이때 주소체계가 서로 다르다. 아래의 그림처럼 base와 limit 레지스터 안에 있는 값들을 조합해서 CPU가 사용하는 주소(논리 주소)와 실제 메모리 주소(물리 주소)를 구할 수 있다.\n 그러면 왜 두 주소를 구분하였을까? 가장 큰 이유는 보안이다. Limit 레지스터를 둠으로써, P1이 P2의 메모리 영역을 참조하는 Memory Illegal Access를 방지하는 Protection의 기능을 수행한다. MMU는 Memory-Management Unit의 약자로 위에서 말한 논리주소를 물리주소로 대응시켜주는 HW 장치이다. MMU 방식에서는 relocation 레지스터가 존재하는데, 프로세스가 메모…","fields":{"slug":"/paging/"},"frontmatter":{"categories":"운영체제","title":"운영체제의 메모리 훔쳐보기 1편 - 페이징(Paging)","date":"January 17, 2022"}},"next":{"fields":{"slug":"/jvm-change-in-java8/"}},"previous":{"fields":{"slug":"/array-and-linked-list/"}}},{"node":{"id":"52e5803d-bf0b-5f07-aa36-e75d5d721256","excerpt":"일단 프로세스 스케쥴링 알고리즘에 대해서 언급하기 전에, 프로세스의 상태와 Context-Switching에 대해서 알아야 한다. 여러가지 프로세스의 상태를 기반으로 전이(Transition)되며 이를 바탕으로 스케쥴링 알고리즘이 이루어진다. 프로세스의 상태  프로세스의 상태는 OS에 따라서 개수도 다르고, 명칭도 조금 다르지만, 가장 대표적인 그림은 위의 상태와 같다.  : 프로세스가 생성된 상태이다. 이때는 Readuy Queue 안에 들어 있지 않기 때문에 CPU를 받을 대상이 아니다.  : 프로세스가 CPU를 할당받기 위해 대기하는 상태이다. 보통 Ready Queue 안에 들어와있는 상태라고 얘기한다. 스케쥴링의 대상이 된다.  : 현재 CPU를 할당받아 작업중인 상태다. Single core 시스템에서는 1개다.  : 프로세스가 입출력이나 이벤트가 끝나기를 기다리는 상태이다.  : 프로세스가 종료된 상태다. 단 프로세스 구조체가 사라진 것은 아니다. 그림에서 프로세스의 …","fields":{"slug":"/process-scheduling-algorithm/"},"frontmatter":{"categories":"운영체제","title":"프로세스 스케쥴링 알고리즘","date":"December 25, 2021"}},"next":{"fields":{"slug":"/process-and-thread/"}},"previous":{"fields":{"slug":"/hash-table/"}}},{"node":{"id":"d35d9a2d-dc83-5898-a8d1-3b9f7d2f1a79","excerpt":"프로세스란, 실행중인 프로그램을 의미한다.\n프로그램을 실행하기 위해서는 주소공간,파일,메모리 등이 필요한데 운영체제로부터 이런 것을 할당받은 프로그램을 프로세스라 한다. 프로그램은 어떤 작업을 수행하기 위한 파일로써 정적인 상태이고, 프로세스는 그 작업을 수행하는 동적인 상태다. 프로세스의 메모리 구조 프로세스는 아래 그림과 같은 메모리 구조를 띄고 있다.  프로세스는 각자 본인이 사용하는 메모리 영역과 레지스터 값을 가진다. 프로세스의 메모리 영역은 코드,데이터,힙,스택 영역으로 구성된다. 코드 : 사용자가 작성한 프로그램 함수들의 코드가 기계어 명령 형태로 변경되어 저장되는 공간 데이터 : 전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터를 저장하는 공간 스택 : 함수의 복귀주소와 지역변수,매개변수,반환값을 저장하는 공간. 재귀함수가 반복되거나 지역변수가 너무 많으면 stack overflow 발생. 가변적이다. 힙 : 프로세스 실행 중에 런타임에 할당되는 영역.…","fields":{"slug":"/process-and-thread/"},"frontmatter":{"categories":"운영체제","title":"프로세스와 쓰레드","date":"December 25, 2021"}},"next":{"fields":{"slug":"/junior-student-challege-to-kakao-2022/"}},"previous":{"fields":{"slug":"/process-scheduling-algorithm/"}}},{"node":{"id":"5d077397-5291-5ba2-8fbc-ceb75966ec5d","excerpt":"운영체제 과제 4(double indirect inode) 테스트 환경 OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 운영체제 네번째 과제인 double indirect inode에 대한 내용입니다. 크게 fs.c안의 bmap , itrunc함수를 수정하고, fs.h와 file.h, param.h의 값을 조금 수정함으로써 double indirect inode를 구현합니다. 과제 명세 먼저 xv6의 기본적인 inode의 구조에 대한 간단한 구조입니다.\nimage dinode 구조체에서 direct block pointer는 12개가 존재하고, 1개의 indirect block pointer가 존재합니다. 그런 구조를 아래와 같이 수정해야합니다.\nimage dinode 구조체에서 direct block pointer가 11개로 바뀌고, 1개의 single indirect block pointer, 그리고 1개의 dobule indirect block pointer…","fields":{"slug":"/os-xv6-double-indirect-node/"},"frontmatter":{"categories":"운영체제","title":"운영체제 과제 4 (Double indirect inode)","date":"June 21, 2019"}},"next":{"fields":{"slug":"/os-xv6-thread/"}},"previous":{"fields":{"slug":"/starategy-design-pattern-with-in-spring-boot-application/"}}},{"node":{"id":"855c7bac-c3be-59d4-9b55-84e267962b13","excerpt":"운영체제 과제 3(LWP) 테스트 환경 OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 운영체제 세번째 과제인 Light-weight Process인 Thread에 대한 내용입니다. 크게 thread_create, thread_exit, thread_join을 통해 구현됩니다. thread 구현을 위한 proc 구조체 변경사항 image  등을 추가했습니다.\n그중에서  creator 멤버는 기존 proc 구조체의 parent와 비슷한 역할을 수행합니다. 이번 설계에서 process와 thread_create를 통해 생성된 thread는 parent-child 관계가 아니고 pid도 다르기 때문에 creator라는 포인터를 가짐으로써 최소한의 연결 관계를 유지해줍니다. 이 방식은 아래에서 다시 설명합니다. (단 프로세스의 경우에는 creator와 parent가 같다고 생각합니다.) 기본적인 Thread 기능 명세 먼저 Thread의 기본 명세는 다음과 같습니다.\ni…","fields":{"slug":"/os-xv6-thread/"},"frontmatter":{"categories":"운영체제","title":"운영체제 과제 3 (LWP)","date":"June 02, 2019"}},"next":{"fields":{"slug":"/os-xv6-scheduler/"}},"previous":{"fields":{"slug":"/os-xv6-double-indirect-node/"}}},{"node":{"id":"6b3dc350-65b2-5e76-bbc1-dbd475110e49","excerpt":"운영체제 과제 2(implementing simple schedulers on xv6) 테스트 환경 OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 운영체제 두번째 과제인 Implementing simple schedulers (FCFS,MLFQ) 에 대한 내용입니다. 크게 FCFS 정책과 MLFQ 정책을 사용하게끔 분기됩니다. FCFS 과제 명세 : 먼저 FCFS 스케쥴링의 명세는 다음과 같습니다.\nimage 먼저 생성(fork())된 프로세스가 먼저 스케줄링 되어야 한다. 스케줄링된 프로세스는 종료되기 전까지는 swithc-out 되지 않는다. 프로세스가 스케쥴링 된 이후 100ticks이 지날때까지 종료되거나 sleeping 하지 않으면 종료해야한다. 실행중인 프로세스가 sleeping으로 전환되면 다음 프로세스가 스케줄링된다. sleeping 상태이면서 먼저 생성된 P가 깨어나면 그 프로세스로 스케줄링 된다. 작동과정 설명 : 첫번째로 FCFS 스케쥴링 정…","fields":{"slug":"/os-xv6-scheduler/"},"frontmatter":{"categories":"운영체제","title":"운영체제 과제 2 (Implementing simple schedulers on xv6)","date":"April 28, 2019"}},"next":{"fields":{"slug":"/os-user-level-unix-shell/"}},"previous":{"fields":{"slug":"/os-xv6-thread/"}}},{"node":{"id":"ae05463a-541b-597c-acfd-185ccfe382cc","excerpt":"운영체제 과제 1 ( Simple User-level Unix Shell) 테스트 환경 : OS : Ubuntu 16.04 gcc : gcc 5.4.0 개요 : 운영체제 첫번째 과제인 Simple User-level Unix shell에 대한 내용입니다. 크게 interactvie mode와 batch mode로 나뉘어지고\n사용자가 입력한 명령 혹은 batch file을 읽어와서 명령을 수행하고 그 결과를 출력하는 프로그램입니다. 작동과정 설명 : Interactvie Mode 첫번째로 interactvie mode내에서의 작동 과정과 예시입니다.\n크게 사용자로부터 입력을 받아오고, 입력을 특정한 기준을 가지고 분할하여\nexecvp 함수를 사용하여 처리합니다. fgets() 함수를 통해 사용자에게 입력을 받습니다. strtok 함수를 사용하여 semi-colon과 space를 기준으로 raw한 입력을 유의미하게 분할합니다. 분할된 명령어들은 char* 이차원 배열에 저장됩니다. 명…","fields":{"slug":"/os-user-level-unix-shell/"},"frontmatter":{"categories":"운영체제","title":"운영체제 과제 1 (Simple User-level Unix Shell)","date":"March 28, 2019"}},"next":null,"previous":{"fields":{"slug":"/os-xv6-scheduler/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}