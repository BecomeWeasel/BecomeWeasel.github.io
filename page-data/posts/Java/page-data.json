{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/Java",
    "result": {"pageContext":{"currentCategory":"Java","categories":["All","운영체제","네트워크","자료구조","Java","회고","Spring","PS","Python"],"edges":[{"node":{"id":"970ad7e7-c529-5911-b5d5-ca08c1dcb821","excerpt":"Java 7의 JVM \n기존의 Java 7 까지의 Non Heap Area였던 Permanent Generation이 Native 영역인 Metaspace로 바뀌었다. 기존의 Permanent 영역에는 아래와 같은 정보들이 저장되었다. Class의 메타데이터 (바이트코드 포함) Method의 메타데이터 static 객체, static 상수 상수화된 String Object Class와 관련된 배열 객체 메타데이터 JVM 내부적인 객체들과 JIT의 최적화 정보 OOM 문제점 이런 많은것들이 PermG안에 있다보니 , String Constant Pool, static object, Class 메타 데이터들이 쌓여 OOM이 발생하곤 했다. PermG는 시작할때부터 크게 잡지 않는 이상 리사이징이 되지 않아 그런 문제가 발생하곤 했다. 좋은 글 Java 8의 JVM \nJava 8에서부턴 PermG 영역을 삭제하고 Metaspace 영역을 추가해 Native 메모리의 영역으로 이동시켰다.…","fields":{"slug":"/jvm-change-in-java8/"},"frontmatter":{"categories":"Java","title":"JVM의 Java 8에서의 변화","date":"January 13, 2022"}},"next":{"fields":{"slug":"/hash-table/"}},"previous":{"fields":{"slug":"/paging/"}}},{"node":{"id":"b98e3e53-8195-5969-aa57-8c541f9543d1","excerpt":"GC를 수행하는 Garabage Collector는 아래와 같은 일을 한다. 메모리 할당 사용 중인 메모리 인식 미사용 메모리 인식 Stop-the-World 자바 애플리케이션은 GC 실행시 GC 실행 스레드를 제외한 모든 스레들르 멈추고, GC 완료 후 다시 스레드들을 실행 상태로 변경 Stop the World는 모든 애플리케이션 스레드들의 작업이 멈추는 상태 어떤 GC 알고리즘을 사용해도 Stop-the-World는 불가피하며 대개의 GC 튜닝이란 이 Stop-the-World 시간을 줄이는 것이다. 전제 가비지 컬렉터는 두가지 전제 조건 하에서 만들어졌다. 대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다. 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다. 이것을 ‘weak generational hypothesis’라고 하는데 이것을 살리기 위해서 Young 영역과 Old 영역으로 나누었다. Young 영역 (Young Generation 영역…","fields":{"slug":"/java-gc/"},"frontmatter":{"categories":"Java","title":"Java의 알쏭달쏭한 GC","date":"November 05, 2021"}},"next":{"fields":{"slug":"/programmers-flip-card/"}},"previous":{"fields":{"slug":"/how-spring-handler-mapping-works-2/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}