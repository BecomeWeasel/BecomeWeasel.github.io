{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/spring-core-chap1/",
    "result": {"data":{"cur":{"id":"2b1ab9c1-7d44-5a52-b72a-91915d8fa2ea","html":"<h2 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가며</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 423px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAG2BJkB/8QAFhABAQEAAAAAAAAAAAAAAAAAAAEx/9oACAEBAAEFAlXf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQABPyFX/9oADAMBAAIAAwAAABB8P//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQADAQEAAAAAAAAAAAAAAAEAESFxkf/aAAgBAQABPxBbetRtOnkO7n//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"마션\"\n        title=\"마션\"\n        src=\"/static/b7c4d40935bbbcbb299372593889fec7/b7bea/martian.jpg\"\n        srcset=\"/static/b7c4d40935bbbcbb299372593889fec7/4ec73/martian.jpg 180w,\n/static/b7c4d40935bbbcbb299372593889fec7/158ba/martian.jpg 360w,\n/static/b7c4d40935bbbcbb299372593889fec7/b7bea/martian.jpg 423w\"\n        sizes=\"(max-width: 423px) 100vw, 423px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>마션이라는 책에서 가장 유명한 파트이다. 그리고 나는 저 도입부에 <strong>100%</strong> 공감하고 있다.</p>\n<p>현장실습을 3월 2일자로 시작하면서, 이젠 돌이킬 수 없는 4학년이고 취업 전선에 뛰어든 신세다.<br>\n그렇기에 현장실습과 코딩테스트, CS 스터디를 두개씩 동시에 하고 있으며 개인 Spring 프로젝트를 준비하고 있다.</p>\n<p>그중에서도 빼놓을 수 업는 중요한 것은 Spring에 대한 공부라고 생각한다.<br>\n물론 Spring에 대한 지식이 전혀 없는 것은 아니다. 공부를 하면 했지, 절대 하지 않은 것은 아니다.<br>\n하지만 그럼에도 <strong>나는 왜 다시 스프링을 공부해야 하는가?</strong></p>\n<p>항상 참인 명제인 <em><strong>나는 생각보다 멍청하고, 배운것을 모조리 까먹는다는 것이다.</strong></em></p>\n<p>그렇기에 Spring의 1타 강사 아니 사실 인프런 1타 강사인것 같은 김영한 님의 강의를 듣기로 했다.</p>\n<blockquote>\n<p>물론 강의가 중요한 것은 아니지만, 내가 쌩돈 내면서 결제하면 그나마 열심히 할 것 같아서..</p>\n</blockquote>\n<p>그래서 공부한 것들을 내 <strong>기억이 아닌 기록</strong>에 의존하려 한다.</p>\n<h1 id=\"객체-지향-설계와-스프링\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\" aria-label=\"객체 지향 설계와 스프링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 설계와 스프링</h1>\n<h2 id=\"스프링의-진짜-핵심\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%A7%84%EC%A7%9C-%ED%95%B5%EC%8B%AC\" aria-label=\"스프링의 진짜 핵심 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링의 진짜 핵심</h2>\n<ul>\n<li>스프링은 자바 언어 기반의 프레임워크</li>\n<li>자바 언어의 가장 큰 특징 : 객체 지향 언어\n<ul>\n<li>즉, 스프링은 객체 지향 언어가 가진 강력한 특징을 살려냄으로써 <strong>좋은 객체 지향</strong> 어플리케이션을 개발할 수 있게 도와주는 프레임워크다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"좋은-객체-지향-프로그래밍은\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%80\" aria-label=\"좋은 객체 지향 프로그래밍은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋은 객체 지향 프로그래밍은…</h2>\n<p>프로그램을 단순히 명령어의 목록으로 보는것에서 벗어나, <strong>객체들의 모임</strong>으로 파악하는 것.<br>\n객체끼리는 메시지를 주고받으며 데이터를 처리한다.</p>\n<p>또 유연하고 변경이 용이하다는 특징이 있다… 이 난해한 말은 간단히 말해서 <strong>레고를 조립</strong>하듯이 프로그램을 개발하는 것이다.</p>\n<h2 id=\"다형성\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"다형성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성</h2>\n<p>실제 우리가 살고 있는 세계와 객체 지향은 완전히 대응시키기는 어렵지만,<br>\n실생활에서의 예제를 <strong>역할</strong>과 <strong>구현</strong>으로 나눠서 보면 좋다.</p>\n<p>운전자와 자동차들이 있다고 해보자.<br>\n운전자는 운전만 하고, 자동차는 굴러가기만 하면 되는것이다.</p>\n<p>즉, 타고 있는 <strong>자동차가 바뀌어도 운전자는 아무 신경쓰지 않고 그대로 운전을 할 수 있어야 한다.</strong></p>\n<p>다시 말해서 자동차의 <strong>구현</strong>과 운전자를 분리한 이유는 운전자가 자동차의 내부적인 동작 방식에 대해서 모르더라도 운전자에게 영향을 주지 않기 위함이다.</p>\n<p>이렇게 자동차가 K3,아반떼,벤츠,BMW … 등으로 운전자에게 영향을 주지 않고 자동차의 종류를 무한히 확장가능한 이것을 <strong>다형성</strong>이라고 한다.</p>\n<p>이를 통해서 새로운 자동차가 등장하더라도, <strong>운전자는 새로운 자동차의 내부적인 방식에 대해서 신경 쓸 필요가 전혀 없다.</strong> 그저 굴러가는 자동차일뿐이다.</p>\n<h3 id=\"달성하고자-하는-것\" style=\"position:relative;\"><a href=\"#%EB%8B%AC%EC%84%B1%ED%95%98%EA%B3%A0%EC%9E%90-%ED%95%98%EB%8A%94-%EA%B2%83\" aria-label=\"달성하고자 하는 것 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>달성하고자 하는 것</h3>\n<p><strong>역할</strong>과 <strong>구현</strong>으로 세상을 바라보면 세상이 <strong>단순</strong>해지고, <strong>유연</strong>해지고 <strong>변경</strong>이 편리하다.</p>\n<p>아까 운전자의 예시를 그대로 들면,</p>\n<ol>\n<li>운전자는 자동차라는 인터페이스의 역할만 알면 된다.</li>\n<li>운전자는 자동차의 내부 구조를 몰라도 된다.</li>\n<li>운전자는 자동차가 전기로 가든, 기름으로 가든, 뒤에서 밀어서 가든 내부구조가 변경되어도 영향을 받지 않게 된다.</li>\n<li>운전자는 자동차의 종류가 변하는 상황에서도 영향을 받지 않는다.</li>\n</ol>\n<p>자바에서는 <strong>역할</strong>은 인터페이스로, <strong>구현</strong>은 인터페이스를 구현한 클래스이다.</p>\n<h3 id=\"자바에서의-다형성\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"자바에서의 다형성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바에서의 다형성</h3>\n<p>대표적인 예시가 상위 클래스 혹은 인터페이스의 메소드를 재정의하는 <strong>오버라이딩</strong>이다.</p>\n<p>클라이언트는 서버의 인터페이스의 함수를 호출하면서, 서버 내의 메소드가 어떻게 구성되어있는지는 관심이 없으며, 서버는 <strong>런타임</strong>에 필요에 의해 <strong>구현을 유연하게 변경</strong>하여 적용할 수 있다.</p>\n<p>이를 통해 <strong>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경</strong>할 수 있다.</p>\n<h2 id=\"스프링과-객체-지향\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5\" aria-label=\"스프링과 객체 지향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링과 객체 지향</h2>\n<p>결국 가장 중요한 것은 <strong>다양성</strong>이다.</p>\n<p>스프링은 이 다형성을 극대화하게 이용할 수 있게 도와주는 것이다.<br>\n<strong>DI,IOC</strong>와 같은 개념들 역시 다형성을 서포트하는 기능들이다.</p>\n<h2 id=\"solid\" style=\"position:relative;\"><a href=\"#solid\" aria-label=\"solid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SOLID</h2>\n<p>로버트 마틴이 주장한 객체지향 설계 5가지 원칙을 앞 글자만 따서 SOLID라고 한다.</p>\n<h3 id=\"srp--단일-책임-원칙\" style=\"position:relative;\"><a href=\"#srp--%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\" aria-label=\"srp  단일 책임 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SRP : 단일 책임 원칙</h3>\n<p>한 클래스는 <strong>하나의 책임</strong>만을 가져야 하는데, 이 <strong>책임</strong>이라는 것은 모호하다. 문맥에 따라서 클 수도 있고, 작을 수도 있다.</p>\n<p>가장 중요한 기준은 <strong>변경</strong>이다. <strong>어떠한 변경점이 있을때 클래스에 미치는 파급효과가 적으면</strong> SRP를 잘 따른 것이다.</p>\n<blockquote>\n<p>하나의 클래스에 DB접근,View 로직,비즈니스 로직이 다 들어가 있다고 생각해보자.<br>\nDB에 변경점이 생기면, 클래스 전체가 바뀌어야 한다. SRP를 잘 지키지 못한 예시다.</p>\n</blockquote>\n<h3 id=\"ocp--개방-폐쇄-원칙\" style=\"position:relative;\"><a href=\"#ocp--%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\" aria-label=\"ocp  개방 폐쇄 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OCP : 개방 폐쇄 원칙</h3>\n<p><strong>가장 중요한 원칙이다.</strong><br>\n요소들이 <strong>확장에는 열려 있고 변경에는 닫혀</strong> 있어야 한다. 근데 확장을 하는데 어떻게 변경 없이 한다는 것일까?</p>\n<p>처음으로 돌아가서 다형성을 생각해보자.<br>\n운전자와 자동차의 관계에서 자동차의 모델이 바뀔때\n<strong>역할이 확장</strong>된다고 해도 기존의 자동차 모델 구현은 <strong>변경이 필요하지 않는 것이다.</strong></p>\n<p>인터페이스를 구현한 새로운 클래스를 만듦으로써 확장한다고 해보자.<br>\n<strong>그러면 인터페이스는 변경되지 않으며, 확장은 일어난다.</strong></p>\n<p>근데 이것이 정말 변경이 없을까? 요리를 예시로 들어보자.<br>\n예를 들어 고든 램지는 나에게 요리를 시키고, 나는 요리를 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">내 kitchen 인터페이스와 클래스가 이렇다고 해보자.\n\ninterface kitchen:    \n    func cook()\n\nclass fryKitchen :\n    @오버라이드\n    func cook():\n        fry()\n\nclass boilKitchen :\n    @오버라이드\n    func cook():\n        boil()\n\n램지 do : \nkitchen k= new fryKitchen()\n\nk.cook() -> kitchen 인터페이스 안에 있는 cook을 호출\n\n나는 kitchen 인터페이스 안에서 기존에는 구워서(fry()) 해서 만드는데,\n만약 삶아서 요리를 하는것으로 변경한다면?\n\n아마 코드는 이렇게 변할 것이다.\n\n램지의 do :\n# kitchen k = new fryKitchen()\nkitchen k = new boilKitchen()\n\nk.cook() -> kitchen 인터페이스 안에 있는 cook을 호출\n\n고든 램지의 행동은 여전히 같다. 하지만 k에 대해서 코드가 변경이 일어난다. 이상하다...</code></pre></div>\n<p>위 코드에서의 문제점은 <strong><code class=\"language-text\">kitchen</code>에 대한 구현 객체</strong>를 직접 선택하는데 있다.<br>\n<strong>내가 다형성을 사용한게 확실한데, OCP 원칙을 위반</strong>하는 것이다.</p>\n<p>이 문제를 해결하기 위해서는 객체를 생성하고 연관관계를 맺어주는 <strong>별도의 설정자, 조립자</strong>가 필요하다.</p>\n<h3 id=\"lsp--리스코프-치환-원칙\" style=\"position:relative;\"><a href=\"#lsp--%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99\" aria-label=\"lsp  리스코프 치환 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LSP : 리스코프 치환 원칙</h3>\n<p>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.</p>\n<p>이게 무슨 소리일까…</p>\n<p>아까 위의 요리 사례에서 <code class=\"language-text\">kitchen</code> 인터페이스의 메소드인 <code class=\"language-text\">cook()</code>은 어쨌든 요리를 만드는 메소드다.<br>\n<code class=\"language-text\">fryKitchen</code> 이건, <code class=\"language-text\">boilKitchen</code>이건 요리가 만들어져야 하는 것이다.</p>\n<p>내가 <code class=\"language-text\">kitchen</code> 인터페이스를 구현하면서 <code class=\"language-text\">cook()</code> 메소드를 요리가 아닌 음쓰를 만든다면?<br>\n<code class=\"language-text\">kitchen</code> 인터페이스를 믿고 사용할 수 있을까?<br>\n조금 타더라도, 조금 느리더라도 <code class=\"language-text\">cook()</code>을 호출하면 <strong>요리는 만들어져야</strong> 한다.</p>\n<blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 672px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 126.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,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'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"wow\"\n        title=\"wow\"\n        src=\"/static/599793b7cfdf1d3fe82e4c031b73117e/30d16/wow.png\"\n        srcset=\"/static/599793b7cfdf1d3fe82e4c031b73117e/e9ff0/wow.png 180w,\n/static/599793b7cfdf1d3fe82e4c031b73117e/f21e7/wow.png 360w,\n/static/599793b7cfdf1d3fe82e4c031b73117e/30d16/wow.png 672w\"\n        sizes=\"(max-width: 672px) 100vw, 672px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\nLSP를 위반한 대표적인 사례 : 와갤요리</p>\n</blockquote>\n<p>즉, 하위 클래스는 인터페이스 규약을 다 지켜야 하는 것이다.<br>\n단순히 컴파일 시점에서의 성공의 얘기가 아닌 의미론적으로 맞아야 한다는 것이다.</p>\n<h3 id=\"isp--인터페이스-분리-원칙\" style=\"position:relative;\"><a href=\"#isp--%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\" aria-label=\"isp  인터페이스 분리 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ISP : 인터페이스 분리 원칙</h3>\n<p>특정 클래스를 위한 인터페이스 여러 개가 범용적인 인터페이스 하나보다 낫다.</p>\n<p>간단히 얘기해서 인터페이스를 작게 분리함으로써 <strong>명확하게끔하고, 대체가능성을 높</strong>이라는 것이다.</p>\n<p>위의 예시를 요리와 서빙, 포장으로 나누어보자.\n<code class=\"language-text\">kitchen</code> 인터페이스와 <code class=\"language-text\">serve</code> 인터페이스와 <code class=\"language-text\">pack</code> 인터페이스를 각각 분리함으로써<br>\n각각의 인터페이스를 명확하게 하고, 적절히 조합함으로써 대체 가능성을 높이는 것이다.</p>\n<h3 id=\"dip--의존관계-역전-원칙\" style=\"position:relative;\"><a href=\"#dip--%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99\" aria-label=\"dip  의존관계 역전 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DIP : 의존관계 역전 원칙</h3>\n<p>OCP 만큼이나 중요한 원칙이다.</p>\n<p>프로그래머는 <em><strong>“추상화에 의존해야지, 구체화에 의존하면 안된다.”</strong></em> 의존성 주입은 이 원칙을 따르는 방법 중 하나다.</p>\n<p>앞서 이야기한 역할에 의존하게 해야한다는 것과 같은 맥락이다.<br>\n클라이언트가 인터페이스가 아닌 구현체에 의존하게 되면 변경이 어려워진다.</p>\n<p>즉, 고든 램지는 내가 요리를 한다는 것에만 관심이 있지 구워서 만들지, 삶아서 만들지에 대해서는 관심이 없어야 한다는 것이다.<br>\n<strong>구워서 만드는 것이 어떻게 이루어지는지, 삶는 방법은 어떤지에 대해서 관심 끄라는 얘기!</strong> <del>이세계 고든 램지</del></p>\n<p>아까의 OCP 사례가 문제점이 있다고 했으니 다시 가져와보자.</p>\n<p>램지의 행동을 잘 보면 <code class=\"language-text\">kitchen k</code> 는 구현 클래스인 <code class=\"language-text\">fryKitchen</code>과 <code class=\"language-text\">boilKitchen</code>에 의존하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">램지 do :\n# kitchen k = new fryKitchen()\nkitchen k = new boilKitchen()</code></pre></div>\n<blockquote>\n<p>여기서 의존한다라는 것은 강사님이 말하길 “저 코드를 알기만 하면 의존이다.”</p>\n</blockquote>\n<p>클라이언트인 고든 램지가 직접 어떤 구현 클래스를 선택할지 선택함으로써 클라이언트가 <code class=\"language-text\">fryKitchen</code>과 <code class=\"language-text\">boilKitchen</code>에 의존하고 있다.</p>\n<p>이 부분에서 <strong>DIP</strong>를 위반하는 것이다.</p>\n<h2 id=\"다형성만으로는-부족해\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1%EB%A7%8C%EC%9C%BC%EB%A1%9C%EB%8A%94-%EB%B6%80%EC%A1%B1%ED%95%B4\" aria-label=\"다형성만으로는 부족해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성만으로는 부족해</h2>\n<p>객체지향의 핵심은 다형성인것은 분명하지만, 다형성만으로는 쉽게 갈아끼우는 레고처럼 개발할 수 없다.<br>\n다형성만 사용해서는 구현 객체를 변경할때 클라이언트인 램지의 행동도 변경이 된다.<br>\n다형성만으로는 <strong>OCP,DIP</strong>를 지킬 수 없는 것이다.</p>\n<p>뭔가가 더 필요하다.. More and More</p>\n<h2 id=\"객체-지향-설계와-스프링-1\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-1\" aria-label=\"객체 지향 설계와 스프링 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 설계와 스프링</h2>\n<p>스프링은 <strong>DI(Dependency Injection)</strong> 을 이용해서 OCP,DIP를 가능하게끔 해준다.<br>\n즉, 우리가 원하는 대로 레고를 조립하듯이 개발을 할 수 있게끔 해준다.</p>\n<blockquote>\n<p>DI 개념은 솔직히 공부만으로는 잘 이해가 안간다. 면접에서 받은 질문 중에 하나..</p>\n</blockquote>\n<p>앞으로 코드를 직접 작성해보면서 의존성 주입을 이해하며 스프링의 재미를 느끼고 싶다. <del>아니 느껴야 한다.</del></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\">들어가며</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%A7%84%EC%A7%9C-%ED%95%B5%EC%8B%AC\">스프링의 진짜 핵심</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%80\">좋은 객체 지향 프로그래밍은…</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\">다형성</a></p>\n<ul>\n<li><a href=\"#%EB%8B%AC%EC%84%B1%ED%95%98%EA%B3%A0%EC%9E%90-%ED%95%98%EB%8A%94-%EA%B2%83\">달성하고자 하는 것</a></li>\n<li><a href=\"#%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1\">자바에서의 다형성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5\">스프링과 객체 지향</a></p>\n</li>\n<li>\n<p><a href=\"#solid\">SOLID</a></p>\n<ul>\n<li><a href=\"#srp--%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\">SRP : 단일 책임 원칙</a></li>\n<li><a href=\"#ocp--%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\">OCP : 개방 폐쇄 원칙</a></li>\n<li><a href=\"#lsp--%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99\">LSP : 리스코프 치환 원칙</a></li>\n<li><a href=\"#isp--%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\">ISP : 인터페이스 분리 원칙</a></li>\n<li><a href=\"#dip--%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99\">DIP : 의존관계 역전 원칙</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1%EB%A7%8C%EC%9C%BC%EB%A1%9C%EB%8A%94-%EB%B6%80%EC%A1%B1%ED%95%B4\">다형성만으로는 부족해</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\">객체 지향 설계와 스프링</a></p>\n</li>\n</ul>\n</div>","excerpt":"들어가며  마션이라는 책에서 가장 유명한 파트이다. 그리고 나는 저 도입부에 100% 공감하고 있다. 현장실습을 3월 2일자로 시작하면서, 이젠 돌이킬 수 없는 4학년이고 취업 전선에 뛰어든 신세다. 그렇기에 현장실습과 코딩테스트, CS 스터디를 두개씩 동시에 하고 있으며 개인 Spring 프로젝트를 준비하고 있다. 그중에서도 빼놓을 수 업는 중요한 것은 Spring에 대한 공부라고 생각한다. 물론 Spring에 대한 지식이 전혀 없는 것은 아니다. 공부를 하면 했지, 절대 하지 않은 것은 아니다. 하지만 그럼에도 나는 왜 다시 스프링을 공부해야 하는가? 항상 참인 명제인 나는 생각보다 멍청하고, 배운것을 모조리 까먹는다는 것이다. 그렇기에 Spring의 1타 강사 아니 사실 인프런 1타 강사인것 같은 김영한 님의 강의를 듣기로 했다. 물론 강의가 중요한 것은 아니지만, 내가 쌩돈 내면서 결제하면 그나마 열심히 할 것 같아서.. 그래서 공부한 것들을 내 기억이 아닌 기록에 의존하려…","frontmatter":{"date":"March 04, 2022","title":"스프링 핵심 원리 - 기본편 : 객체 지향 설계와 스프링","categories":"Spring","author":"weasel","emoji":"📓"},"fields":{"slug":"/spring-core-chap1/"}},"next":{"id":"5a4dee1d-16e6-5c3a-ab6c-8868ee79a5f5","html":"<p><strong>GIL</strong>은 Global Interpreter Lock의 약자이다.</p>\n<p>Global이 붙으니 전역적이라는 의미이고, Lock을 사용하니 무언가를 제한한다는것은 알겠는데 Interpreter는 뭘까?\n인터프리터에 대해서 제한을 건다는 것이 어떤 의미일까?</p>\n<p>아래에서 쭉 알아보자.</p>\n<h2 id=\"interpreter\" style=\"position:relative;\"><a href=\"#interpreter\" aria-label=\"interpreter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interpreter</h2>\n<p>짧게 얘기하면 <strong>Python 인터프리터는 코드를 한 줄씩 읽으면서 실행</strong>하는 프로그램이다.</p>\n<blockquote>\n<p>이 방식때문에 인터프리터 언어가 느리단 얘기가 나오는 것이고, Java에서 이를 개선해서 등장한 방식이 JIT다.</p>\n</blockquote>\n<p>이 인터프리터의 구현체는 여러가지가 있는데 대표적인 구현체가 C로 구현한 것이고, 이를 <strong>CPython</strong>이라고 한다.</p>\n<p>이 글에서는 CPython 기준으로 설명할 것이다.</p>\n<blockquote>\n<p><a href=\"https://wiki.python.org/moin/GlobalInterpreterLock\">Python 위키</a> 항목을 읽어보면 <em><strong>Non-CPython implementations</strong></em>에 Jython, IronPython은 GIL이 없고, PyPy는 CPython과 비슷한 GIL을 가지고 있다. 또 Cython에는 CIL이 존재하지만, <code class=\"language-text\">with</code> 키워드를 이용하여 잠시동안 해제가 가능하다고 한다.</p>\n</blockquote>\n<p>대충 인터프리터가 어떤 의미인지는 알았으니 본론으로 들어가서 GIL에 대해서 알아보자.</p>\n<h2 id=\"gil\" style=\"position:relative;\"><a href=\"#gil\" aria-label=\"gil permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GIL</h2>\n<p><a href=\"https://wiki.python.org/moin/GlobalInterpreterLock\">Python 위키</a>를 계속 참고해보면, 이렇게 정의하고 있다.</p>\n<blockquote>\n<p>In CPython, the <strong>global interpreter lock</strong>, or <strong>GIL</strong>, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. The GIL prevents race conditions and ensures thread safety. A nice explanation of <a href=\"https://python.land/python-concurrency/the-python-gil\">how the Python GIL helps in these areas can be found here</a>. In short, this mutex is necessary mainly because CPython’s memory management is not thread-safe.</p>\n</blockquote>\n<p>중요한 부분 위주로 해석을 해보면,</p>\n<p>GIL은 CPython에서 객체들에 대한 접근을 보호하는 뮤텍스(Mutex)로써, 여러개의 쓰레드가 동시에 파이썬의 바이트코드를 실행하는 것을 방지하는 역할이라는 것이다.<br>\n따라서 GIL은 경쟁 상태에 진입하는 것을 막아주고, 쓰레드 안전성을 보장한다.<br>\n또 간단하게 말해서, <strong>CPython의 메모리 관리가 쓰레드-안전이 아니기 때문에</strong> 뮤텍스가 필요하다는 것이다.</p>\n<p>더 간단하게 말하면, <em>Python 인터프리터에 대해서 전역적으로 잠금</em>이 걸리기 때문에 <strong>한 시점에 오직 하나의 쓰레드만 인터프리터를 실행할 수 있다.</strong></p>\n<p>또 이어지는 설명에서 이렇게 설명을 한다.</p>\n<blockquote>\n<p>In hindsight, the GIL is not ideal, since it prevents multithreaded CPython programs from taking full advantage of multiprocessor systems in certain situations.</p>\n</blockquote>\n<p>해석해보자면 돌이켜보았을때 GIL은 멀티쓰레딩 CPython 프로그램이 특정 상황에서 <strong><em>멀티프로세서 시스템의 장점을 다 사용하지 못</em></strong> 하게끔 하기 때문에 GIL은 이상적이지 않다.</p>\n<blockquote>\n<p>여기서 말하는 멀티프로세서 시스템의 장점은 <strong>멀티 쓰레딩 동작을 할때 여러 개의 쓰레드가 각각의 프로세서 상에서 병렬적으로 실행됨</strong>을 의미한다.</p>\n</blockquote>\n<p>즉, <strong>GIL 때문에 CPython에서는 그러한 병렬적인 실행이 불가능하다는 것이다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB8ElEQVQ4y31TPW/UQBC9Bv4S/AcIFb8BUSJ+AmmCoKUIJZQkUHGKQEgIEqCAIwV0BO7OF1vx2V5/2/v50MydLZ8u8KQn7e7svJmdmR3VdY0oiuD7PqSUMMZAa83rpmmYbdv2e1r/i1VVYUSCDkBelvDOz1f0PHZ2ziEMQwRBwGcUmM6stVskkNaIHHvUDWxdI8syzpSglOI9kdb/A2mNtJR48mOCO++PcPfjWzz9eYqmLCGyHMY6zlykGTsMszPWolUabr0nGwsaqXDv5B2uHT7D9ZfPcf/DG2RxjEik0NYiSgSCcLkSMaYX1MagblV/3gvKtoVflfi+vMDp8gJBVXI22jooY0HVMQ5c5yFIQGqz/WSnFG6OD3Bl/xGu7j/G7aNXbAzjBGe//yARKRqpuH7U/SEpc5oOaliapjwJnOGvTODY93AcLHCWCRak6NpYzpJ4GZRx2xkaKfHg6wl2xge4NT7E3uQzG6tWolUKUmsUVY04jpEkSU8aJ5EV/PSNGpLg7rdPuPH6BT/94eTLKhqJKQ2lqfiSxybPc2ZRFBBCIC8rvrvR5Y05XMOsB5UiU+3o8mWgOg4Huxd03EnH7CZ+sfAwm82Y5DgEZTefzzGdTrkpXUAWJGfqTvcfuzU9i1iW5ZadHDs7/V86I9Jf/guSa978g3z/uwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/135772f5932488ef9186461afe7f1027/37523/example_gil.png\"\n        srcset=\"/static/135772f5932488ef9186461afe7f1027/e9ff0/example_gil.png 180w,\n/static/135772f5932488ef9186461afe7f1027/f21e7/example_gil.png 360w,\n/static/135772f5932488ef9186461afe7f1027/37523/example_gil.png 720w,\n/static/135772f5932488ef9186461afe7f1027/302a4/example_gil.png 1080w,\n/static/135772f5932488ef9186461afe7f1027/6be49/example_gil.png 1160w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"gil의-필요성\" style=\"position:relative;\"><a href=\"#gil%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"gil의 필요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GIL의 필요성</h3>\n<p>괜히 멀티쓰레딩만 방해하고, GIL은 대체 왜 있는걸까?</p>\n<p>이것에 대한 해답은 아까 말한 정의에 나와있다.</p>\n<p><strong><em>GIL is … mutext that protects access to Python Objects.</em></strong></p>\n<p>Python에서 모든 것은 객체로 존재하고, <a href=\"https://github.com/python/cpython/blob/main/Include/object.h\">CPython에서 각각의 객체들이 C 구조체를 통해 만들어진다는 것을 생각해보면,</a> 수 많은 객체에 대응되는 수 많은 구조체가 있음을 알 수 있다.</p>\n<p>그러면 자연스럽게 메모리 관리를 생각하게 된다.</p>\n<p>Python에서 메모리 관리는 참조 횟수(reference count)를 이용해 GC(Garbage Collection)를 수행하는데, 이 참조 횟수가 C 구조체 안에 적혀 있다.\nCPython의 소스코드를 확인해보면 이렇게 코드가 나와있다.</p>\n<blockquote>\n<p><a href=\"https://github.com/python/cpython/blob/main/Include/object.h\">https://github.com/python/cpython/blob/main/Include/object.h</a></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_object</span> <span class=\"token punctuation\">{</span>\n    _PyObject_HEAD_EXTRA\n    Py_ssize_t ob_refcnt<span class=\"token punctuation\">;</span>\n    PyTypeObject <span class=\"token operator\">*</span>ob_type<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> PyObject<span class=\"token punctuation\">;</span></code></pre></div>\n<p>잘 보면 PyObject 구조체 안에 참조 횟수를 <strong>직접 저장</strong>하고 있다.</p>\n<p>운영체제를 열심히 들으신 분이라면 바로 왜 위에서 언급한 <strong>경쟁 상태</strong>가 생길수 있는지 아실 것이다.</p>\n<p>만약 CPython의 의도와는 정반대로 여러개의 쓰레드가 동시에 Python 인터프리터를 실행한다면,<br>\n참조 횟수에 병렬 프로그래밍의 고질적 문제 중 하나인 <a href=\"https://becomeweasel.me/mutex-and-semaphore/#race-condition\"><strong>경쟁 상태</strong></a>가 발생하게 된다.</p>\n<p>단순히 여기서 그치는 것이 아니라 아까 Python GC의 원리가 참조 횟수에 기반을 둔다는 점을 다시 생각한다면,\n<strong>올바르지 않은(비정합적인)</strong> 참조 횟수를 기반으로 GC가 일어남으로써 <strong>GC가 의도한 바와는 다르게 동작할 수 있다는 것이다.</strong></p>\n<p>그렇다고 객체에 대해서 작업을 할때, 좀 더 좁게 말하자면 <strong><code class=\"language-text\">ob_refcnt</code>에 대한 작업을 수행할때마다</strong> 별도의 뮤텍스를 이용해서 Lock을 얻고 해제한다면 비효율적이고, 프로그래머가 일일이 제어하기에는 부담이 가는 작업이다.</p>\n<p>그렇기에 CPython에서는 <strong>한 쓰레드가 인터프리터를 실행 중일때는 다른 쓰레드가 실행하지 못하도록 인터프리터를 잠궈버렸다.</strong><br>\n이렇게 된다면, 객체의 참조 횟수에 대한 경쟁 상태 역시 고려할 필요가 없어진다.</p>\n<blockquote>\n<p>GIL을 선택한 이유에 대해서 조금 더 자세하게 알아보자면, 이 <a href=\"https://softwareengineering.stackexchange.com/questions/186889/why-was-python-written-with-the-gil\">링크</a>와 이 <a href=\"https://realpython.com/python-gil/\">링크</a>를 참조하면 된다.</p>\n</blockquote>\n<blockquote>\n<p>짧게 얘기하자면, Python을 처음 만들때는 쓰레드라는 개념이 인기 있기 전이였고, 그 후에 쓰레드가 등장했을때 가장 <strong>현실적이고 쉬운</strong> 방법이 GIL이였다.</p>\n</blockquote>\n<p>첨언하자면, 왜 GIL이 아닌 다른 해결책을 도입하지 않냐고 하자 Python의 개발자인 <a href=\"https://en.wikipedia.org/wiki/Guido_van_Rossum\"><strong>Guido van Rossum</strong></a>은 이렇게 말했다고 한다.</p>\n<blockquote>\n<p>”단일 쓰레드 프로그램에서(그리고 I/O 바운드 멀티 쓰레드 프로그램) 성능이 저하되지 않는 GIL 해결책을 가지고 오면, 그 해결책을 기쁘게 받아들이겠다.”</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#interpreter\">Interpreter</a></p>\n</li>\n<li>\n<p><a href=\"#gil\">GIL</a></p>\n<ul>\n<li><a href=\"#gil%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\">GIL의 필요성</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"February 08, 2022","title":"GIL 훔쳐보기","categories":"Python","author":"weasel","emoji":"📓"},"fields":{"slug":"/GIL/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/spring-core-chap1/","nextSlug":"/GIL/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}