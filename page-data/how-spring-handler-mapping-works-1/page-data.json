{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/how-spring-handler-mapping-works-1/",
    "result": {"data":{"cur":{"id":"775850b9-bf7d-5165-a970-117498904ad5","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 719px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjElEQVQoz31SO47bMBTUIbbIAXKcRZogVZA27XZ7jXRp9xKB+1zApWHIsGUItCTDkvWzKEqUNME8mI7WcPKAwaMovnnzhvSmaQKj73vEcYzdbgelFMqyhPvHrLWW/f1+jyhSyLIWSv1Cmn5CEHyFUp9R1y/w5oSHwwHr9Rqr1QppmgqRgzEGQRDIvzDcI0lKKLVAnn+B739HGH6D1q/wcA0WHY9HQVVVGIZB9sdxlO8sy5DnuTS21sKYFl034T48FrKIaJoGRVFIYdu2uFwuQsBMCzgBLdlutzidTlchdoYBXl3X4l0UReITCZMkESIWLZdL8c4pnoeza772uq4TBSQmqIwjOYXMbERwdFpCpWzsiObE3rwjjXeKuZ4HFXJs2sJMIfcqhdBtWNtjHHtoTaUFrO3e3TItoKrz+SyknOK/hMYM0BqI41YyzzvfeIaj+74vnm42m9sEDwjHK2GINP2JIPiBpnmDMQv8PTvdXsIc/yAcrg/7N6bpA6rqI7R+grXPcBd7X/Tolh3hH4izTHKPcv51AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image\"\n        title=\"image\"\n        src=\"/static/3ced1b2df8c525ffaec0ce9aa709fff6/073e9/image.png\"\n        srcset=\"/static/3ced1b2df8c525ffaec0ce9aa709fff6/e9ff0/image.png 180w,\n/static/3ced1b2df8c525ffaec0ce9aa709fff6/f21e7/image.png 360w,\n/static/3ced1b2df8c525ffaec0ce9aa709fff6/073e9/image.png 719w\"\n        sizes=\"(max-width: 719px) 100vw, 719px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>글이 매우 복잡하고 깁니다. 양해 부탁드립니다.</p>\n</blockquote>\n<blockquote>\n<p>틀린 정보나 이해가 가지 않는 부분은 댓글 남겨주시면 참고하겠습니다.</p>\n</blockquote>\n<h3 id=\"handlermapping의-역할\" style=\"position:relative;\"><a href=\"#handlermapping%EC%9D%98-%EC%97%AD%ED%95%A0\" aria-label=\"handlermapping의 역할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HandlerMapping의 역할</h3>\n<p>Spring MVC에 대해서 공부하던 중, <code class=\"language-text\">HandlerMapping</code>이 request를 처리하기에 적절한 handler를 찾아온다는 설명을 들었다.\n좀 더 찾아보니 <em><code class=\"language-text\">HandlerMapping</code>은 <strong>request의 URL과 매칭되는 handler</strong>를 선택하는 역할을 수행한다</em> 는 것을 보았다.</p>\n<p>request의 URL만 보고 어떻게 찾아온다는 것일까? 그리고 <em>찾아진</em> handler는 method인데 어떠한 방식으로 가져온다는 것일까?</p>\n<p>한가지만 기억하고 가자.\n<strong>HandlerMapping은 원하는 handler를 찾아오는 역할을 수행한다.</strong></p>\n<h3 id=\"spring-mvc-request-flow\" style=\"position:relative;\"><a href=\"#spring-mvc-request-flow\" aria-label=\"spring mvc request flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring MVC Request flow</h3>\n<p><code class=\"language-text\">HandlerMapping</code>의 역할에 대해서 살펴보기 전에 Spring MVC에서 request가 어떠한 순서로 처리되는지 먼저 보아야 한다.\n<img src=\"https://images.velog.io/images/hsw0194/post/8e1df081-c5d5-4c7c-8a33-699b3d6f6e9e/image.png\" alt=\"처리 순서\"></p>\n<ol>\n<li>먼저 <code class=\"language-text\">front-controller</code>의 역할을 하는 <code class=\"language-text\">DispatcherServlet</code>이 request를 받는다.</li>\n<li><strong><code class=\"language-text\">DispatcherServlet</code>은 적절한 controller를 선택하는 일을 <code class=\"language-text\">HandlerMapping</code>에게 요청한다.</strong></li>\n<li><strong><code class=\"language-text\">HandlerMapping</code>은 적합한 controller를 선택한다.</strong></li>\n<li><code class=\"language-text\">DispatcherServlet</code>은 선택된 controller의 비즈니스 로직 실행 작업을 <code class=\"language-text\">HandlerAdapter</code>에게 위임한다.</li>\n<li><code class=\"language-text\">HandlerAdpater</code>가 controller의 비즈니스 로직을 호출하고 결과를 <code class=\"language-text\">ModelAndView</code> 객체에 담아서 <code class=\"language-text\">DispatcherServlet</code>이 에게 return한다.</li>\n<li><code class=\"language-text\">DispatcherServlet</code>이 <code class=\"language-text\">ViewResolver</code>를 이용하여 결과를 보여줄 View를 가져온다.</li>\n<li>View 객체에게 <code class=\"language-text\">DispatcherServlet</code>이 응답 결과 생성을 요청한다.</li>\n</ol>\n<p>이 긴 과정 속에서 이 글에서 살펴볼 과정은 2,3번이다. Request flow 순서대로 <code class=\"language-text\">HandlerMapping</code>에 대해서 알아볼 것이다.</p>\n<h3 id=\"dispatcherservlet\" style=\"position:relative;\"><a href=\"#dispatcherservlet\" aria-label=\"dispatcherservlet permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DispatcherServlet</h3>\n<p>먼저 <code class=\"language-text\">DispatcherServlet</code>에서 부터 출발해야한다. 상속구조부터 보면,</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DispatcherServlet</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">FrameworkServlet</span>\n\t\t\t↓\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FrameworkServlet</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HttpServletBean</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ApplicationContextAware</span>\n\t\t\t↓\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HttpServletBean</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HttpServlet</span>\n\t\t\t↓\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HttpServlet</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">GenericServlet</span></code></pre></div>\n<p>이렇게 상속구조를 통해 <code class=\"language-text\">DispatcherServlet</code>은 결국 <code class=\"language-text\">HttpServlet</code>을 상속함을 알 수 있다.\n그렇기 때문에 <code class=\"language-text\">DispatcherServlet</code>도 <code class=\"language-text\">Servlet</code>의 생명주기와 비슷하게 흘러감을 알 수 있다. (<code class=\"language-text\">init(),doGet(),doPost(),service() 등등</code>)</p>\n<p>실제로 디버깅을 해보면, <code class=\"language-text\">doService</code>가 호출된다. 그 후 <code class=\"language-text\">DispatcherServlet</code>은 <code class=\"language-text\">front-controller</code> 역할을 하기 때문에 <code class=\"language-text\">doDispatch</code>를 호출한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doService</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpServletResponse</span> response<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">doDispatch</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">doDispatch</code>의 javadoc을 보면 Servlet의 <code class=\"language-text\">HandlerMapping</code>을 순서대로 처리하여 handler를 가져온다고 되어있다.</p>\n<blockquote>\n<p>Process the actual dispatching to the handler. The handler will be obtained by applying the servlet’s HandlerMappings in order. The HandlerAdapter will be obtained by querying the servlet’s installed HandlerAdapters to find the first that supports the handler class.</p>\n</blockquote>\n<p><code class=\"language-text\">doDispatch</code>의 실제 코드를 보면 아래처럼 request에 대해서 handler를 가져오는 <code class=\"language-text\">getHandler</code> 함수를 호출하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doDispatch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpServletResponse</span> response<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        <span class=\"token comment\">// Determine handler for the current request.</span>\n\tmappedHandler <span class=\"token operator\">=</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p><code class=\"language-text\">getHandler</code> 함수는 <code class=\"language-text\">DispatcherServlet</code>의 method로 아래와 같다. 이게 실제로 적절한 handler를 가져오는 방식인데 전혀 감이 안온다. 하나하나 풀이해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Nullable</span>\n<span class=\"token keyword\">protected</span> <span class=\"token class-name\">HandlerExecutionChain</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlerMappings <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HandlerMapping</span> mapping <span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlerMappings<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token class-name\">HandlerExecutionChain</span> handler <span class=\"token operator\">=</span> mapping<span class=\"token punctuation\">.</span><span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>handler <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> handler<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p><code class=\"language-text\">DispathcerServlet</code>은 처음 <code class=\"language-text\">init</code>되는 과정에서 여러가지 <code class=\"language-text\">handlerMapping</code>들을 등록하고 <code class=\"language-text\">List</code>를 통해 <code class=\"language-text\">handlerMappings</code>라는 이름으로 관리하고 있다. <code class=\"language-text\">handelrMappings</code>안에는 여러가지 <code class=\"language-text\">handlerMapping</code>들이 등록되어 있는 것이다.</p>\n</blockquote>\n<p>그러므로 아래 코드는 <em><code class=\"language-text\">DispatcherServlet</code> 안에 <code class=\"language-text\">handlerMapping</code>들이 등록되었다면</em> 이라는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlerMappings<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>등록되어있는 <code class=\"language-text\">HandlerMapping</code>들을 loop 하면서</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HandlerMapping</span> mapping <span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handlerMappings<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n</code></pre></div>\n<p><strong><code class=\"language-text\">HandlerMapping</code>들에게 request에 맞는 handler를 가져오게하고,가져왔다면 그 handler를 return</strong>하는것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">  <span class=\"token class-name\">HandlerExecutionChain</span> handler<span class=\"token operator\">=</span>mapping<span class=\"token punctuation\">.</span><span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>handler<span class=\"token operator\">!=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> handler<span class=\"token punctuation\">;</span></code></pre></div>\n<p>핵심 부분은 <strong><code class=\"language-text\">HandlerMapping</code>에게 request에 맞는 handler를 가져오는</strong> 부분이다. 이게 궁금해서 이 먼 길을 돌아온 것이다.</p>\n<p><code class=\"language-text\">DispatcherServlet</code>부분의 내용을 정리하자면,\n1.<code class=\"language-text\">doService</code>이 호출된다.\n2.<code class=\"language-text\">doService</code>내에서 <code class=\"language-text\">doDispatch</code>가 호출된다.\n3.<code class=\"language-text\">doDispatch</code>내에서 <code class=\"language-text\">getHandler</code>가 호출된다.\n4.<code class=\"language-text\">getHandler</code>내에서 등록된 <code class=\"language-text\">HandlerMapping</code> 중에서 request에 걸맞는 handler를 가져온다.</p>\n<blockquote>\n<p>이제 거의 다왔다.</p>\n</blockquote>\n<h3 id=\"handlermapping이-handler를-가져오는-과정\" style=\"position:relative;\"><a href=\"#handlermapping%EC%9D%B4-handler%EB%A5%BC-%EA%B0%80%EC%A0%B8%EC%98%A4%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"handlermapping이 handler를 가져오는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HandlerMapping이 handler를 가져오는 과정</h3>\n<p><code class=\"language-text\">HandlerMapping</code>은 <code class=\"language-text\">interface</code>로 함수의 선언부만 가지고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">HandlerMapping</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">HandlerExecutionChain</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>실제로 handler를 가져오는 <code class=\"language-text\">getHandler</code>는 추상 클래스인 <code class=\"language-text\">AbstractHandlerMapping</code>에 정의되어 있다.\n우리가 흔히 아는 <code class=\"language-text\">RequestMappingHandlerMapping,SimpleUrlHandlerMapping</code> 같은 것들의 부모(<em>바로 윗단계는 아니지만</em>)가 <code class=\"language-text\">AbstratHandlerMapping</code>이다.</p>\n<p>아래는 <code class=\"language-text\">AbstractHandlerMapping</code>의 <code class=\"language-text\">getHandler</code> 코드이다.\n<code class=\"language-text\">getHandlerInternal</code>을 통해서 handler을 찾아오고, <code class=\"language-text\">HandlerExecutionChain</code>을 return하는데,우리가 원하는건 handler를 찾아오는 방식이므로 <code class=\"language-text\">getHandlerInternal</code>을 봐야겠다.</p>\n<blockquote>\n<p><code class=\"language-text\">HandlerExecutionChain</code>은 간단하게 handler와 handler interceptor들을 모아놓은 것이다.\nHandler execution chain, consisting of handler object and any handler interceptors.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">HandlerExecutionChain</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">Object</span> handler <span class=\"token operator\">=</span> <span class=\"token function\">getHandlerInternal</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token class-name\">HandlerExecutionChain</span> executionChain <span class=\"token operator\">=</span> <span class=\"token function\">getHandlerExecutionChain</span><span class=\"token punctuation\">(</span>handler<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token keyword\">return</span> executionChain<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">getHandlerInternal</code>은 <code class=\"language-text\">AbstractHandlerMapping</code>을 상속한 <code class=\"language-text\">AbstractHandlerMethodMapping</code>에 정의되어 있다.\n<code class=\"language-text\">AbstractHandlerMethodMapping</code>은 복잡하지만 이런 구조를 가지고 있다.\n<img src=\"https://images.velog.io/images/hsw0194/post/3753e0fe-6506-4414-9ee4-c41dc849a312/image.png\" alt=\"\"></p>\n<p>아래는 <code class=\"language-text\">getHandlerInternal</code>의 코드다. 이번에도 차근차근 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractHandlerMethodMapping</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractHandlerMapping</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token comment\">// Look up a handler method for the given request.</span>\n<span class=\"token keyword\">protected</span> <span class=\"token class-name\">HandlerMethod</span> <span class=\"token function\">getHandlerInternal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">String</span> lookupPath <span class=\"token operator\">=</span> <span class=\"token function\">getUrlPathHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLookupPathForRequest</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mappingRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">acquireReadLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">HandlerMethod</span> handlerMethod <span class=\"token operator\">=</span> <span class=\"token function\">lookupHandlerMethod</span><span class=\"token punctuation\">(</span>lookupPath<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>handlerMethod <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> handlerMethod<span class=\"token punctuation\">.</span><span class=\"token function\">createWithResolvedBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mappingRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">releaseReadLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>먼저 javadoc을 보면 <em>주어진 request에 대한 handler method를 찾습니다.</em> 라고 되어있다. 동작원리의 핵심적인 부분인것이다.</p>\n<blockquote>\n<p>Look up a handler method for the given request.</p>\n</blockquote>\n<p><code class=\"language-text\">lookupPath</code>는 현재 servlet mapping 안에서의 검색경로인데, request 요청을 분석해서 얻을 수 있다. 그리고 <strong><code class=\"language-text\">mappingRegistry</code>에 대한 ReadLock을 가져오고 있다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> lookupPath <span class=\"token operator\">=</span> <span class=\"token function\">getUrlPathHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLookupPathForRequest</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mappingRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">acquireReadLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">lookupPath</code>를 바탕으로 <code class=\"language-text\">lookupHandlerMethod</code>를 통해서 <strong>적절한 <code class=\"language-text\">handlerMethod</code>를 가져온 후 return 한다</strong>, 이 <code class=\"language-text\">handlerMethod</code>가 바로 우리가 직접 Controller 안에 정의한 함수인것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">HandlerMethod</span> handlerMethod <span class=\"token operator\">=</span> <span class=\"token function\">lookupHandlerMethod</span><span class=\"token punctuation\">(</span>lookupPath<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>handlerMethod <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> handlerMethod<span class=\"token punctuation\">.</span><span class=\"token function\">createWithResolvedBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>정리해보자면, <code class=\"language-text\">DispatcherServlet</code> 함수 안에서 <code class=\"language-text\">handlerMapping</code>이 여러 과정을 거쳐서 <strong>적절한 <code class=\"language-text\">handlerMethod</code></strong> 를 가져온다는것은 알 수 있다.</p>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/96c33f73-1c61-47c2-920f-965fdadc0bff/Untitled%20Diagram%20(1).jpg\" alt=\"\"></p>\n<p><strong>그러나 궁금증이 더 남아있다. url에 해당하는 적절한 method를 구별하는 방법과, method를 가져오는 것이 여전히 궁금하다.</strong>\n각각 <strong>MappingRegistry</strong>와 <strong>Reflection</strong>이 답이다.</p>\n<p>나머지 궁금증은 2편에서 마저 다루도록 한다.</p>\n<h3 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h3>\n<p><a href=\"https://bgpark.tistory.com/72\">Interceptor 사용법</a> : Request flow에 대해서 잘 정리되어 있었다.\n<a href=\"https://docs.spring.io/spring-framework/docs/4.3.2.RELEASE_to_4.3.3.RELEASE/Spring%20Framework%204.3.3.RELEASE/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.html\">AbstractHandlerMethodMapping javadoc</a>\n<a href=\"https://docs.spring.io/spring-framework/docs/4.3.2.RELEASE_to_4.3.3.RELEASE/Spring%20Framework%204.3.3.RELEASE/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.MappingRegistry.html\">MappingReigstry javadoc</a>\n<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/LinkedMultiValueMap.html\">LinkedMultiValueMap javadoc</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#handlermapping%EC%9D%98-%EC%97%AD%ED%95%A0\">HandlerMapping의 역할</a></li>\n<li><a href=\"#spring-mvc-request-flow\">Spring MVC Request flow</a></li>\n<li><a href=\"#dispatcherservlet\">DispatcherServlet</a></li>\n<li><a href=\"#handlermapping%EC%9D%B4-handler%EB%A5%BC-%EA%B0%80%EC%A0%B8%EC%98%A4%EB%8A%94-%EA%B3%BC%EC%A0%95\">HandlerMapping이 handler를 가져오는 과정</a></li>\n<li><a href=\"#%EC%B6%9C%EC%B2%98\">출처</a></li>\n</ul>\n</div>","excerpt":"글이 매우 복잡하고 깁니다. 양해 부탁드립니다. 틀린 정보나 이해가 가지 않는 부분은 댓글 남겨주시면 참고하겠습니다. HandlerMapping의 역할 Spring MVC에 대해서 공부하던 중, 이 request를 처리하기에 적절한 handler를 찾아온다는 설명을 들었다.\n좀 더 찾아보니 은 request의 URL과 매칭되는 handler를 선택하는 역할을 수행한다 는 것을 보았다. request의 URL만 보고 어떻게 찾아온다는 것일까? 그리고 찾아진 handler는 method인데 어떠한 방식으로 가져온다는 것일까? 한가지만 기억하고 가자.\nHandlerMapping은 원하는 handler를 찾아오는 역할을 수행한다. Spring MVC Request flow 의 역할에 대해서 살펴보기 전에 Spring MVC에서 request가 어떠한 순서로 처리되는지 먼저 보아야 한다.\n처리 순서 먼저 의 역할을 하는 이 request를 받는다. 은 적절한 controller를 선택하는 …","frontmatter":{"date":"June 09, 2021","title":"Spring MVC - HandlerMapping의 동작방식 이해하기 1편","categories":"Spring","author":"weasel","emoji":"📓"},"fields":{"slug":"/how-spring-handler-mapping-works-1/"}},"next":{"id":"fab54913-676d-5548-a4f9-d4855a8db7cc","html":"<h3 id=\"문제-제목\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%A0%9C%EB%AA%A9\" aria-label=\"문제 제목 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 제목</h3>\n<p><a href=\"https://www.acmicpc.net/problem/12904\">12904번 A와 B</a></p>\n<h3 id=\"문제-설명\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\" aria-label=\"문제 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 설명</h3>\n<p>수빈이는 A와 B로만 이루어진 영어 단어가 존재한다는 사실에 놀랐다. 대표적인 예로 AB (Abdominal의 약자), BAA (양의 울음 소리), AA (용암의 종류), ABBA (스웨덴 팝 그룹)이 있다.</p>\n<p>이런 사실에 놀란 수빈이는 간단한 게임을 만들기로 했다. 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다.</p>\n<ol>\n<li>문자열의 뒤에 A를 추가한다.</li>\n<li>문자열을 뒤집고 뒤에 B를 추가한다.</li>\n</ol>\n<p>주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오.</p>\n<h3 id=\"입력\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EB%A0%A5\" aria-label=\"입력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입력</h3>\n<p>첫째 줄에 S가 둘째 줄에 T가 주어진다. (1 ≤ S의 길이 ≤ 999, 2 ≤ T의 길이 ≤ 1000, S의 길이 &#x3C; T의 길이)</p>\n<h3 id=\"출력\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EB%A0%A5\" aria-label=\"출력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출력</h3>\n<p>S를 T로 바꿀 수 있으면 1을 없으면 0을 출력한다.</p>\n<h3 id=\"예제-입출력\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5\" aria-label=\"예제 입출력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예제 입출력</h3>\n<p><strong>입력</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">B\nABBA\n\nAB\nABB</code></pre></div>\n<p><strong>출력</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1\n0</code></pre></div>\n<h3 id=\"풀이\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4\" aria-label=\"풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이</h3>\n<p>가장 먼저 생각난 풀이는 <strong>백트래킹</strong>을 사용해서 <strong>S</strong>가 <strong>T</strong>를 만드는 방법이였다. 매 노드에 대해서 <strong>뒤에 A를 뒤에 추가할지</strong>,<strong>뒤집어서 B를 뒤에 추가할지</strong>의 선택지 뿐이니 매우 간단할 것이라고 생각했지만, 첫 제출은 메모리 초과로 통과하지 못했다.</p>\n<p>그 이유는 입력조건을 잘 보면 알 수 있다. <strong>T</strong>의 최대 길이가 1000이니 매 노드에서 선택지가 두가지 뿐이라고 해도 1000번째 단계의 탐색에서는 선택지가 무려 <strong>2^1000</strong>개에 달한다.\n일반화했을때 <strong>T</strong>의 길이를 <strong>N</strong>이라 할때, 길이가 K(1&#x3C;=K&#x3C;=N)일때의 탐색일때 선택지는 <strong>2^K</strong>개에 달하니 당연히 메모리 초과가 발생할수 밖에 없었다.</p>\n<p>문제의 분류가 그리디 알고리즘이어서 그 다음 떠올린 풀이는 주어진 <strong>S</strong>에 특정 조건에 따라서 <strong>A</strong> 혹은 <strong>B</strong>를 덧붙일지 고려하는것이였는데,(<a href=\"https://www.acmicpc.net/problem/2138\">백준 2138번 전구와 스위치</a>와 비슷한 풀이를 떠올렸다.) 이것도 문제가 생겼다.</p>\n<p><strong>A</strong>는 단순히 뒤에 덧붙이는 것이지만, <strong>B</strong>는 문자열을 뒤집은후 덧붙이는것이기 때문에 경우의 수가 매우 많았다.</p>\n<p>문제를 최대한 단순하게 생각해서 바라보았다.</p>\n<blockquote>\n<p>S에 여러 가지 적당한 연산을 해서 T가 되었다는 것은 <strong>T’에 한가지 연산을 해서 T</strong>가 되었다는 것과, <strong>T”에 한가지 연산을 해서 T’</strong> 이 되는 것이 같다는 것을 생각하게 되었다.</p>\n</blockquote>\n<p>바꿔서 말하면 주어진 목표 문자인 <strong>T</strong>에 각 <strong>연산의 역원</strong>을 계속 수행하다 보면 <strong>S</strong>가 되는지 안 되는지 쉽게 알 수 있다는 것이다.</p>\n<p>예를 들어서 위에서 언급한 <strong>연산의 역원</strong>은 아래와 같다.</p>\n<blockquote>\n<p>문자열의 뒤에 A를 추가한다. -> 끝 문자열 하나를 삭제한다 (A 삭제)</p>\n</blockquote>\n<p>문자열을 뒤집고 뒤에 B를 추가한다. -> 끝 문자열 하나를 삭제하고 뒤집는다.</p>\n<p>그럼 어떤 <strong>연산의 역원</strong>을 수행할지만 판단하면 되는데 이건 판단하기 매우 쉽다. 단순하게 <strong>A</strong>로 끝나면 첫 번째 역원을, <strong>B</strong>로 끝나면 두 번째 역원을 수행하면 되는 것이다.</p>\n<p>이렇게 <strong>연산의 역원</strong>을 계속 수행해서 <strong>T</strong>가 <strong>S</strong>와 길이가 같게 되었을때, <strong>S</strong>와 <strong>T</strong>의 일치여부만 판단해주면 되는것이다.</p>\n<h3 id=\"풀이코드\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4%EC%BD%94%EB%93%9C\" aria-label=\"풀이코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> sys <span class=\"token keyword\">import</span> stdin\n\nS <span class=\"token operator\">=</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span>stdin<span class=\"token punctuation\">.</span>readline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rstrip<span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nT <span class=\"token operator\">=</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span>stdin<span class=\"token punctuation\">.</span>readline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rstrip<span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">sol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">global</span> S<span class=\"token punctuation\">,</span> T\n  <span class=\"token comment\"># 생각을 바꿔서 T에서 한단계씩 이전으로 되돌아가는것임</span>\n  <span class=\"token comment\"># T의 마지막이 A라면 이전은 무조건 T[:len(T)-1]이고</span>\n  <span class=\"token comment\"># T의 마지막이 B라면 이전은 T.pop() 후에 T[::-1]임</span>\n  <span class=\"token comment\"># 이렇게 이전으로 계속 되돌아갔을때 S와 T가 일치하는지만 보면됨</span>\n\n  <span class=\"token comment\"># ctrl-z를 해서 S로 되돌아갈수 잇느냐를 판단</span>\n  <span class=\"token keyword\">while</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># T의 마지막이 A라면 </span>\n    <span class=\"token keyword\">if</span> T<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">:</span>\n      T<span class=\"token operator\">=</span>T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># T의 마지막이 B라면</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n      T<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      T <span class=\"token operator\">=</span> T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\n  <span class=\"token keyword\">if</span> S <span class=\"token operator\">==</span> T<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>sol<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/b7570854-25d0-4a6b-8f28-65b97cad59da/image.png\" alt=\"\"></p>\n<blockquote>\n<p>구현 난이도는 브론즈 수준이였지만 구현 아이디어가 골드 난이도였다.</p>\n</blockquote>\n<blockquote>\n<p>이 문제를 통해서 느낀 점은 도착점에서 출발점으로 돌아가는 것도 풀이의 방법이다 라는것이다.</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%A0%9C%EB%AA%A9\">문제 제목</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\">문제 설명</a></li>\n<li><a href=\"#%EC%9E%85%EB%A0%A5\">입력</a></li>\n<li><a href=\"#%EC%B6%9C%EB%A0%A5\">출력</a></li>\n<li><a href=\"#%EC%98%88%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5\">예제 입출력</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4\">풀이</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4%EC%BD%94%EB%93%9C\">풀이코드</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 30, 2021","title":"백준 12904 - A와 B","categories":"PS","author":"weasel","emoji":"📓"},"fields":{"slug":"/12904-A-and-B/"}},"prev":{"id":"5ca018d3-2146-5d17-ad98-699a8e12e7f0","html":"<p><img src=\"/9146a4d3298760c2e7e49595184e1975/spring-logo-9146a4d3298760c2e7e49595184e1975.svg\" alt=\"\"></p>\n<blockquote>\n<p>본 글은 <a href=\"https://dimitr.im/spring-interface\">Do I need an interface with Spring boot?</a>을 번역한 글입니다.</p>\n</blockquote>\n<blockquote>\n<p>잘 쓰여진 글을 정리 하는 겸 한글로 공유하고 싶어서 번역했습니다.</p>\n</blockquote>\n<h2 id=\"들어가면서\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B4%EC%84%9C\" aria-label=\"들어가면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가면서</h2>\n<p>Spring boot를 사용하다보면, 종종 <code class=\"language-text\">service</code> (<code class=\"language-text\">@Service</code> annotation을 붙인 bean)을 사용하게 된다. 인터넷 상의 많은 예시에서, 사람들이 <code class=\"language-text\">service</code>들을 위해서 <code class=\"language-text\">interface</code>를 사용하는 걸 볼 수 있을것이다. 예를 들어서 , 우리가 todo 어플리케이션을 만든다고 할때, <code class=\"language-text\">TodoService</code>라는 <code class=\"language-text\">interface</code>와 <code class=\"language-text\">TodoServiceImpl</code>이라는 구현체를 만들때가 있다.</p>\n<p>이 포스트에서, 우리는 왜 그런 것을 하는지와 필요한가에 대해서 알아볼 것이다.</p>\n<h2 id=\"짧은-결론은\" style=\"position:relative;\"><a href=\"#%EC%A7%A7%EC%9D%80-%EA%B2%B0%EB%A1%A0%EC%9D%80\" aria-label=\"짧은 결론은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>짧은 결론은</h2>\n<p>짧은 결론은 꽤나 간단하다. <strong><code class=\"language-text\">interface</code>를 만들 필요가 없다.</strong><br>\n<code class=\"language-text\">service</code>를 만든다고 하면, class의 자체의 이름을 <code class=\"language-text\">TodoService</code>라고 하고 <code class=\"language-text\">autowire</code>를 통해서 bean들에 주입하면 된다.<br>\n예를 들어서 이런 코드가 있다고 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// TODO: Implement</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>service <span class=\"token operator\">=</span> service<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> </code></pre></div>\n<p>위에 있는 예시는 <code class=\"language-text\">@Autowired</code>를 이용한 field injection을 사용하던 생성자 주입을 사용하던간에 <strong>작동</strong>할 것이다.</p>\n<h2 id=\"그럼-왜-신경써야할까\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%99%9C-%EC%8B%A0%EA%B2%BD%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C\" aria-label=\"그럼 왜 신경써야할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그럼 왜 신경써야할까?</h2>\n<p>만약, 우리가 그게 필요하지 않다면… 왜 그런 방식(<code class=\"language-text\">inteface</code>를 이용한 방식)을 종종 쓰곤 할까?<br>\n음, 첫 번째 이유는 사실 좀 역사적인것이다. 하지만 그걸 살펴보기 전에 , Spring에서 annotation이 어떻게 작동하는지를 설명해야만 한다.</p>\n<p>만약 <code class=\"language-text\">@Cacheable</code>같은 annotation을 사용한다고 하면, cache에서 결과를 얻을것이라고 예상할 수 있다. Spring에서 그것이 작동되는 방식은 bean들을 위한 proxy를 만들고 그 proxy들에 필요한 로직을 추가해주는것이다. 원래 스프링은 JDK dynamic proxies를 사용했다. 이 dynamic proxies는 오직 <code class=\"language-text\">interface</code>들만을 위해서 만들어졌고, 이것이 예전에는 <code class=\"language-text\">interface</code>를 작성해줘야 했던 이유다.</p>\n<p>그러나, 10여 년 전부터 , Spring이 CGLIB proxying도 지원하기 시작했다. 이 proxy들은 <strong>별도의</strong> <code class=\"language-text\">interface</code>를 필요로 하지 않는다. 심지어 Spring 3.2 버전부터는 CGLIB가 Spring에 내장되어 있어서 별도로 추가해줄 필요도 없다.</p>\n<h2 id=\"느슨한-결합\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9\" aria-label=\"느슨한 결합 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>느슨한 결합</h2>\n<p>아마 두 번째 이유는 두 class 간의 느슨한 결합을 만들기 위해서 일 것이다. <code class=\"language-text\">interface</code>를 사용함으로써, <code class=\"language-text\">service</code>에 의존하는 class는 더 이상 <code class=\"language-text\">service</code>의 구현에 의존하지 않게 된다. 이것이 <code class=\"language-text\">service</code>를 독립적으로 사용할 수 있게 해준다. 예를 들어서 이런 코드가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoServiceImpl</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// TODO: Implement</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>service <span class=\"token operator\">=</span> service<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러나 위의 예시에서, 개인적인 의견으로 <code class=\"language-text\">TodoFacade</code>와 <code class=\"language-text\">TodoServiceImpl</code>이 함께 한다고 생각한다. 여기서 <code class=\"language-text\">interface</code>를 추가하는건 추가적인 복잡도를 늘릴 수 있다. 개인적으로, 그만한 가치는 없어 보인다.</p>\n<h2 id=\"여러-방식의-구현\" style=\"position:relative;\"><a href=\"#%EC%97%AC%EB%9F%AC-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84\" aria-label=\"여러 방식의 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>여러 방식의 구현</h2>\n<p>느슨한 결합이 유용한 부분은 여러 가지 구현체를 가질 때이다. 예를 들어서 TodoService가 두 가지 구현체를 가진다고 해보자. 하나는 todo 리스트를 메모리에서 가져오는 것이고, 하나는 DB와 같은 곳에서 가져오는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InMemoryTodoServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// TODO: Implement</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DatabaseTodoServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// TODO: Implement</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>service <span class=\"token operator\">=</span> service<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런 경우에선 느슨한 결합이 매우 유용한데, <code class=\"language-text\">TodoFacade</code>가 todo가 메모리에 저장되어 있는지 DB에 저장되어 있는지 알 필요 없기 때문이다. 그건 <code class=\"language-text\">Facade</code>의 책임이 아니라 어플리케이션 설정의 책임이다.</p>\n<p>원하는 것에 따라서 구현방식은 달라진다. 만약에 <code class=\"language-text\">TodoFacade</code>가 모든 구현체를 호출해야 한다면, <code class=\"language-text\">collection</code>을 주입해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">TodoService</span><span class=\"token punctuation\">></span></span> services<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TodoService</span> services<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>services <span class=\"token operator\">=</span> services<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약 구현체 중에 하나가 99%의 상황에서 사용되고 나머지들은 아주 특수한 경우에만 사용된다면, <code class=\"language-text\">@Primary</code>를 사용해라.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Primary</span>\n<span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DatabaseTodoServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">TodoService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Todo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// TODO: Implement</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">@Primary</code>를 사용함으로써, Spring container에게 <code class=\"language-text\">TodoService</code>에 의존성 주입을 해야할때, 이 구현체를 사용하라고 알려주는 것이다. 만약 다른 걸 사용해야 한다면, <code class=\"language-text\">@Qualifier</code>를 사용하거나 특정 구현체를 주입함으로써 <strong>명시적으로</strong> 설정해야 한다. 개인적으로 난 이런 방식을 분리된 <code class=\"language-text\">@Configuration</code> class에서 사용하는데, 그렇지 않으면 , <code class=\"language-text\">TodoFacade</code>를 또 다시 구현체에 관한 정보들로 오염시키기 때문이다.</p>\n<p>예시 코드를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoConfiguration</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token comment\">// Using @Qualifier</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token function\">todoFacade</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Qualifier</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"inMemoryTodoService\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token comment\">// Or by using the specific implementation</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TodoFacade</span> <span class=\"token function\">todoFacade</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InMemoryTodoService</span> service<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"제어의-역전\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84\" aria-label=\"제어의 역전 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제어의 역전</h2>\n<p>느슨한 결합의 또 다른 방식은 <strong>IoC</strong> 혹은 <strong>제어의 역전</strong>이다. 개인적으로 서로에게 의존하는 여러 가지 module을 사용할 때 제어의 역전이 유용했다. 예를 들어서 <code class=\"language-text\">OrderService</code>와 <code class=\"language-text\">CustomerService</code>가 있다고 해보자. Customer는 자신의 profile을 삭제할 수 있고 그때 pending 상태의 order들은 취소되어야 한다. <code class=\"language-text\">interface</code> 없이 구현했다면, 이런 방식으로 할것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">cancelOrdersForCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// TODO: implement</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomerService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">OrderService</span> orderService<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CustomerService</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">OrderService</span> orderService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>orderService <span class=\"token operator\">=</span> orderService<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">deleteCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        orderService<span class=\"token punctuation\">.</span><span class=\"token function\">cancelOrdersForCustomer</span><span class=\"token punctuation\">(</span>customerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// TODO: implement</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 한다면, 상황은 매우 나빠질 수 있다. 어플리케이션 내부의 domain들이 모두 결합되게 되고, 결과적으로 강하게 결합된 어플리케이션을 만들게 될것이다.</p>\n<p>그러는 대신에, <code class=\"language-text\">CustomerDeletionListener</code>라는 <code class=\"language-text\">interface</code>를 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">CustomerDeletionListener</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">onDeleteCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomerService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CustomerDeletionListener</span><span class=\"token punctuation\">></span></span> deletionListeners<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CustomerService</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CustomerDeletionListener</span><span class=\"token punctuation\">></span></span> deletionListeners<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deletionListeners <span class=\"token operator\">=</span> deletionListeners<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">deleteCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        deletionListeners<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>listener <span class=\"token operator\">-></span> listener<span class=\"token punctuation\">.</span><span class=\"token function\">onDeleteCustomer</span><span class=\"token punctuation\">(</span>customerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// TODO: implement</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">cancelOrdersForCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// TODO: implement</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderCustomerDeletionListener</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">CustomerDeletionListener</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">OrderService</span> orderService<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">OrderCustomerDeletionListener</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">OrderService</span> orderService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>orderService <span class=\"token operator\">=</span> orderService<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onDeleteCustomer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> customerId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        orderService<span class=\"token punctuation\">.</span><span class=\"token function\">cancelOrdersForCustomer</span><span class=\"token punctuation\">(</span>customerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>예시를 보면, 제어의 역전이 일어난 것을 볼 수 있다. 첫 번째 예시에서 우리가 <code class=\"language-text\">OrderService</code> 안에 있는 <code class=\"language-text\">cancelOrderForCustomer()</code>를 바꾸면, <code class=\"language-text\">CustomerService</code> 역시 바뀌어야 한다. 이 말은 <code class=\"language-text\">OrderService</code>가 제어되고 있다는 것을 말한다.</p>\n<p>두 번째 예시에서는 <code class=\"language-text\">OrderService</code>가 제어되고 있지 않다. 우리가 <code class=\"language-text\">cancelOrderForCustomer()</code>를 변화시키면, 다른 module의 일부인 오직 <code class=\"language-text\">OrderCustomerDeletionListener</code>만 바뀌어야 한다. 이것은 <code class=\"language-text\">CustomerService</code>가 제어하고 있음을 말한다. 또, 두 <code class=\"language-text\">service</code>들은 느슨하게 결합되어 있기 때문에, 하나가 다른 하나에 직접적으로 의존하고 있지 않다.</p>\n<p>비록 두 번째 방법이 복잡도를 더 늘리긴 하지만 (<code class=\"language-text\">class</code>와 <code class=\"language-text\">interface</code>가 각각 한개씩 늘었으니) domain들이 서로 결합되지 않게 해준다. 리팩토링 하기가 쉬워지는 것이다. 이 <code class=\"language-text\">listener</code>는 <code class=\"language-text\">event-driven</code>한 구조로 리팩토링 될 수 있다. domain-driven modular design이나 MSA같은 구조로 리팩토링하기 쉽게 해주는 것이다.</p>\n<h2 id=\"test\" style=\"position:relative;\"><a href=\"#test\" aria-label=\"test permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Test</h2>\n<p>마지막으로 말하고 싶은 건 테스트다. 몇몇 사람들은 dummy 구현체를 가지기 위해서 (여러 구현체를 가질 수 있으니) <code class=\"language-text\">interface</code>가 필요하다고 주장하곤 한다. 하지만 <strong>Mockito</strong>같은 mocking 라이브러리가 이 문제를 해결해 준다.</p>\n<p>단위 테스트를 작성할 때, <code class=\"language-text\">MockitoExtension</code>을 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@ExtendWith</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MockitoExtension</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacadeTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoFacade</span> facade<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@Mock</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token annotation punctuation\">@BeforeEach</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">setUp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>facade <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token comment\">// TODO: implement tests</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 방법은 <code class=\"language-text\">service</code>가 무엇을 하는지 몰라도 <code class=\"language-text\">facade</code>를 적절히 테스트할 수 있게 해준다. <code class=\"language-text\">Mockito.when()</code>을 사용함으로써 <code class=\"language-text\">service</code> mock이 무엇을 반환하게 하는지 제어할 수 있고, <code class=\"language-text\">Mockito.verfiy()</code>를 사용함으로써 특정 method가 호출되었는지 확인할 수 있다.\n예시 코드다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">findAll_shouldUseServicefindAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Todo</span> todo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Todo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">when</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">.</span><span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenReturn</span><span class=\"token punctuation\">(</span>todo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">assertThat</span><span class=\"token punctuation\">(</span>facade<span class=\"token punctuation\">.</span><span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">containsOnly</span><span class=\"token punctuation\">(</span>todo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">verify</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">findAllTodos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>심지어 Spring container를 필요로 하는 통합 테스트를 작성할때도,<code class=\"language-text\">@MockBean</code> annotation을 이용해서 bean들을 mock할 수 있다. 실제 구현체가 있는 package를 탐색하지 않게 해라.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@ExtendWith</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SpringExtension</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@SpringBootTest</span><span class=\"token punctuation\">(</span>classes <span class=\"token operator\">=</span> <span class=\"token class-name\">TodoFacade</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TodoFacadeTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoFacade</span> facade<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@MockBean</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TodoService</span> service<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러니까 대부분의 경우에서, 테스트 할때 <code class=\"language-text\">interface</code>는 필요하지 않다.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>만약 개인적으로 <code class=\"language-text\">interface</code>를 <code class=\"language-text\">serivce</code>에 사용해야 하냐는 질문을 받는다면, 내 대답은 <strong>아니오</strong>다. 유일한 예외는 제어의 역전을 사용하거나 여러개의 구현체를 신경써야 하는 경우다.</p>\n<p>만약의 경우를 위해서 <code class=\"language-text\">interface</code>를 만드는 게 좋지 않겠냐고 생각할 수 있다. 개인적으로 여전히 <strong>아니오</strong>다.<br>\n첫 번째로, “You aren’t going to need it”(YAGNI) 라는 원칙을 믿는다. <em>필요할지도 몰라</em> 라는 이유로 복잡성을 높일 이유는 없는데 , 일반적으로 <strong>필요하지 않기</strong> 때문이다.<br>\n두 번째로 필요한 경우라도 전혀 문제 없다. 대부분의 IDE들은 기존의 class에서 method만 추출해서 <code class=\"language-text\">interface</code>를 만들수 있게 해주고, 모든 코드들을 그 <code class=\"language-text\">interface</code>를 사용하게끔 순식간에 만든다.</p>\n<h3 id=\"참고하면-좋은-자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%9E%90%EB%A3%8C\" aria-label=\"참고하면 좋은 자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고하면 좋은 자료</h3>\n<p><a href=\"https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html\">JDK Dynamic Proxy와 CGLIB의 차이점은 무엇일까?</a>\n<a href=\"https://jusungpark.tistory.com/23\">퍼사드 패턴</a>\n<a href=\"https://swk3169.tistory.com/185\">느슨한 결합 vs 긴밀한 결합</a>\n<a href=\"https://medium.com/@gorali/how-mockito-works-7d3a2c77da71\">How Mockito Works?</a>\n<a href=\"https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&#x26;blogId=complusblog&#x26;logNo=221163007357&#x26;redirect=Dlog&#x26;widgetTypeCall=true&#x26;directAccess=false\">소프트웨어 개발 3대 원칙 : KISS,YAGNI,DRY</a></p>\n<blockquote>\n<p>스프링 부트에 <code class=\"language-text\">interface</code>가 필요한가에 대해서는 당연히 <strong>YES</strong>지만 이 글에선 <strong><code class=\"language-text\">service</code>에 <code class=\"language-text\">interface</code></strong> 가 필요한지, 정확히 말하면 <code class=\"language-text\">service</code>의 구현체가 필요한지에 대해서 논하고 있습니다.</p>\n</blockquote>\n<blockquote>\n<p>프로젝트를 시작하면서 Spring boot에서 구현체와 인터페이스를 구분해야하는지 고민이 많았는데 꽤나 자세하고 명쾌해서 도움이 되었습니다.</p>\n</blockquote>\n<blockquote>\n<p>소프트웨어공학 수업에서 배운 YAGNI를 실제로 보니까 반갑네요. 그냥 무지성으로 외웠는데..</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B4%EC%84%9C\">들어가면서</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A7%A7%EC%9D%80-%EA%B2%B0%EB%A1%A0%EC%9D%80\">짧은 결론은</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%99%9C-%EC%8B%A0%EA%B2%BD%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C\">그럼 왜 신경써야할까?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9\">느슨한 결합</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%97%AC%EB%9F%AC-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84\">여러 방식의 구현</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84\">제어의 역전</a></p>\n</li>\n<li>\n<p><a href=\"#test\">Test</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></p>\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%9E%90%EB%A3%8C\">참고하면 좋은 자료</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"July 15, 2021","title":"Spring Boot에서 interface를 사용해야 할까? (Do I need an interface with Spring boot?)","categories":"Spring","author":"weasel","emoji":"📓"},"fields":{"slug":"/do-i-need-an-interface-with-spring-boot/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/how-spring-handler-mapping-works-1/","nextSlug":"/12904-A-and-B/","prevSlug":"/do-i-need-an-interface-with-spring-boot/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}