{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/process-scheduling-algorithm/",
    "result": {"data":{"cur":{"id":"867e7d2b-13b3-5749-8198-b6d3c099538d","html":"<p>일단 프로세스 스케쥴링 알고리즘에 대해서 언급하기 전에, 프로세스의 상태와 Context-Switching에 대해서 알아야 한다.</p>\n<p>여러가지 프로세스의 상태를 기반으로 전이(Transition)되며 이를 바탕으로 스케쥴링 알고리즘이 이루어진다.</p>\n<h2 id=\"프로세스의-상태\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\" aria-label=\"프로세스의 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>프로세스의 상태</strong></h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3UlEQVQ4y+VU2W7aUBC9AgRm+f/PqCAhjR9wVSoWEWynNirGZbcRYRVgDJj1RDMSVprnPlTqSEfjO8u5c2dGFkII/GX864TJZBLRaBSRSASSJCGTySCVSiGdToN8BDqTJv/9TKBYslFuLBbjHCHLMuRnGfnHPAqFAprNJvr9PmzbxnA4xGg0Qq/XDb9J93o9jrEsC4qiIPsli6f8E3K5HIRhGHCGDvrdPjqdDmazGd7exphMJgiCAMvlksld18HlcgHJdDrFer3GeDyG3bJh/bJg/jRRq9YgKPFwOGCz2eB0OnFCu91GtVqFrutsJ6Lz+czVl8tl6K86/J3PsefTGZ7n4Xg8cjFiPp+z43a7sSZjwzRRKVXQMBrodjtsXywWKP4o4uHxAdlcFqqmhjl3IS5BBB+FqqEnaaqGltWC7/uh3f5tQ/mmcGu2222Yc71ew2KYkHq12+0Y+/2e4Y5cJtZ1DS/1F1QqZR4G9Zv89ES6jPSdkOIF9YgMnrfhfhGo9CA4cIDVtFCv1WEaJlRV5X7RxTSU1WoVDoqEcoWmaeE6OI4TwnVdHkLxe5HXQv4qo1QqYTAY/BFHZ67ccXiIIpFIQJISIP0ZtMTxeBzxRJwXl5aY8Dnuo138fz+Hd45V7ag5zclUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/37523/process_state.png\"\n        srcset=\"/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/e9ff0/process_state.png 180w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/f21e7/process_state.png 360w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/37523/process_state.png 720w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/302a4/process_state.png 1080w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/21b4d/process_state.png 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>프로세스의 상태는 OS에 따라서 개수도 다르고, 명칭도 조금 다르지만, 가장 대표적인 그림은 위의 상태와 같다.</p>\n<ul>\n<li><code class=\"language-text\">new</code> : 프로세스가 생성된 상태이다. 이때는 Readuy Queue 안에 들어 있지 않기 때문에 <strong>CPU를 받을 대상이 아니다.</strong></li>\n<li><code class=\"language-text\">ready</code> : 프로세스가 <strong>CPU를 할당받기 위해 대기</strong>하는 상태이다. 보통 <strong>Ready Queue 안</strong>에 들어와있는 상태라고 얘기한다. <strong>스케쥴링의 대상</strong>이 된다.</li>\n<li><code class=\"language-text\">running</code> : 현재 CPU를 할당받아 <strong>작업중인</strong> 상태다. Single core 시스템에서는 1개다.</li>\n<li><code class=\"language-text\">wating</code> : 프로세스가 <strong>입출력이나 이벤트가 끝나기를 기다리는</strong> 상태이다.</li>\n<li><code class=\"language-text\">terminated</code> : 프로세스가 <strong>종료된</strong> 상태다. 단 프로세스 구조체가 사라진 것은 아니다.</li>\n</ul>\n<p>그림에서 프로세스의 상태가 특정 작업들로 인하여 변하는 것을 볼 수 있는데 이것을 프로세스의 <strong>상태 전이(Transition)</strong> 라고 한다.</p>\n<ul>\n<li><code class=\"language-text\">admitted</code> : 생성된 프로세스가 CPU를 받을 준비가 되어서 <strong>Long-term Scheduler(Job Scheduler)</strong> 에 의해서 선택받아 Reaudy queue로 옮겨지는 작업이다.\n<ul>\n<li><strong>Long Term Scheduer :</strong> 어떠한 프로세스를 레디큐로 옮길지 선택하는 스케쥴러다. 자주 일어나지 않고, <strong>멀티프로그래밍의 정도(DOM)</strong> 가 이것에 영향을 받는다.\n<ul>\n<li>일반적으로 많은 프로세스가 한꺼번에 메모리에 올라오면, 일부는 디스크에 저장된다.</li>\n<li>존재하는 이유는 기존의 프로세스들이 자원을 확보하기 위해서 존재한다. 무턱대고 다 RQ로 올리면 기존의 프로세스는 작업이 진행되지 않는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"language-text\">scheduler dispatch</code> : <code class=\"language-text\">ready</code> 상태에 있는 프로세스를 <strong>Short term Scheduler</strong>가 선택해서 자원을 할당한 후 실행시키는 행위다.\n<ul>\n<li><strong>Short Term Scheduler :</strong> RQ에 있는 프로세스 중에서 어떠한 것이 다음으로 실행될지, CPU를 할당할지 선택하는 스케쥴러다.\n<ul>\n<li>빈번하게 발생한다. 그렇기에 이 스케쥴러의 오버헤드를를 줄여야 전체 오버헤드를 줄일 수 있다.</li>\n<li>스케쥴링 알고리즘과 아주 깊은 연관이 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"language-text\">interrupt</code>  : 인터럽트는 조금 논란이 있는데, 저 그림상에서는 입출력 이벤트는 포함하지 않는다. <strong>Context-switching이 일어난다.</strong>\n<ul>\n<li>선점식(preemptive) 방식에서는 타이머(<strong>Timer)</strong> 이벤트가 있다. 인터럽트 핸들러가 인터럽트를 일으켜서 STS에게 다른 프로세스를 선택할지, 지금 프로세스를 그대로 둘지 결정하게끔 한다. 만약 바뀐다면 전이가 일어난다.</li>\n<li>비선점식(non-preemptive 혹은 cooperative) 방식에서는 양보(<strong>Yield</strong>)가 있다. 이 방식에서는 OS가 프로세스를 스케쥴링할때 인터럽트를 사용,허용하지 않는다. 대신에 작동중인 프로세스가 자발적으로 양보를 해서 스케쥴러가 다른 프로세스를 스케쥴링할 수 있는 방식을 쓴다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">I/O or event wait</code> : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 끝날때까지 대기 상태로 만드는 것. <strong>Context-switching이 일어난다.</strong>\n<ul>\n<li>여기서 왜 <strong>ready로 안보내는지가 중요하다.</strong> 왜냐면, 이 프로세스는 ready로 가서 자원을 할당받을 자격이 없다. <strong>이벤트나 입출력이 끝나지 않았으니 자원을 받아도 사용하지 못하기 때문이다.</strong></li>\n</ul>\n</li>\n<li><code class=\"language-text\">I/O or event completion</code> : 입출력/이벤트가 끝난 프로세스를 ready 상태로 만들어 STS에게 선택될수 있게끔 한다. <code class=\"language-text\">wait</code> 과는 다르게 자원을 할당받기만 하면 작업을 이어나갈 수 있기 때문이다.</li>\n</ul>\n<h2 id=\"context-switching\" style=\"position:relative;\"><a href=\"#context-switching\" aria-label=\"context switching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Context-switching?</strong></h2>\n<p>정확한 정의는 ”<strong>CPU</strong>가 <strong>다른 프로세스로 스위치</strong>할때, 시스템(OS)이 <strong>기존의 프로세스의 상태를 저장</strong>하고, <strong>다음</strong> 진행될 <strong>프로세스의 저장된 상태값을 불러오는것</strong>“이다.</p>\n<ul>\n<li>이 때 중요한것이 PCB 등인데, PCB 안에는 CPU 레지스터에 대한 정보, PC,페이지 테이블과 관련된 정보가 있다. 그렇기에 PCB는 프로세스의 문맥을 보관하고 있는 것이다.</li>\n<li>다시 작업을 수행할때 이것을 참조해서 어디부터 다시 시작할지 참고 할 수 있다. 그렇기에 새로운 프로세스로 선택될때도 PCB를 불러와야하고, ready 상태나 waiting 상태로 프로세스가 전이될때도 PCB를 저장해야한다.</li>\n</ul>\n<p>일반적으로 context switch하는 시간은 순전한 오버헤드다. 대부분의 시스템은 이 전환 시간동안 어떤 의미있는 작업을 하지 않는다.</p>\n<p>또 가장 중요한 부분이 <strong>context-swtichg을 하면서 Cache flushing이 일어난다</strong>. 그렇기에 그 다음에는 <strong>연속적인 캐시 미스</strong>(successive cache misses)가 발생한다. 이 과정이 대부분의 오버헤드를 차지한다.</p>\n<blockquote>\n<p>💡 캐시를 날리는 이유는 새로운 프로세스는 새로운 virtual adrress를 가지는 새로운 메모리 주소다. 그렇기 때문에 기존의 캐시된 메모리의 주소 영역을 사용할 필요가 없기에 기존의 캐시된 메모리를 Flush 하는 것.</p>\n</blockquote>\n<blockquote>\n<p>참고로 스레드도 컨텍스트스위칭을 한다. 그치만 <strong>쓰레드들끼리는 주소공간을 공유</strong>하기 때문에 캐시를 flush할 필요가 없다.</p>\n</blockquote>\n<h3 id=\"process-context-switching-vs-thread-context-switching\" style=\"position:relative;\"><a href=\"#process-context-switching-vs-thread-context-switching\" aria-label=\"process context switching vs thread context switching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Process context switching vs Thread context switching</strong></h3>\n<p>프로세스만 context switching을 하는 것이 아닌 쓰레드끼리도 context switching을 한다. 다만 아래와 같은 차이점이 있다.</p>\n<ul>\n<li>프로세스간 context switching\n<ul>\n<li>커널 단에서 스위칭이 일어난다.</li>\n<li>메모리 주소 공간의 전환이 일어난다.</li>\n<li>프로세서의 <strong>캐시와 TLB 모두 Flush 된다. → 연속적인 캐시 미스와 TLB 미스가 일어난다.</strong></li>\n<li>메모리 주소공간이 전환되고, 캐시미스가 <strong>필연적으로 동반되므로 훨씬 비용이 비싸다</strong>.</li>\n</ul>\n</li>\n<li>쓰레드간 context switching\n<ul>\n<li>커널 단에서 스위칭이 마찬가지로 일어난다.</li>\n<li>같은 프로세스 내에서 일어나는 스위칭이기에 메모리 주소공간을 그대로 사용한다.</li>\n<li>프로세서의 <strong>캐시와 TLB 정보가 유지된다.</strong></li>\n<li>레지스터의 값과 스택 포인터 전환 정도만 일어나니 훨씬 저렴하다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"cpu-스케쥴링-알고리즘이란\" style=\"position:relative;\"><a href=\"#cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80\" aria-label=\"cpu 스케쥴링 알고리즘이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>CPU 스케쥴링 알고리즘이란?</strong></h2>\n<p>스케쥴링 알고리즘은 레디 큐에 있는 프로세스들을 대상으로 다음으로 실행할(CPU를 할당받을) 프로세스를 고르는 작업이다.</p>\n<p>일단 프로세스의 상태를 다이어그램으로 먼저 보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACAUlEQVQoz3WTXXOaQBSG/f+/xpvOtI1Jc9FpY2KN1GoQWFQEBTZ+gAqClaeza0LTJGXmsGeW3Wff95ylEd+m+B/WJMMMMlgIi7lwyLKMPMsoiwMyjvHsOWPLI4ojXNdFCMF7T+PxIcHteozHAX1zxN33GzzHJklT5rFk5I4JV0t6zTbmRZ/OfYfrL9eEYchyuSRNUx1BEJDnOQ2oCGVIxxlzaQxpC48Hy6LTvedzt89Fb8Ct5eI8/GQqLC4vr2g2mxq4Wq10xMqB552B1amq5W7TlDiKkLHUJ46GA3ZJUn8vylJv2u127Pf79y2r16kooCjIsvx80iHHtGw+tbu0un1atz+YzWaEi0W9UanabDY6P51OOqqqOgMrGeEP70mOB47Vb2SyIowiDNOibfRx/Tnr9Vrbs21b25VS6lAQzXgaGzwlw2iCMRuxybbsDhmzmc/IEZiOwBKutqhCQZIk0bZfgv4CgX2R8U0YXI3uGMwF1emE5we0egOu+iZff5kapBTW9d5ua9AzrAbmZYEVTZlvJOss1QsepeR4yCn2Oz0qdWVZ1pDXCv8BqsnieF5MBd50ii0EFx2Dj3c9us5EX3RVO9V9de+Sp+6/Ab6cULnqllKjrog58bgx+rR7BpPJGfrczde1e6PwdS3UX7CUkkUQMHYF0+mUKIr0vO/7/7X8B9PZjIsssUPCAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/8bdbc78afd4ec9a6165a99fcfe0f71fe/37523/queue_diagram.png\"\n        srcset=\"/static/8bdbc78afd4ec9a6165a99fcfe0f71fe/e9ff0/queue_diagram.png 180w,\n/static/8bdbc78afd4ec9a6165a99fcfe0f71fe/f21e7/queue_diagram.png 360w,\n/static/8bdbc78afd4ec9a6165a99fcfe0f71fe/37523/queue_diagram.png 720w,\n/static/8bdbc78afd4ec9a6165a99fcfe0f71fe/9d5da/queue_diagram.png 871w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>레디큐 뿐만 아니라, 새로 만들어지는 큐를 담는 큐도 있고, block(I/O wait) 큐도 있다. 일반적으로 CPU 스케쥴링 알고리즘은 <strong>Short-term scheduling</strong>을 얘기한다.</p>\n<p>스케쥴링 알고리즘을 얘기하기 전에 <strong>멀티 프로그래밍(Multi Programming)</strong> 과 <strong>시분할(Time sharing)</strong> (혹은 <strong>멀티 태스킹(Multi Tasking))</strong> 에 대해서 먼저 얘기를 해야한다.</p>\n<ul>\n<li><strong>멀티 프로그래밍</strong>\n<ul>\n<li>작업들을 적절히 구성해 <strong>항상 CPU가 프로세스를 실행</strong>하도록 한다.</li>\n<li>어떤 프로세스가 CPU를 할당받아 사용하다 I/O 작업등 CPU를 필요로 하지 않는 순간이 오면,</li>\n</ul>\n다른 프로세스로 교체해서 그 프로세스가 CPU를 계속 사용할 수 있도록 한다.\n<ul>\n<li>이것의 목적은 <strong>CPU 사용률</strong>(CPU Utilization)을 최대화함에 있다.</li>\n</ul>\n</li>\n<li><strong>시분할(멀티 태스킹)</strong>\n<ul>\n<li>CPU가 일할때 <strong>매우 빈번하게 수행중인 작업을 교체</strong>해서 사용자가 상호작용할 수 있는것이다.</li>\n<li>반응하는데 걸리는 시간(Response time)이 충분히 작아야 프로그램들이 동시에 진행하는것처럼 보인다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"스케쥴링의-발생과-목적\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81%EC%9D%98-%EB%B0%9C%EC%83%9D%EA%B3%BC-%EB%AA%A9%EC%A0%81\" aria-label=\"스케쥴링의 발생과 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케쥴링의 발생과 목적</h3>\n<p>CPU 스케쥴링은 아래와 같은 상황에서 일어난다.</p>\n<ul>\n<li><code class=\"language-text\">running</code> 에서 <code class=\"language-text\">waiting</code> 으로 갈 때 (I/O Request)</li>\n<li><code class=\"language-text\">running</code> 에서 <code class=\"language-text\">ready</code> 로 갈 때 (timeout), <strong>Preemptive</strong></li>\n<li><code class=\"language-text\">waiting</code> 에서 <code class=\"language-text\">ready</code> 로 갈 때 (I/O Finish, <strong>이때 스케쥴링 해주는 이유는, I/O가 끝난 이후에 핸들링을 해줘야 하기 때문이다</strong>. 기존의 <code class=\"language-text\">running</code> 프로세스는 고려하지 않음),<strong>Preemptive</strong></li>\n<li><code class=\"language-text\">running</code> 에서 <code class=\"language-text\">terminated</code> 로 갈 때 (프로세스의 종료)</li>\n</ul>\n<p>만약 스케쥴링이 1번과 4번에서만 일어난다면 , non-preempitve지만, 그렇지 않다면 <strong>preemptive</strong> 스케쥴링이다.</p>\n<p>스케쥴링 알고리즘에 대한 기준은 몇가지가 있다</p>\n<ul>\n<li><strong>CPU 이용률</strong> : CPU를 가능한 바쁘게 해야 한다. 높을 수록 좋음</li>\n<li><strong>Throughput</strong> : 단위시간당 프로세스 처리 수,batch 시스템에선 중요함, 높을 수록 좋음</li>\n<li><strong>Turnaround time</strong> : 특정 프로세스가 도착시간에서부터 끝날때까지 걸린 시간, 낮을 수록 좋음</li>\n<li><strong>Waiting time</strong> : 레디큐에서 기다린 시간의 합 , 범용적으로 중요하고, 낮을 수록 좋음</li>\n<li><strong>Response time</strong> : 요청이 들어왔을때 첫번째 응답까지 걸리는 시간,일반적인 PC에서 중요하다. Throughput과는 반대의 관계이며 낮을수록 좋다.</li>\n</ul>\n<h3 id=\"스케쥴링-알고리즘\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"스케쥴링 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케쥴링 알고리즘</h3>\n<ul>\n<li><strong>FCFS</strong> (First-Come, First-Served)\n<ul>\n<li><strong>비선점</strong></li>\n<li>먼저 CPU를 요청한 프로세스에게 먼저 CPU가 할당된다. <strong>공평하다</strong>.</li>\n<li>큐를 이용하면 쉽게 구현이 가능하다</li>\n<li>도착순서를 바꿈으로써 전체 waiting time이 바뀐다. <strong>CPU bound job을 뒤로 하면 확 줄어든다</strong></li>\n<li><strong>Convoy Effect</strong> : <strong>시간이 짧게 걸리는 프로세스가 시간이 오래 걸리는 프로세스 뒤에 있으면 CPU 전체 사용률이 줄어든다.</strong></li>\n</ul>\n</li>\n<li><strong>SJF</strong> (Shortest Job First)\n<ul>\n<li><strong>기본적으로 비선점</strong> 방식</li>\n<li>CPU burst time이 가장 작은 프로세스를 먼저 CPU 할당시킨다.</li>\n<li><strong>선점방식으로 구현하는것을 SRTF</strong>(Shortest Remaining Time First) 방법은, 현재 프로세스의 남은 시간보다 더 짧은 프로세스가 새로 들어오면, 선점해버리는 방식이다.\n<ul>\n<li>컨텍스트 스위칭에 드는 <strong>오버헤드를 고려하지 않을시에는 SJF보다 성능이 좋다.</strong></li>\n<li>만약 선점방식이라면, CPU burst time이 긴 프로세스는 계속 실행되지 못하는 <strong>기아(starvation)</strong> 현상이 발생 할 수 있다.</li>\n</ul>\n</li>\n<li>하지만 현실적으로 SJF는 구현하기 어려운데, <strong>CPU의 남은 시간을 예측불가</strong>하기 때문이다. 그래서 평균 waiting time이 최소인 Optimal한 알고리즘이다.</li>\n<li>그나마 유사하게 접근 하는 방식은 <strong>이전 CPU burst time을 기반으로 예측</strong>하는 것이다.</li>\n</ul>\n</li>\n<li><strong>Priority Scheduling</strong>\n<ul>\n<li>각 프로세스에게 우선순위 지시자가 연결되어 있다.</li>\n<li><strong>가장 높은 우선순위</strong>(일반적으로 가장 낮은 숫자)를 가진 프로세스에게 CPU가 할당된다</li>\n<li>SJF도 CPU burst time이라는 우선순위를 가지는 우선순위 스케쥴링 방식이다.</li>\n<li>선점과 비선점 방식 모두 구현이 가능하다.\n<ul>\n<li>선점 : 새<strong>로 도착한 프로세스의 우선순위가 기존의 것보다 높으면 CPU 교체</strong> (SRTF)</li>\n<li>비선점 : 신경쓰지 않고 새로운 프로세스를 <strong>그저 레디큐 맨 앞에 배치</strong></li>\n</ul>\n</li>\n<li>우선순위가 낮은 프로세스는 계속 실행되지 못하는 <strong>기아(starvation) 현상</strong>이 발생하는데, 시간이 지날때마다 프로세스의 우선순위를 올려주는 <strong>에이징(Aging) 방식으로 해결 가능</strong></li>\n</ul>\n</li>\n<li><strong>RR</strong>(Round-Robin) Scheduling\n<ul>\n<li>각각의 프로세스는 <strong>Time quantum</strong>이라 불리는 짧은 시간을 부여받음.</li>\n<li>이 시간이 <strong>끝나면</strong>, 프로세스는 <strong>다른 프로세스로 무조건 교체되고</strong>(선점) 레디큐의 마지막으로 돌아간다.(FCFS의 측면)</li>\n<li>q초의 quantum을 가지는 n개의 프로세스가 있으면, q초마다 한번씩은 1/n의 CPU 타임을 보장받는다.</li>\n</ul>\n→ *<em>최대 (n-1)<em>q 초까지만 기다리면 무조건 보장받는다. 이를 통해서 waiting time의 upper bound를 보장받게 된다.</em></em>\n<ul>\n<li>q의 사이즈를 적절히 고르는 것이 중요하다.\n<ul>\n<li>q가 너무 <strong>크면</strong> → <strong>FCFS</strong>랑 다를게 없다.</li>\n<li>q가 너무 <strong>작으면</strong> → 잦은 컨텍스트 스위칭, 그로 인한 <strong>오버헤드가 커지기 때문에 throughput이 감소한다.</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Multi-Level Queue</strong>\n<ul>\n<li>레디큐를 두개 이상으로 구분해 <strong>I/O bound job</strong>과 <strong>CPU bound job</strong>으로 구분한다. 그 이유는 <strong>I/O bound job은 interaction이 많아서 response를 빨리 얻어야 하기 때문이다</strong>. (우선순위를 높여야겠지?)</li>\n<li>크게 두 분류로 나누는데 foreground와 background로 나눈다.\n<ul>\n<li>foreground : <strong>interactive</strong>하고 , I/O job 위주이며, <strong>RR 알고리즘</strong>으로 동작하여 <strong>response time</strong>을 높이는데 주력으로 둔다.</li>\n<li>background : <strong>batch job</strong>(CPU bound job)위주이며, <strong>FCFS</strong>로 동작하며 throughput을 높이는데 집중한다.</li>\n</ul>\n</li>\n<li>각 큐들은 독립적인 스케쥴링을 가지고 있고, <strong>foreground가 다 수행되어야 background를 선택한다.</strong>\n<ul>\n<li>그렇기 때문에 <strong>background job들은 기아현상</strong>이 발생할 수 있다. (계속 foreground로 들어오면)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>MLFQ</strong>\n<ul>\n<li>\n<p>프로세스들은 <strong>큐들 사이에서 서로 이동</strong>이 가능하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 589px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACHElEQVQoz2VT144aQRDk73nkB7gHg1gL6bizOV4wQSevWMAscEs6cs45BxHKqkZ7wvJIrekJXVPdXWNpt9toNBrodDpotVro9XowDANOpxMuRcHL6wt8Ph/8fj/C4TDU3yrisTiSySTy+TwqlQqKxSIymYzMllwuh36/j8lkgvF4LIAMdrvdeH72wPHNge8uBW8/vQj4A0j80fHxYcBms8kDJDMcDlEulxGJRGAplUqYzWZYrVbYbrfiky39xXyOerUm1mq00Ov05HwwHEBVVfFJwBzNZhMWvmAOsqSNRiNhS38+n0vgdDr9OqMtl0tZm/Hn8xnVahWWer2Oy+UiG6yn6Q8GAykFgxlIwMVigdVyhfV6g8PhgNPphOv1KoCciSWAXBDEpJ9IJPD0ZIfD6YTiUuDxeBD4FcB7+B0pPY3PzyK8b14UCgVhygzYUMZ9MeQgC9YhlUoJs2qlAk3VENNiyBlZGCkD7dZdFXa7XQBZbxLa7/f3Lj8CctxuN+x2O2nSer3GZrO524PPs+PxKPe73e7/KROQGywqJcA0CMaZxtrR2KBHYxZM9x9As0vcYCPM9iuKIjqkqEOhEDRNEzEzTQZSbnzM7DBlxjPRIResQa1WE+UHg0EBiMfjItZXzw8E/SERND9CNpuF1WqVJlABJMLsotHonSGLyQ3zCxEonU5Lc/SEDi2iIarFBEDXdQnkL2EM2dJIhCn/BWrlXz6/huLOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/1b6079a67d732c3bf73f5859f845dda9/b1665/mlq.png\"\n        srcset=\"/static/1b6079a67d732c3bf73f5859f845dda9/e9ff0/mlq.png 180w,\n/static/1b6079a67d732c3bf73f5859f845dda9/f21e7/mlq.png 360w,\n/static/1b6079a67d732c3bf73f5859f845dda9/b1665/mlq.png 589w\"\n        sizes=\"(max-width: 589px) 100vw, 589px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>새로운 프로세스는 q=8인 큐로 진입하고, <strong>큐 내부적으로는 FCFS</strong>의 행동을 취한다. <strong>Q1과 Q2의 작업이 있으면 선점한다.</strong></p>\n</li>\n<li>\n<p>CPU를 얻으면 8ms동안 수행되고, 그 안에 <strong>끝나지 않으면 Q1으로 강등당한다.</strong></p>\n</li>\n<li>\n<p>Q2에서 16ms동안 수행되고, 그 안에 <strong>끝나지 않으면, Q2로 강등당한다.</strong> 이런 방식을 취함으로써 <strong>Convoy Effect를 방지할 수 있다.</strong> (CPU bound job은 우선순위가 낮으니)</p>\n</li>\n<li>\n<p>단, <strong>yield</strong>와 같이 I/O 작업으로 인해 q가 소진되기전에 CPU를 포기하면 <strong>강등당하지 않고 우선순위를 그대로 유지한다.</strong></p>\n</li>\n<li>\n<p>MLFQ는 burst time이 짧은 <strong>대화형 작업들을 빨리 처리하려고 해 response time에서 강점을 보이지만 , CPU bound job들은 기아 현상을 겪을수 있다.</strong></p>\n<ul>\n<li>주기적으로 모든 작업의 우선순위를 <strong>상향조정</strong> 할 수 있다. 예를 들어 모두를 Q0로 올려보낸다. 이 과정에서 CPU bound job들도 조금이나마 작업을 진행할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p><strong>의도적인 I/O 작업 호출</strong>로 <strong>우선순위를 유지하는 프로세스가 있을 수 있다</strong>. 이 프로세스는 예를 들어 7ms가 지난 후 의미 없는 I/O 작업으로 우선순위를 유지한다.</p>\n<ul>\n<li>누적적인 <strong>CPU 사용 시간을 기록</strong>해서 방지한다. PCB 안에 기록하지 않을까..?</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"선점식-vs-비선점식\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%A0%90%EC%8B%9D-vs-%EB%B9%84%EC%84%A0%EC%A0%90%EC%8B%9D\" aria-label=\"선점식 vs 비선점식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>선점식 vs 비선점식</strong></h1>\n<ul>\n<li>선점식은 프로세스에게 한번 실행될때 제한된 시간만큼 CPU를 할당한다. 작업 도중에 자원을 반납당하고 ready 상태로 진입한다. 비선점식은 프로세스가 종료되거나, yield를 통해서나 I/O를 위해서 자발적으로 ready에 가지 않는 한 자원을 반납하지 않는다.</li>\n<li>선점식만 실행 중에 인터럽트를 허용한다.</li>\n<li>선점식은 프로세스의 우선순위에 따라 스케쥴링을 하는데, 우선순위가 낮은 프로세스가 선택받지 못하는 기아(starvation)현상이 일어날 수 있다. 비선점식은 수행시간이 긴 프로세스(CPU-bound job)이 스케쥴링되면, 그 뒤의 작업들이 오랜 기간동안 선택받지 못한다.</li>\n<li>선점식은 context-swtiching이 자주 일어나 이로 인한 오버헤드가 크고, 비선점식은 필수적인 context-switching을 제외하면 자주 일어나지 않아 오버헤드가 비교적 적다.</li>\n<li>선점식은 우선순위에 따른 유연성을 가지지만(예를 들어 우선순위 promotion을 진행하는 MLFQ) 비선점식은 그렇지 않다.</li>\n</ul>\n<p>이러한 특징때문에 interactive한 시스템에선 반응성 때문에 선점식을, batch job을 자주 수행하는 시스템에선 비선점식을 사용하곤 한다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\"><strong>프로세스의 상태</strong></a></p>\n</li>\n<li>\n<p><a href=\"#context-switching\"><strong>Context-switching?</strong></a></p>\n<ul>\n<li><a href=\"#process-context-switching-vs-thread-context-switching\"><strong>Process context switching vs Thread context switching</strong></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80\"><strong>CPU 스케쥴링 알고리즘이란?</strong></a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81%EC%9D%98-%EB%B0%9C%EC%83%9D%EA%B3%BC-%EB%AA%A9%EC%A0%81\">스케쥴링의 발생과 목적</a></li>\n<li><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">스케쥴링 알고리즘</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"일단 프로세스 스케쥴링 알고리즘에 대해서 언급하기 전에, 프로세스의 상태와 Context-Switching에 대해서 알아야 한다. 여러가지 프로세스의 상태를 기반으로 전이(Transition)되며 이를 바탕으로 스케쥴링 알고리즘이 이루어진다. 프로세스의 상태  프로세스의 상태는 OS에 따라서 개수도 다르고, 명칭도 조금 다르지만, 가장 대표적인 그림은 위의 상태와 같다.  : 프로세스가 생성된 상태이다. 이때는 Readuy Queue 안에 들어 있지 않기 때문에 CPU를 받을 대상이 아니다.  : 프로세스가 CPU를 할당받기 위해 대기하는 상태이다. 보통 Ready Queue 안에 들어와있는 상태라고 얘기한다. 스케쥴링의 대상이 된다.  : 현재 CPU를 할당받아 작업중인 상태다. Single core 시스템에서는 1개다.  : 프로세스가 입출력이나 이벤트가 끝나기를 기다리는 상태이다.  : 프로세스가 종료된 상태다. 단 프로세스 구조체가 사라진 것은 아니다. 그림에서 프로세스의 …","frontmatter":{"date":"December 25, 2021","title":"프로세스 스케쥴링 알고리즘","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/process-scheduling-algorithm/"}},"next":{"id":"47d4a3c9-8311-5002-8347-5782768ff95b","html":"<p>프로세스란, <strong>실행중인 프로그램</strong>을 의미한다.\r\n프로그램을 실행하기 위해서는 <strong>주소공간,파일,메모리</strong> 등이 필요한데 <strong>운영체제로부터 이런 것을 할당받은 프로그램을 프로세스</strong>라 한다.</p>\n<blockquote>\n<p>프로그램은 어떤 작업을 수행하기 위한 파일로써 <strong>정적인 상태</strong>이고, 프로세스는 그 작업을 수행하는 <strong>동적인 상태</strong>다.</p>\n</blockquote>\n<h2 id=\"프로세스의-메모리-구조\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\"프로세스의 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스의 메모리 구조</h2>\n<p>프로세스는 아래 그림과 같은 메모리 구조를 띄고 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.1111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC+klEQVQ4y2WUCW/bOhCE/f9/2bsKJE7i+lAcS7Fu3ockH/H3ILppU1TAQgQ4HM7u7HIBcKws26xFSI9QnqazaOnR/264XK7cuH/DeGa1bmhah3MjQoZ0Rj2+co5TwiyMHdkfRAI+r2qWzyX/LY/k2wb313da4blePzidLnS952FZsnyueHyq+Odbkc7pv9fYzqHdxGIGnc+XxD6dJqyzTNOIj4F4mShryfV6I8YTWg8Jd7t9YJxL+HEaGU4j1gXazrPoRWAczwloreFxuWS92fDw9MTzasVb0fLxcWMYTigdE+58mthlGY9PT2yzjG8PD+RFmTJYdH1ICs8fN3oXaZWh7HqGIaaoG5NSvhPeFao40lvPse3Q1jKOA9YGOhFYCBFQYaR0Ay+dI5OeTAXsdEVPV3oZuCTCM0JFzHTmpbWsOsdGeMRwSrg4XZi5FlJGGhNxweOswTmH8x5tLJUJPwnH4UyvBnoff+As1nm89zTKYsKEkPGTMCCMpqobttkrq/UGrTVHoZOquXXmlKUeqbWlaVve8pzH52e0Vhx7gbQRqRJhoHMDfogYY1BaI5XCWEvvB2bTfimMqX4xBqxzCRu8R/qIjadfCmvtU3HLquJQFDRzsY2hVDaBPhUKPdAaR1mW7N/eEt7OuF6i3ID8mrI0muL9nc1uR7bf0/U9lXZ/EHazu2XJJstYb7e0XUsl1FfCQGsjNviUsv1hirU2leKry7MpMgxpb8aEGPHeIazHz13w6XKtZ4Um3fx9u2W1uZtSSvubKeKHKUnhbpeav6qqlLIff7ZNoLMDyhqklEnhbMq87lz8ovCEmNvGzQ+CTKOntEEpRacd7qvCOWWpFUWRs91tOeSHtG5t+L1tzH1Civc8jV5e5LzuMxqpCJ+N3feBSnoOrWSdH1ntC9Z5yaaoyIWlbiyX652w6TyH3rA+lLzsC1Zv76wPR3aVQLnxPss+nKhbR9V56j7QiJj+KVqf3r7b7ZZU1q2hmqNz1P2Mdymqbr5Y48PE/1WXBQNFAZ7vAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/91a393f9cb795ceb248a279f8b935fc0/37523/process_memory_1.png\"\n        srcset=\"/static/91a393f9cb795ceb248a279f8b935fc0/e9ff0/process_memory_1.png 180w,\n/static/91a393f9cb795ceb248a279f8b935fc0/f21e7/process_memory_1.png 360w,\n/static/91a393f9cb795ceb248a279f8b935fc0/37523/process_memory_1.png 720w,\n/static/91a393f9cb795ceb248a279f8b935fc0/50383/process_memory_1.png 740w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>프로세스는 각자 본인이 사용하는 메모리 영역과 레지스터 값을 가진다.</p>\n<p>프로세스의 메모리 영역은 <strong>코드,데이터,힙,스택</strong> 영역으로 구성된다.</p>\n<ul>\n<li><strong>코드</strong> : 사용자가 작성한 프로그램 함수들의 코드가 기계어 명령 형태로 변경되어 저장되는 공간</li>\n<li><strong>데이터</strong> : <strong>전역 변수 또는 static 변수</strong> 등 프로그램이 사용하는 데이터를 저장하는 공간</li>\n<li><strong>스택</strong> : <strong>함수의 복귀주소와 지역변수,매개변수,반환값</strong>을 저장하는 공간. 재귀함수가 반복되거나 지역변수가 너무 많으면 stack overflow 발생. <strong>가변적이다</strong>.</li>\n<li><strong>힙</strong> : 프로세스 실행 중에 <strong>런타임에 할당</strong>되는 영역. 이곳에 메모리를 할당하는 것을 <strong>동적 할당</strong>이라고 한다. <strong>가변적이다</strong>.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 221px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 160%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAgCAYAAAASYli2AAAACXBIWXMAAAsTAAALEwEAmpwYAAADx0lEQVRIx41WaU8bSRDl/3/c/bRKAkS7EClRPiyKE7CJYTyHx+O5L18iQRw+1jZJZAQxYN6qam6Po92Rnrq7uuf1q+pWVW8JggBFUSBJEp6fn3F+fg5V02A5LkzbKcCwbBi2zW1mt3NwsDUajXB5eYmLiwvQ1+31oLR1WH4A0/VS0NgNu3CCEG7Ygen5hfkEW1j7+oMBWobJP1qez6B+SzdQq59AkGVuDceF7QfpGoLt+dgiN1erFYO+Xr8PVTdSQtrV63RxWK3h5fY2dnZ3sb2zg6bWLmyagAkTMCErtOCEHVhewCpsP+R+EgY7CGN7BCvXLxFyDFUVlkOHYMFMQUG3YLvxQeTstC5BSriKCe3BGQ6MDo7DL6j6ZylqwRmO3D72qiKqfjRXY3zhNhmXFAZXY9THd2h+W0G5eWTISTt7wNt2D/L8KbUV1swfywr9yxHq1ws0Z0vI058p1JtHHH+d4fd3FTTnj5Cn91By8wRler+JcIj6cIHm/KG4eP6AxvUtDtyvUGbRnDJbQpkuocxozZI3+F+ESqyWSLXvzxkZ2/OEy3IM2eUC4TJVIk+XBbIU0w0K00MpEf5MFcj/LNNNCsrJNvsFYaTwNiXMXIv6dDgllf9NmClUcnEUx3eonk3TDZL5iDDy5Bcu30KdPxQUqN+e+Nr89rYC9eaJfy7FcrbccMoXQxxf/eB7Jk7uUkiTe742b2QX4uQeEtsyiHFbIvQ6HRyJCkTDgtA2ILRNnLZNNHhsoiY10dBN7udxGrcll/uDPjTdgEsZxfPgeD7cIGCbbllso8zMc77P83YMZ2P66vfR1A1ORUkWpnz494cPePnqFXZfv8YfL15AM61iVqd86PqbFA7QtmwmoQTqhFHKp+SpmSYUTcOpJKelwAk60ToaB2EuhnHGDsIQn08FKC0NUlON0YKsqpDVFoOyNdmy+Qwlwk63C0GSoRkm1LbOtYRAY50qn+2wB1QmMujp2o0uU3yowlEcE9eIpHJ4iINKBZ8FIXY3ctWOWyfvclZTikUqqXrkzl/7+1yg3r1/z6dqbcDmU6a6vF536WqQ4rBTuAGlurweQ8/38alagyBJOGk0cNIQGfVGg12tE9iezaV9QdwcQyr0bqwkAV2JsD9A0OsV7OsoKUwKPQU6ccPtdPGxWsXe/hv8ubcPsalGzxF6omyK4fpTJDrlTCH1JbWFyqdDfDw6gm7ZJQ84vnmFw+GQVVKhbyhNvnNEnEDPvWXoCuXn8uDHEhHato3FYsG4ur7GeDLBaDwuYDgagV5r6/Y8/gXjNvCLZWC8owAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/d46dc5a982cd97a7828a89636b927e6e/cccdc/process_memory_2.png\"\n        srcset=\"/static/d46dc5a982cd97a7828a89636b927e6e/e9ff0/process_memory_2.png 180w,\n/static/d46dc5a982cd97a7828a89636b927e6e/cccdc/process_memory_2.png 221w\"\n        sizes=\"(max-width: 221px) 100vw, 221px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이처럼 프로세스는 <strong>각자의 메모리 영역</strong>을 가지기에 프로세스간의 메모리는 서로 침범 할 수 없다.</p>\n<h2 id=\"프로세스-제어-블록-process-control-block-pcb\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9D-process-control-block-pcb\" aria-label=\"프로세스 제어 블록 process control block pcb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 제어 블록 (Process Control Block, PCB)</h2>\n<p>PCB(Process Control Block)는 <strong>특정 프로세스에 대한 중요한 정보를 저장</strong>하고 있는 운영체제의 자료구조이다. 그렇기에 PCB는 일반적으로 보호된 메모리 영역,예를 들면 커널 스택등에 위치한다.</p>\n<p>OS는 프로세스를 관리하기 위해 <strong>프로세스를 생성함과 동시에 고유한 PCB를 생성한다.</strong></p>\n<p>프로세스는 CPU를 할당받아 작업하다가도 context-switching이 일어나면, 진행하던 작업을 저장하고 CPU를 반환해야하는데, 이때의 <strong>작업 진행상황이 PCB에 저장</strong>된다.\r\n그 후 다시 CPU를 할당받게 되면 PCB 안에 있던 정보들을 불러와서 작업이 멈추었던 시점에서부터 다시 시작한다.</p>\n<ul>\n<li>\n<p>프로세스 식별자 : PID</p>\n</li>\n<li>\n<p>프로세스 상태 : <code class=\"language-text\">new,ready,running,waiting,terminated</code></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3UlEQVQ4y+VU2W7aUBC9AgRm+f/PqCAhjR9wVSoWEWynNirGZbcRYRVgDJj1RDMSVprnPlTqSEfjO8u5c2dGFkII/GX864TJZBLRaBSRSASSJCGTySCVSiGdToN8BDqTJv/9TKBYslFuLBbjHCHLMuRnGfnHPAqFAprNJvr9PmzbxnA4xGg0Qq/XDb9J93o9jrEsC4qiIPsli6f8E3K5HIRhGHCGDvrdPjqdDmazGd7exphMJgiCAMvlksld18HlcgHJdDrFer3GeDyG3bJh/bJg/jRRq9YgKPFwOGCz2eB0OnFCu91GtVqFrutsJ6Lz+czVl8tl6K86/J3PsefTGZ7n4Xg8cjFiPp+z43a7sSZjwzRRKVXQMBrodjtsXywWKP4o4uHxAdlcFqqmhjl3IS5BBB+FqqEnaaqGltWC7/uh3f5tQ/mmcGu2222Yc71ew2KYkHq12+0Y+/2e4Y5cJtZ1DS/1F1QqZR4G9Zv89ES6jPSdkOIF9YgMnrfhfhGo9CA4cIDVtFCv1WEaJlRV5X7RxTSU1WoVDoqEcoWmaeE6OI4TwnVdHkLxe5HXQv4qo1QqYTAY/BFHZ67ccXiIIpFIQJISIP0ZtMTxeBzxRJwXl5aY8Dnuo138fz+Hd45V7ag5zclUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/37523/process_state.png\"\n        srcset=\"/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/e9ff0/process_state.png 180w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/f21e7/process_state.png 360w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/37523/process_state.png 720w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/302a4/process_state.png 1080w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/21b4d/process_state.png 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>프로그램 카운터,<strong>PC</strong> : 프로세스가 <strong>다음에 실행할 명령어 주소</strong></p>\n</li>\n<li>\n<p>CPU <strong>레지스터</strong></p>\n</li>\n<li>\n<p>CPU <strong>스케쥴링 정보</strong> : 우선순위, 스케쥴 큐에 대한 포인터 ← 이것을 바탕으로 MLFQ나 RR이 동작한다.</p>\n</li>\n<li>\n<p><strong>메모리</strong> 관리 정보 : <strong>페이지 테이블 또는 세그먼트 테이블에 대한 정보 포함</strong></p>\n</li>\n<li>\n<p>입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록</p>\n</li>\n<li>\n<p>어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호</p>\n</li>\n</ul>\n<p>이 PCB들은 <strong>커널 스택과 같은 보호된 메모리 영역 내에서 Linked List 형태로 관리된다.</strong> PCB List Head에 PCB들이 생성될때 붙는 방식으로 관리가 된다.</p>\n<h2 id=\"스레드thread\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9Cthread\" aria-label=\"스레드thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드(Thread)</h2>\n<p><strong>스레드는 프로세스가 할당받은 자원을 이용하는 실행 단위다.</strong></p>\n<p>한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.</p>\n<p>스레드는 스레드 ID,PC,레지스터 집합, 그리고 각자의 스택으로 구성된다(독립적인 메모리는 아니고, 스택 포인터로 표시한다).</p>\n<p>이를 통해 멀티 쓰레딩을 달성할 수 있는데 멀티쓰레딩은 하나의 프로세스를 여러개의 실행단위(스레드)로 나누어서 자원을 공유하며 자원의 생성과 관리의 중복을 줄여 수행능력을 높이는 것이다.</p>\n<ul>\n<li>공유\n<ul>\n<li>같은 프로세스에 속하는 스레드들은 <strong>힙,데이터,코드 영역을 공유한다.</strong> 추가적으로 open된 파일등도 공유한다.</li>\n</ul>\n</li>\n<li>공유하지 않는 것\n<ul>\n<li>각자의 스택과 레지스터(PC 포함)은 공유하지 않는다.</li>\n</ul>\n</li>\n</ul>\n<p>이렇게 하나의 프로세스 내에서 다수의 실행 단위인 스레드로 구분하여 공유할 자원은 공유하고, 독립적인것은 따로 두어 수행 능력을 향상시키는 것을 멀티스레딩이라 한다.</p>\n<h3 id=\"스레드에서의-메모리-구조\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\"스레드에서의 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드에서의 메모리 구조</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABoUlEQVQoz42SV4/CQAyE9///LR6QQqih9957JwHm9FlaxMOddJac4jI7Hq9bLpfa7/fCdrudZrOZttut+fF4NH+9Xspms6rVahoOh/YdRZG63a6q1ary+bwmk4kWi4Xc+XyWt1arpVQqpUqlovV6/Ynf73flcjlzwMIwVCaTURAEBphOpy03n8/lOAVkmuI4tvf1etV0OjVfrVa63W46HA6W5x9PksQAmIQ4xGDpBoOBTqeTMWGcdrut0WhkjhyA0wBr8s1mU8ViUf1+X41Gw2TodDrq9XrW4wqFgkqlkiUJoBen0VCv1y3HWMiB0YhmGIzK5bKez6ftAXKOJhbB2BRgl8vFADmA+Hg8NuYYcRhiSMJh7/fbJDFACtGEJTASIGyWJAcQ5w1D9IIhU9FDDSNDCD1tZLbGWOgAEy8wjejG9UA3PzIMAfQjw/DxeNiVM4Y8/Ob8yAASZyk4cW7Dv0bmPkEbRjAk+c3Qs/trKdTQ81kKJ4LunQT00RPW/p86GNEEKGD+qkCEerR0jLTZbEx8/waIBXzH+Sf+2zc1OIR+AJ9ndsk2MQsNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/d86cddb51ebd04f91e872a4c148a77f9/6af66/thread_memory.png\"\n        srcset=\"/static/d86cddb51ebd04f91e872a4c148a77f9/e9ff0/thread_memory.png 180w,\n/static/d86cddb51ebd04f91e872a4c148a77f9/f21e7/thread_memory.png 360w,\n/static/d86cddb51ebd04f91e872a4c148a77f9/6af66/thread_memory.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>스레드 역시 프로세스와 단짝인 개념인데, 짧게 말하면 <em><strong>프로세스가 할당받은 자원을 이용하는 실행의 단위</strong></em> 이다. 위의 그림처럼, 여러개의 스레드는 각자의 레지스터와 스택을 가지지만, 나머지 영역은 가지지 않는다. 대신에 <strong>코드,힙,데이터</strong> 영역을 공유해서 병렬적인 수행이 가능하다.</p>\n<ul>\n<li>\n<p><strong>TMI : 왜 스레드는 각자의 스택을 가지고 있을까?</strong></p>\n<p>스레드가 하나의 실행의 context라는 것을 생각하면 자명하다. 그 context내에서 아주 간단하게 여러개의 지역변수,파라미터,반환값,복귀주소등을 가지는데, 그 스레드들이 만약 서로의 스택을 공유하게 된다면, 그 context가 서로 섞이게 된다. 사실 각자의 스택을 가지기 때문에 스레드가 종종 Lightweight Process라고 불리는 이유다. <strong>그리고 각자의 스택을 가지고 있다고 얘기하지만 사실은 하나의 메모리공간을 stack pointer를 이용해서 분리하는 것이다.</strong></p>\n</li>\n<li>\n<p><strong>TMI2 : 그럼 스레드는 왜 각자의 PC와 register도 있을까?</strong></p>\n<p>위의 답과 비슷한 이유인데, PC(Program Counter)나 레지스터의 역할은 <strong>현재 명령어가 어디까지 수행되었는지,수행될때 쓰던 데이터는 무엇이었는지</strong> 알려주는 것이다. 스레드는 CPU를 할당받을때 프로세스처럼 스케쥴러에 의해 결정되는데, 그렇기에 명령어가 연속적으로 실행됨을 보장하지 못하기에 <strong>어디까지 실행되었는지 기록</strong>할 필요가 있는데 그래서 스레드가 각자의 PC를 가지는 것이다.</p>\n</li>\n</ul>\n<h3 id=\"스레드의-장점과-단점\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90\" aria-label=\"스레드의 장점과 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드의 장점과 단점</h3>\n<ul>\n<li><strong>장점</strong>\n<ul>\n<li><strong>반응성</strong>\n<ul>\n<li>특정 스레드가 I/O 작업을 처리중이거나(blocked) 긴 작업을 수행중이여도 다른 스레드는 본인의 일을 계속 할 수 있다.</li>\n</ul>\n</li>\n<li><strong>자원 공유</strong>\n<ul>\n<li>프로세스는 shared memory나 message passing과 같은 기법을 이용해서 자원을 공유할 수 있지만, 스레드끼리는 프로세스의 자원을 서로 공유한다.</li>\n</ul>\n</li>\n<li><strong>경제적</strong>\n<ul>\n<li>프로세스의 자원을 공유하기 때문에 새로운 메모리 주소공간을 할당받을 필요가 없어 생성에 자원이 적게 들어간다.</li>\n<li>스레드 간에 컨텍스트 스위칭을 할 때 캐시 메모리 안비워도 된다. 어차피 같은 메모리 주소공간을 사용하니까 오버헤드가 적다.</li>\n<li>근데 이것도 극복하려고 thread pool이라는 기술도 있다.</li>\n</ul>\n</li>\n<li>확장가능성</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li><strong>공유자원</strong>을 사용하기 때문에 <strong>동기화 문제</strong>를 고려해야 한다.\n<ul>\n<li>lock을 함으로써 공유자원에 대한 동기화를 해결할 수 있는데 이게 병목현상이 될 수 있다.</li>\n<li>그러므로 적절한 부분만 lock을 하는 것이 필요하다. → Critical Section Only</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"멀티-프로세싱-vs-멀티-스레드\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"멀티 프로세싱 vs 멀티 스레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>멀티 프로세싱 vs 멀티 스레드</strong></h1>\n<ul>\n<li>멀티 프로세싱\n<ul>\n<li>두 개 이상의 다수의 프로세스가 협력적으로 하나의 작업을 동시에 병렬적으로 처리하는 것</li>\n<li>프로세스간 메모리 공유는안되기 때문에, <strong>IPC</strong>를 이용해 소통</li>\n<li>하나의 프로세스에서 문제가 생겨도 다른 프로세스는 계속 진행할 수 있음.</li>\n<li><strong>컨텍스트 스위칭 비용이 높음</strong></li>\n</ul>\n</li>\n<li>멀티 스레딩\n<ul>\n<li>단일 프로세스 내에서 여러 쓰레드로 나누어 동시에 실행</li>\n<li><strong>컨텍스트 스위칭 비용이 거의 없음</strong></li>\n<li>스택을 제외한 <strong>데이터,코드,힙 영역을 공유</strong>하기 때문에 <strong>공유하는데 편리</strong>함</li>\n<li>임계영역의 문제가 있음</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">프로세스의 메모리 구조</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9D-process-control-block-pcb\">프로세스 제어 블록 (Process Control Block, PCB)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9Cthread\">스레드(Thread)</a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">스레드에서의 메모리 구조</a></li>\n<li><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90\">스레드의 장점과 단점</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 25, 2021","title":"프로세스와 쓰레드","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/process-and-thread/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.github.io","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/process-scheduling-algorithm/","nextSlug":"/process-and-thread/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}