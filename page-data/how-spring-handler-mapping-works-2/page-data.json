{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/how-spring-handler-mapping-works-2/",
    "result": {"data":{"cur":{"id":"9f73b4bb-d5a7-5501-955c-6499d6b7bb91","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 719px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjElEQVQoz31SO47bMBTUIbbIAXKcRZogVZA27XZ7jXRp9xKB+1zApWHIsGUItCTDkvWzKEqUNME8mI7WcPKAwaMovnnzhvSmaQKj73vEcYzdbgelFMqyhPvHrLWW/f1+jyhSyLIWSv1Cmn5CEHyFUp9R1y/w5oSHwwHr9Rqr1QppmgqRgzEGQRDIvzDcI0lKKLVAnn+B739HGH6D1q/wcA0WHY9HQVVVGIZB9sdxlO8sy5DnuTS21sKYFl034T48FrKIaJoGRVFIYdu2uFwuQsBMCzgBLdlutzidTlchdoYBXl3X4l0UReITCZMkESIWLZdL8c4pnoeza772uq4TBSQmqIwjOYXMbERwdFpCpWzsiObE3rwjjXeKuZ4HFXJs2sJMIfcqhdBtWNtjHHtoTaUFrO3e3TItoKrz+SyknOK/hMYM0BqI41YyzzvfeIaj+74vnm42m9sEDwjHK2GINP2JIPiBpnmDMQv8PTvdXsIc/yAcrg/7N6bpA6rqI7R+grXPcBd7X/Tolh3hH4izTHKPcv51AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image\"\n        title=\"image\"\n        src=\"/static/3ced1b2df8c525ffaec0ce9aa709fff6/073e9/image.png\"\n        srcset=\"/static/3ced1b2df8c525ffaec0ce9aa709fff6/e9ff0/image.png 180w,\n/static/3ced1b2df8c525ffaec0ce9aa709fff6/f21e7/image.png 360w,\n/static/3ced1b2df8c525ffaec0ce9aa709fff6/073e9/image.png 719w\"\n        sizes=\"(max-width: 719px) 100vw, 719px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"mappingregistry\" style=\"position:relative;\"><a href=\"#mappingregistry\" aria-label=\"mappingregistry permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MappingRegistry</h3>\n<p><code class=\"language-text\">MappingRegistry</code>는 아까 살펴본 <code class=\"language-text\">AbstractHandlerMethodMapping</code>의 내부 클래스다. <code class=\"language-text\">MappingRegistry</code>는 <strong>handler method에 대한 모든 mapping을 유지 관리</strong>하고 <strong><code class=\"language-text\">lookup</code>을 수행하는 method</strong>를 가지고 있고 동시성을 가진 접근을 가능하게 해주는 레지스트리다.</p>\n<blockquote>\n<p>A registry that maintains all mappings to handler methods, exposing methods to perform lookups and providing concurrent access.</p>\n</blockquote>\n<p>Package-private for testing purposes.</p>\n<p>가장 중요한 부분이 <strong>handler method에 대한 모든 mapping을 유지 관리</strong>하고 <strong><code class=\"language-text\">lookup</code>을 수행하는 method</strong>를 가지고 있다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MappingRegistry</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">MappingRegistration</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> registry <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">HandlerMethod</span><span class=\"token punctuation\">></span></span> mappingLookup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">MultiValueMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> urlLookup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedMultiValueMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HandlerMethod</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> nameLookup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HandlerMethod</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">CorsConfiguration</span><span class=\"token punctuation\">></span></span> corsLookup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ReentrantReadWriteLock</span> readWriteLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantReadWriteLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  \n  <span class=\"token comment\">// methods</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">MappingRegistry</code> 안에서 <code class=\"language-text\">Map</code> 자료구조를 가진 멤버 변수들이 있다. 그 중에서<code class=\"language-text\">LinkedMultiValueMap</code>이라는 자료구조를 사용한다. 이건 한개의 key에 여러 value들을 저장하는 <code class=\"language-text\">MultiValueMap</code>을 <code class=\"language-text\">LinkedHashMap</code>으로 감싼 자료구조로 Spring이 만든 자료구조다.</p>\n<p><code class=\"language-text\">urlLookup</code>은 <code class=\"language-text\">LinkedMultiValueMap</code>의 자료구조인데, key는 <code class=\"language-text\">url</code>을 가지고, value는 <code class=\"language-text\">RequestMappingInfo</code>를 가진다. <code class=\"language-text\">LinkedMultiValueMap</code>을 쓰는 이유는 하나의 <code class=\"language-text\">url</code>에 여러 handlerMethod들에 대한 정보가 담기기 때문이다.</p>\n<p>예를 들어 <code class=\"language-text\">\"/app/user\"</code>라는 <code class=\"language-text\">url</code> 아래 user에 대한 정보를 조회하는 <code class=\"language-text\">GET</code>,user를 추가하는 <code class=\"language-text\">POST</code>가 매핑될때, 아래처럼 <code class=\"language-text\">RequestMappingInfo</code>가 들어가는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">key <span class=\"token operator\">:</span> \"<span class=\"token operator\">/</span>app<span class=\"token operator\">/</span>user<span class=\"token operator\">/</span> \nvalue <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">GET</span> <span class=\"token operator\">/</span>app<span class=\"token operator\">/</span>user<span class=\"token punctuation\">,</span><span class=\"token constant\">POST</span> <span class=\"token operator\">/</span>app<span class=\"token operator\">/</span>user<span class=\"token punctuation\">]</span></code></pre></div>\n<p>위와 같은 구조를 통해 <code class=\"language-text\">MappingRegistry</code>는 <code class=\"language-text\">url</code>에 해당하는 handlerMethod를 구별할 수 있게 된다. 코드로 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token class-name\">HandlerMethod</span> <span class=\"token function\">lookupHandlerMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> lookupPath<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Match</span><span class=\"token punctuation\">></span></span> matches <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> directPathMatches <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mappingRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">getMappingsByUrl</span><span class=\"token punctuation\">(</span>lookupPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>directPathMatches <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addMatchingMappings</span><span class=\"token punctuation\">(</span>directPathMatches<span class=\"token punctuation\">,</span> matches<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>matches<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    matches<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>comparator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Match</span> bestMatch <span class=\"token operator\">=</span> matches<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    request<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span>BEST_MATCHING_HANDLER_ATTRIBUTE<span class=\"token punctuation\">,</span> bestMatch<span class=\"token punctuation\">.</span>handlerMethod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">handleMatch</span><span class=\"token punctuation\">(</span>bestMatch<span class=\"token punctuation\">.</span>mapping<span class=\"token punctuation\">,</span> lookupPath<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> bestMatch<span class=\"token punctuation\">.</span>handlerMethod<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>위는 아까 잠깐 언급한 <code class=\"language-text\">lookupHandlerMethod</code>이다. <em><strong>적절한 <code class=\"language-text\">handlerMethod</code>를 가져온 후 return 한다</strong></em> 고 했는데 그 과정이 담겨있다.\n길다고 겁먹지 말고 한줄씩 보자. (<em>match되는 것이 없거나, 2개 이상인 경우는 제외함</em>)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Match</span><span class=\"token punctuation\">></span></span> matches <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">match</code>를 담는 <code class=\"language-text\">matches</code>라는 리스트가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> directPathMatches <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mappingRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">getMappingsByUrl</span><span class=\"token punctuation\">(</span>lookupPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>현재 <code class=\"language-text\">url</code>에 mapping되는 handler method들의 <code class=\"language-text\">RequestMappingInfo</code>들을 <code class=\"language-text\">getMappingsByUrl</code>로 가져온 후 <code class=\"language-text\">directPathMatches</code>에 저장한다. 예를 들어 <code class=\"language-text\">url</code>이 <code class=\"language-text\">/app/user</code>이면 <code class=\"language-text\">directPathMatches</code>에는 <code class=\"language-text\">[GET /app/user, POST /app/user]</code> 와 같은 정보가 들어오는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>directPathMatches <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addMatchingMappings</span><span class=\"token punctuation\">(</span>directPathMatches<span class=\"token punctuation\">,</span> matches<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그 후 <code class=\"language-text\">[GET /app/user, POST /app/user]</code> 중에서 request 정보와 일치하는 것들을 <code class=\"language-text\">addMatchingMappings</code>을 통해서 <code class=\"language-text\">matches</code>에 추가한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">matches<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>comparator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Match</span> bestMatch <span class=\"token operator\">=</span> matches<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">matches</code>들을 우선순위에 맞게끔 정렬하고, request와 가장 일치하는 0번째 <code class=\"language-text\">match</code>를 <code class=\"language-text\">bestMatch</code>에 저장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">request<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span>BEST_MATCHING_HANDLER_ATTRIBUTE<span class=\"token punctuation\">,</span> bestMatch<span class=\"token punctuation\">.</span>handlerMethod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">handleMatch</span><span class=\"token punctuation\">(</span>bestMatch<span class=\"token punctuation\">.</span>mapping<span class=\"token punctuation\">,</span> lookupPath<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span> bestMatch<span class=\"token punctuation\">.</span>handlerMethod<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">bestMatch</code>의 멤버인 <code class=\"language-text\">handlerMethod</code>를 return해서 최종적으로 적합한 handler method를 찾게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Match</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">T</span> mapping<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">HandlerMethod</span> handlerMethod<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"reflection\" style=\"position:relative;\"><a href=\"#reflection\" aria-label=\"reflection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reflection</h3>\n<p>이제 마지막 궁금증만이 남았다.</p>\n<h3 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h3>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/4.3.2.RELEASE_to_4.3.3.RELEASE/Spring%20Framework%204.3.3.RELEASE/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.MappingRegistry.html\">MappingReigstry javadoc</a>\n<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/LinkedMultiValueMap.html\">LinkedMultiValueMap javadoc</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#mappingregistry\">MappingRegistry</a></li>\n<li><a href=\"#reflection\">Reflection</a></li>\n<li><a href=\"#%EC%B6%9C%EC%B2%98\">출처</a></li>\n</ul>\n</div>","excerpt":"MappingRegistry 는 아까 살펴본 의 내부 클래스다. 는 handler method에 대한 모든 mapping을 유지 관리하고 을 수행하는 method를 가지고 있고 동시성을 가진 접근을 가능하게 해주는 레지스트리다. A registry that maintains all mappings to handler methods, exposing methods to perform lookups and providing concurrent access. Package-private for testing purposes. 가장 중요한 부분이 handler method에 대한 모든 mapping을 유지 관리하고 을 수행하는 method를 가지고 있다는 것이다.  안에서  자료구조를 가진 멤버 변수들이 있다. 그 중에서이라는 자료구조를 사용한다. 이건 한개의 key에 여러 value들을 저장하는 을 으로 감싼 자료구조로 Spring이 만든 자료구조다. 은 의 자료구조인데, key는 을 …","frontmatter":{"date":"November 05, 2021","title":"Spring MVC - HandlerMapping의 동작방식 이해하기 2편","categories":"Spring","author":"weasel","emoji":"📓"},"fields":{"slug":"/how-spring-handler-mapping-works-2/"}},"next":{"id":"b98e3e53-8195-5969-aa57-8c541f9543d1","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 460px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGeV89UFK//xAAaEAEBAAIDAAAAAAAAAAAAAAABAgADESJC/9oACAEBAAEFAtnUbznN1DXklD//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPwFn/8QAGRAAAgMBAAAAAAAAAAAAAAAAABABETEh/9oACAEBAAY/Ai1uE9X/xAAaEAEAAwEBAQAAAAAAAAAAAAABABEhMUFh/9oACAEBAAE/IXt6xa4+wvsAWjjkaQHrfIIpu9n/2gAMAwEAAgADAAAAEIfP/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAEDAQE/EJGP/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EFrP/8QAHBABAQEBAAIDAAAAAAAAAAAAAREAITFBcZGh/9oACAEBAAE/ECAFaBcmco+nTQ1FcLWjxXfvNoTgfP8AdEAgD87/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"java meme\"\n        title=\"java meme\"\n        src=\"/static/c7f0a4e5d437279c1ee577d32a9f2c97/e41a8/java-meme.jpg\"\n        srcset=\"/static/c7f0a4e5d437279c1ee577d32a9f2c97/4ec73/java-meme.jpg 180w,\n/static/c7f0a4e5d437279c1ee577d32a9f2c97/158ba/java-meme.jpg 360w,\n/static/c7f0a4e5d437279c1ee577d32a9f2c97/e41a8/java-meme.jpg 460w\"\n        sizes=\"(max-width: 460px) 100vw, 460px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>GC를 수행하는 Garabage Collector는 아래와 같은 일을 한다.</p>\n<ul>\n<li>메모리 할당</li>\n<li>사용 중인 메모리 인식</li>\n<li>미사용 메모리 인식</li>\n</ul>\n<p><strong>Stop-the-World</strong></p>\n<ul>\n<li>자바 애플리케이션은 GC 실행시 GC 실행 스레드를 제외한 모든 스레들르 멈추고, GC 완료 후 다시 스레드들을 실행 상태로 변경</li>\n<li>Stop the World는 모든 애플리케이션 스레드들의 작업이 멈추는 상태</li>\n<li>어떤 GC 알고리즘을 사용해도 Stop-the-World는 불가피하며 대개의 GC 튜닝이란 이 Stop-the-World 시간을 줄이는 것이다.</li>\n</ul>\n<h3 id=\"전제\" style=\"position:relative;\"><a href=\"#%EC%A0%84%EC%A0%9C\" aria-label=\"전제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전제</h3>\n<p>가비지 컬렉터는 두가지 전제 조건 하에서 만들어졌다.</p>\n<ul>\n<li>대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다.</li>\n<li>오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.</li>\n</ul>\n<p>이것을 ‘weak generational hypothesis’라고 하는데 이것을 살리기 위해서 <strong>Young 영역</strong>과 <strong>Old</strong> <strong>영역</strong>으로 나누었다.</p>\n<ul>\n<li>Young 영역 (Young Generation 영역) : <strong>새롭게 생성한 객체</strong> 대부분이 여기에 위치하고, 대부분이 금방 <strong>접근불가능</strong> 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말함.</li>\n<li>Old 영역 (Old Generation 영역) : 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다는 GC가 적게 발생한다.(쉽게 가득차지 않으니) 이 영역에서 객체가 사라질 때 Major GC가 발생한다고 말한다.</li>\n</ul>\n<p>객체의 데이터 흐름은 아래와 같다. PermG는 <strong>Java 8에서 Metaspace</strong>로 교체되었다.\n<img src=\"https://images.velog.io/images/hsw0194/post/e69c19a9-6591-4525-b7fb-97b15a47ac6a/Untitled%201.png\" alt=\"\"></p>\n<p>PermG에서 GC가 발생해도 MajorGC의 횟수로 친다.</p>\n<p>전제의 두번째가 “오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다”인데, 만약 실제로 Old 영역의 객체가 Young 영역의 객체를 참조하는 경우가 생긴다면 Old 영역에 512Byte의 chunck로 되어 있는 card table을 따로 두어 해결한다.</p>\n<p>카드 테이블에는 Old 영역에 있는 객체가 <strong>Young 영역의 객체를 참조할 때마다 정보가 표시된다.</strong> Young 영역의 GC를 실행할 때에는 Old 영역에 있는 모든 객체의 참조를 확인하지 않고, <strong>이 카드테이블만 확인해 GC 대상인지 식별한다</strong>.\n<img src=\"https://images.velog.io/images/hsw0194/post/5ca37e27-9ab9-4a73-be73-880d868c89ef/Untitled%202.png\" alt=\"\"></p>\n<p>카드 테이블은 write barrier를 사용하여 관리한다. write barrier는 Minor GC를 빠르게 할 수 있도록 하는 장치인데, 이것 때문에 약간의 오버헤드는 있지만 (<strong>Old가 Young을 참조하는지 Old 영역 전체를 일일이 확인하지 않아도 되기에</strong>) 전반적인 GC시간은 줄어든다.</p>\n<h3 id=\"young-영역의-구성\" style=\"position:relative;\"><a href=\"#young-%EC%98%81%EC%97%AD%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"young 영역의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Young 영역의 구성</h3>\n<p>객체가 제일 먼저 생성되는 Young 영역은 크게 3가지로 나뉜다.</p>\n<ul>\n<li>Eden 영역</li>\n<li>Survivor 영역(2개,From과 To)</li>\n</ul>\n<p>각 영역의 처리 절차를 순서에 따라 기술하면 다음과 같다.</p>\n<ul>\n<li>새롭게 생성한 대부분의 객체는 Eden 영역에 위치한다.</li>\n<li>Eden 영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor 영역 중 하나로 이동한다.</li>\n<li>Eden 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 Survivor 영역으로 객체가 계속 쌓인다.</li>\n<li>하나의 Survivor 영역이 가득차게 되면, 그 중에서 살아남은 객체를 다른 Surivor 영역으로 이동한다. 그리고 가득찬 Survivor 영역은 이제 아무 데이터가 없는 상태가 된다.</li>\n<li>이 과정을 반복하다 계속해서 살아남아 있는 객체는 Old 영역으로 이동하게 된다.</li>\n</ul>\n<p>이 절차에 따라서 <strong>Survivor 영역 중 하나는 반드시 비어있는 상태</strong>로 남아 있어야 한다.</p>\n<blockquote>\n<p>💡 <em>오래되었다고 하는 기준은 Young Generation 영역에서 Minor GC 가 발생하는 동안 얼마나 오래 살아남았는지로 판단한다. 각 객체는 Minor GC에서 살아남은 횟수를 기록하는 <strong>age bit</strong> 를 가지고 있으며, <strong>Minor GC가 발생할 때마다 age bit 값은 1씩 증가</strong> 하게되며, age bit 값이 <strong>MaxTenuringThreshold 라는 설정값을 초과하게 되는 경우 Old Generation 영역을 객체가 이동</strong> 되는 것이다. 또는 Age bit가 MaxTenuringThreshold 초과하기 전이라도 Survivor 영역의 메모리가 부족할 경우에는 미리 Old Generation 으로 객체가 옮겨질 수도 있다.</em> <em>JVM 옵션 : -XX:MaxTenuringThreshold</em></p>\n</blockquote>\n<h3 id=\"그럼-왜-survivor-영역이-두개인가\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%99%9C-survivor-%EC%98%81%EC%97%AD%EC%9D%B4-%EB%91%90%EA%B0%9C%EC%9D%B8%EA%B0%80\" aria-label=\"그럼 왜 survivor 영역이 두개인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그럼 왜 Survivor 영역이 두개인가?</h3>\n<p>퍼포먼스와 연관있는데, fragmentation(단편화)를 줄이기 위함이다.\n예를 들어 새로운 객체는 Eden에 생성된다. Eden이 가득차면 GC가 수행되고 살아있는 객체는 Survivor로 옮겨진다. 근데 그다음에 Eden이 가득차면, Eden과 Survivor 영역의 메모리를 정리하지만 이 영역은 연속적이지 않게 된다. 이런 현상을 방지하기 위해 두가지 Survivor 영역을 두어서 위의 예시에서 두번째 GC시에 Eden과 Survivor 안에 있는 reachable한 객체들은 비어 있는 새로운 Survivor로 옮겨지거나 특정 객체(<strong>Old enough한</strong>)는 Old로 Promotion된다. 그리고 두 Survivor space는 역할을 바꾼다. 하나는 텅텅 비어있고 하나는 Eden에서 올라오는 것을 수용하는 공간. 이 과정을 통해 Heap에서의 <strong>연속적인 메모리 사용</strong>을 가능하게 한다.</p>\n<blockquote>\n<p>다시 말하면 Eden에서도 빈 공간 생기고, Survivor에서도 드문드문 빈 공간이 생기게 되는것. <strong>Memory internal Fragmentation</strong>과 비슷한일이 일어나는것)</p>\n</blockquote>\n<h3 id=\"mark-and-copy\" style=\"position:relative;\"><a href=\"#mark-and-copy\" aria-label=\"mark and copy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mark and Copy</h3>\n<p>SerialGC에서 Young Generation에게 쓰는 GC 방식이다.</p>\n<ul>\n<li><strong>Fragmentation(단편화) 방지에는 효과적</strong>이다.</li>\n<li>Heap의 절반 밖에 사용하지 못하니 공간 활용의 비효율성</li>\n<li>Suspend 현상(Copy할때), Copy에 대한 Overhaed 존재</li>\n</ul>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/ae4e6a2d-f0be-49f2-a110-f4cc9219e1b1/Untitled%203.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>Mark and Copy</strong> algorithms are very similar to the Mark and Compact as they too relocate all live objects. The important difference is that the target of relocation is a different memory region as a new home for survivors. Mark and Copy approach has some advantages as copying can occur simultaneously with marking during the same phase. The disadvantage is the need for one more memory region, which should be large enough to accommodate survived objects.</p>\n</blockquote>\n<h3 id=\"old-영역에-대한-gc\" style=\"position:relative;\"><a href=\"#old-%EC%98%81%EC%97%AD%EC%97%90-%EB%8C%80%ED%95%9C-gc\" aria-label=\"old 영역에 대한 gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Old 영역에 대한 GC</h3>\n<p>Old 영역은 기본적으로 데이터가 가득 차면 GC를 실행한다. GC 방식에 따라 처리 절차가 달라지므로 GC 방식에 따라 접근하고 이해해야 한다. JDK 7 기준 5가지 방식</p>\n<ul>\n<li>Serial GC (싱글코어를 상정하고 만든 방식이라 운영서버 사용금지)</li>\n<li>Parallel GC</li>\n<li>Parallel Old GC(Parallel Compacting GC)</li>\n<li>Concurrent Mark &#x26; Sweep GC(CMS)</li>\n<li>G1(Garbage First) GC (도입은 JDK7, JDK9부터 기본 GC)</li>\n</ul>\n<h3 id=\"serial-gc\" style=\"position:relative;\"><a href=\"#serial-gc\" aria-label=\"serial gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Serial GC</h3>\n<p>Young 영역에서의 GC는 앞에서 설명한 방식을 사용하고,(<strong>Mark and Copy</strong>) Old 영역의 GC는 <strong>mark-sweep-compact</strong> 알고리즘을 사용한다. 디스크 조각모음과 비슷하다. 두 GC 모두 Stop-the-World를 트리거한다.</p>\n<ol>\n<li>Old 영역에 살아 있는 객체를 식별(<strong>Mark</strong>)한다.</li>\n<li>Heap의 앞 부분부터 확인하여 살아있는 것만 남긴다.(<strong>Sweep)</strong></li>\n<li>각 객체들이 연속되게 쌓이도록 Heap의 가장 앞 부분부터 채워서 객체가 존재하는 부분과 존재하지 않는 부분으로 남긴다.(<strong>Compaction)</strong></li>\n</ol>\n<p>적은 메모리와 CPU 코어 개수가 적을때 적합한 방식이다.</p>\n<h3 id=\"parallel-gc\" style=\"position:relative;\"><a href=\"#parallel-gc\" aria-label=\"parallel gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel GC</h3>\n<p>기본적인 알고리즘은 Serial GC와 같다. 그러나 SerialGC가 GC를 처리하는 스레드가 하나인 것에 비해 Parallel GC는 GC를 처리하는 <strong>스레드가 여러개</strong>로 SerialGC보다 빠르게 수행된다. 메모리가 충분하고 코어의 개수가 많을 때 유리하다. <strong>Throughput GC</strong>라고도 부른다.</p>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/301f3f1d-9e3d-44e4-bd73-30ee8c7ab469/Untitled%204.png\" alt=\"\">\n더 빠르게 동작하니 Stop-the-World의 시간도 줄여주는 효과를 얻을 수 있고 Java 애플리케이션 전체가 매끄럽게 동작한다.</p>\n<h3 id=\"parallel-old-gc\" style=\"position:relative;\"><a href=\"#parallel-old-gc\" aria-label=\"parallel old gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel Old GC</h3>\n<p>JDK5u6부터 제공한 GC 방식이고, Parallel GC와 비교하여 Old 영역의 GC 알고리즘만 다르다. 이 방식은 <strong>Mark-Summary-Compaction</strong> 단계를 거친다. Summary 단계는 앞서 GC를 수행한 영역에 대해 별도로 살아 있는 객체를 식별한다는 점에서 Mark-Sweep-Compcation 알고리즘의 sweep 단계와는 다르며, 약간 더 복잡하다.</p>\n<ul>\n<li><strong>Sweep</strong>은 <strong>단일 스레드</strong>가 Old 영역 전체를 훑어 살아있는 객체만 찾는다.</li>\n<li><strong>Summary</strong>는 <strong>여러 스레드</strong>가 Old 영역을 분리하여 훑는다. 또 효율성을 위해 Compaction된 영역도 별도로 훑는다.</li>\n</ul>\n<h3 id=\"cms-gc-concurrent-mark-sweep-garbage-collector\" style=\"position:relative;\"><a href=\"#cms-gc-concurrent-mark-sweep-garbage-collector\" aria-label=\"cms gc concurrent mark sweep garbage collector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CMS GC (Concurrent Mark-Sweep Garbage Collector)</h3>\n<p>GC 과정에서 발생하는 Stop-the-World의 시간을 최소화하는데 초점을 맞춘 GC 방식으로 GC의 과정이 복잡하다.</p>\n<p>GC 대상을 최대한 자세히 파악한후, 정리하는 시간(STW가 발생하는 시간)을 짧게 가져가는 컨셉으로, 과정이 복잡한 만큼 다른 GC 대비 CPU 사용량이 높다.</p>\n<p>아래의 그림은 Serial GC와 CMS GC를 비교한 그림이다. 엄청 복잡.</p>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/2a1ae290-5b84-41e3-a97a-04d07a49ea9e/Untitled%205.png\" alt=\"\">\nYoung 영역에서는 <strong>Mark and copy</strong>방식을 그대로 사용하고 Old 영역은 Concurrent Mark-Sweep 알고리즘을 사용한다.</p>\n<p>CMS GC는 <strong>Initial Mark → Concurrent Mark → Remark → Concurrent Sweep</strong> 과정이다.</p>\n<ul>\n<li><strong>Initial Mark</strong>\n<ul>\n<li>GC 과정에서 살아남은 객체를 탐색하는 시작 객체(GC Root)에서 참조 Tree상 가장 가까운 객체만 1차적으로 찾아가며 객체가 GC대상(참조가 끊긴)인지를 판단한다. 이때는 STW 현상이 발생하지만, 탐색 깊이가 얕아 STW 발생 기간이 매우 짧다.</li>\n</ul>\n</li>\n<li><strong>Concurrent Mark</strong>\n<ul>\n<li>STW 현상없이 진행되며, Initial Mark 단계에서 GC 대상으로 판별된 객체들이 참조하는 다른 객체들을 따라가며 GC 대상인지를 추가적으로 확인한다.</li>\n<li>이 단계의 특징은 다른 스레드가 실행중인 상태에서 동시에 진행된다는 것.</li>\n</ul>\n</li>\n<li><strong>Remark</strong>\n<ul>\n<li>Concurrent Mark 단계의 결과를 검증하며, 이전 단계에서 GC 대상으로 추가 확인되거나 참조가 제거되었는지 등을 확인한다. 이 과정은 STW를 유발하기 때문에 STW 지속시간을 최대한 줄이기 위해 멀티스레드로 검증 작업을 수행한다.</li>\n</ul>\n</li>\n<li><strong>Concurrent Sweep</strong>\n<ul>\n<li>STW 없이 Remark 단계에서 검증 완료된 GC 객체들을 메모리에서 제거한다.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/a1b7f7fd-119a-4c13-8620-579be4c807db/Untitled%206.png\" alt=\"Initial Mark -> Concurrent Mark -> Remark -> Concurrent Sweep , CMS의 상황\">\n<em>Initial Mark -> Concurrent Mark -> Remark -> Concurrent Sweep ,</em> CMS의 상황</p>\n<p>CMS GC는 Compaction 작업을 <strong>필요한 경우에만</strong> 수행한다. 즉, 연속적인 메모리 할당이 어려울 정도로 메모리 단편화과 심한 경우에만 Compaction 과정을 수행하는 것이다.</p>\n<p>또 이러한 단계로 진행되는 것이기에 STW 시간이 매우 짧고, 모든 애플리케이션의 응답 속도가 매우 중요할 때 CMS GC를 사용하며, Low Latency GC라고도 부른다.</p>\n<h3 id=\"g1-gc-garbage-first\" style=\"position:relative;\"><a href=\"#g1-gc-garbage-first\" aria-label=\"g1 gc garbage first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>G1 GC (Garbage First)</h3>\n<p>G1 GC는 기존의 Young 영역과 Old 영역을 구분하던 방식과는 다른 접근을 한다.</p>\n<p>아래 그림과 같이 G1 GC는 <strong>바둑판처럼 영역을 구분</strong>하고 그 영역에 객체를 할당하고 GC를 실행한다. 해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행한다.</p>\n<p>기존의 Young의 Eden/Survivor 영역에서 데이터가 Old 영역으로 이동하는 단계가 사라진 GC방식이다. 또 G1 GC에선 각각의 바둑판 모양의 영역이 <strong>Eden,Survivor,Old 영역의 역할을 동적으로 바꿔가며 GC가 일어난다.</strong>\n<img src=\"https://images.velog.io/images/hsw0194/post/19719195-b95f-4434-a093-57c28684ba9e/Untitled%207.png\" alt=\"\"></p>\n<p>G1 GC는 지금껏 얘기한 어떤 GC 방식보다 빠른 성능을 장점으로 가진다. 다시 말해 짧은 STW를 지향한다는 것이다.</p>\n<p>G1 GC는 굉장히 크기가 큰 Heap에서도 짧은 STW 시간은 보이는데 왜 그런것일까?</p>\n<h3 id=\"g1-gc의-비밀\" style=\"position:relative;\"><a href=\"#g1-gc%EC%9D%98-%EB%B9%84%EB%B0%80\" aria-label=\"g1 gc의 비밀 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>G1 GC의 비밀</h3>\n<p>Heap의 용량이 커지면 커질수록, 객체의 갯수가 많아지고, 자연스럽게 GC 수행시간이 길어지며 STW 시간도 늘어난다. 하지만 G1 GC는 다르다.</p>\n<ol>\n<li>GC시에 전체 Heap에 대해서 GC를 수행할 필요가 없다. GC 해야하는 영역만 GC를 수행하면 되기 때문이다.</li>\n<li>Old 영역에 대한 Compaction을 할때, 전체 Old 영역에 대해서 Compaction을 할 필요가 없다. 특정한 영역에 대해서만 Compaction을 하면 된다.</li>\n<li>Garbage를 먼저 수집해간다. G1 GC는 살아있는 객체를 마킹한후에 <strong>영역 별로 얼만큼 살려줘야 하는지를 알 수 있다.</strong> 그 후 영역 중에 모든 객체가 죽은 리전(유효한 객체가 없는,<strong>Garbage만 있는 영역</strong>)부터 먼저 회수를 한다. 메모리 회수를 먼저하기에 빈 공간 확보를 더 빨리 할 수 있다. 그러면 GC가 낮은 빈도로 일어난다.</li>\n</ol>\n<h3 id=\"왜-g1gc가-jdk9부터-default-gc로-선정되었을까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-g1gc%EA%B0%80-jdk9%EB%B6%80%ED%84%B0-default-gc%EB%A1%9C-%EC%84%A0%EC%A0%95%EB%90%98%EC%97%88%EC%9D%84%EA%B9%8C\" aria-label=\"왜 g1gc가 jdk9부터 default gc로 선정되었을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 G1GC가 JDK9부터 default GC로 선정되었을까?</h3>\n<blockquote>\n<p>G1 GC의 목표는 일시정지 시간 (STW)을 최소화하는데 있다. 영역별로 나누어서 GC를 수행하기 때문에 전체 Old 영역에 대한 GC를 수행하는 일이 생기지 않아 긴 시간의 STW를 가지는 Major GC의 빈도를 낮출수 있어서 선택되었다고 생각한다.</p>\n</blockquote>\n<h3 id=\"출처-\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98-\" aria-label=\"출처  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처 :</h3>\n<p><a href=\"https://perfectacle.github.io/2019/05/11/jvm-gc-advanced/\">JVM GC</a></p>\n<p><a href=\"https://d2.naver.com/helloworld/1329\">네이버 D2 블로그</a></p>\n<p><a href=\"https://plumbr.io/handbook/garbage-collection-algorithms-implementations\">전체적인 GC에 대한 통계 제공</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%A0%84%EC%A0%9C\">전제</a></li>\n<li><a href=\"#young-%EC%98%81%EC%97%AD%EC%9D%98-%EA%B5%AC%EC%84%B1\">Young 영역의 구성</a></li>\n<li><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%99%9C-survivor-%EC%98%81%EC%97%AD%EC%9D%B4-%EB%91%90%EA%B0%9C%EC%9D%B8%EA%B0%80\">그럼 왜 Survivor 영역이 두개인가?</a></li>\n<li><a href=\"#mark-and-copy\">Mark and Copy</a></li>\n<li><a href=\"#old-%EC%98%81%EC%97%AD%EC%97%90-%EB%8C%80%ED%95%9C-gc\">Old 영역에 대한 GC</a></li>\n<li><a href=\"#serial-gc\">Serial GC</a></li>\n<li><a href=\"#parallel-gc\">Parallel GC</a></li>\n<li><a href=\"#parallel-old-gc\">Parallel Old GC</a></li>\n<li><a href=\"#cms-gc-concurrent-mark-sweep-garbage-collector\">CMS GC (Concurrent Mark-Sweep Garbage Collector)</a></li>\n<li><a href=\"#g1-gc-garbage-first\">G1 GC (Garbage First)</a></li>\n<li><a href=\"#g1-gc%EC%9D%98-%EB%B9%84%EB%B0%80\">G1 GC의 비밀</a></li>\n<li><a href=\"#%EC%99%9C-g1gc%EA%B0%80-jdk9%EB%B6%80%ED%84%B0-default-gc%EB%A1%9C-%EC%84%A0%EC%A0%95%EB%90%98%EC%97%88%EC%9D%84%EA%B9%8C\">왜 G1GC가 JDK9부터 default GC로 선정되었을까?</a></li>\n<li><a href=\"#%EC%B6%9C%EC%B2%98-\">출처 :</a></li>\n</ul>\n</div>","frontmatter":{"date":"November 05, 2021","title":"Java의 알쏭달쏭한 GC","categories":"Java","author":"weasel","emoji":"📓"},"fields":{"slug":"/java-gc/"}},"prev":{"id":"79ae2a8f-01d0-50f4-814c-5192b56de742","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEDBf/aAAwDAQACEAMQAAAB042MOwD/AP/EABcQAAMBAAAAAAAAAAAAAAAAAAECESD/2gAIAQEAAQUCawFrj//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABoQAAICAwAAAAAAAAAAAAAAAAERACECIIH/2gAIAQEABj8CoMy8V3X/xAAZEAEAAwEBAAAAAAAAAAAAAAABESFRACD/2gAIAQEAAT8hQbkExPNoDbef/9oADAMBAAIAAwAAABD/AO//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAWEQEBAQAAAAAAAAAAAAAAAAABERD/2gAIAQIBAT8QEkmf/8QAGxAAAgEFAAAAAAAAAAAAAAAAAREhACBBUbH/2gAIAQEAAT8QB6EGWRp4pKWTDgrf/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"kakaopay logo\"\n        title=\"kakaopay logo\"\n        src=\"/static/d1f66dccbc3f0f4a7eba3d6bb104b50e/80e3c/kakaopay_logo.jpg\"\n        srcset=\"/static/d1f66dccbc3f0f4a7eba3d6bb104b50e/4ec73/kakaopay_logo.jpg 180w,\n/static/d1f66dccbc3f0f4a7eba3d6bb104b50e/158ba/kakaopay_logo.jpg 360w,\n/static/d1f66dccbc3f0f4a7eba3d6bb104b50e/80e3c/kakaopay_logo.jpg 720w,\n/static/d1f66dccbc3f0f4a7eba3d6bb104b50e/6a068/kakaopay_logo.jpg 960w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>도전기? 후기? 어느단어를 써야할지 한참 고민하다가 도전기로 선택했습니다.\n<strong>도전기로 선택한 이유는 결과와 상관없이 공채의 모든 과정에서 배운점이 굉장히 많았거든요.</strong></p>\n<blockquote>\n<p>그런면에선 개발자 취준생인 저의 성장기도 맞는 것 같습니다.</p>\n</blockquote>\n<blockquote>\n<p>글이 <strong>굉장히,매우</strong> 호흡이 깁니다. 적당히 스크롤 내려가면서 스킵하면서 읽어주세요.. 공채 얘기만 궁금하시면 뜬금없는 블라인드 공채 목차쯤부터 보시면 됩니다.</p>\n</blockquote>\n<h2 id=\"조금-늦은-시작\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%EA%B8%88-%EB%8A%A6%EC%9D%80-%EC%8B%9C%EC%9E%91\" aria-label=\"조금 늦은 시작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>조금 늦은 시작</h2>\n<p>저는 서울 소재 H대학교에서 컴퓨터계열을 전공하다 3학년을 수료하고 20년도 초에 사회복무요원으로 입대하게 되었습니다.\n여러가지 사정들로 군 복무가 굉장히 늦어졌고, 3학년을 마칠때까지 아직 <strong>진로에 대해서 확실히 정하지 못했습니다.</strong> 분명 개발을 좋아하고 적당히 실력도 있었지만, 그만큼 컴퓨터공학에 대한 열정도 있어서 진학 후 연구도 하고 싶었습니다. 개발자와 진학 중 하나를 선택하기 위해서는 일단 군 문제 먼저 해결해야한다고 생각해 일단 복무를 시작했습니다.</p>\n<p>그러던 중, 5월쯤 취업한 친한 과 동기를 만나서 여러가지 얘기를 하던 중, 본인의 입사동기 중 한명은 <em><strong>매일 백준에서 알고리즘 1문제를 꾸준히 풀었다</strong></em> 라는 말을 듣게 되었습니다. 일반적인 사람이라면 흘려듣거나 or 조언을 받아들일텐데 저는 태생적으로 <strong>반골</strong>기질이 있어서인지 <strong>그게 그렇게 어렵고 대단한 일인가?</strong> 라는 생각이 먼저 들게 되었습니다. 그 노력을 폄하하려는게 절대 아니라 <strong>정말 순수하게 궁금했습니다.</strong></p>\n<blockquote>\n<p>사실 이전까지 알고리즘 문제를 단 한번도 풀어보지 않았지만 갑자기 저런 당돌한 생각이 들더라구요.</p>\n</blockquote>\n<h2 id=\"습관-들이기와-실패\" style=\"position:relative;\"><a href=\"#%EC%8A%B5%EA%B4%80-%EB%93%A4%EC%9D%B4%EA%B8%B0%EC%99%80-%EC%8B%A4%ED%8C%A8\" aria-label=\"습관 들이기와 실패 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>습관 들이기와 실패</h2>\n<p>학부때 배운 알고리즘 지식을 제외하고 PS계통에 대한 지식은 전무했습니다. 자료구조와 알고리즘에 대한 조금의 배경지식은 있었지만, 그것을 제외하고는 완전한 뉴비수준이었습니다.\n일반적으로 근무지에서 정해진 일을 하고 난 후에 어느정도의 개인시간이 보장되기에 노트북을 들고와 대략 6월부터 <a href=\"https://www.acmicpc.net/\">백준</a>사이트에서 아주 난이도가 낮은 문제부터 한 문제씩 풀기 시작했습니다.</p>\n<p>구현, 자료구조, 탐색, DP 와 같은 알고리즘 분류도 조금씩 신경쓰면서 풀었습니다. 매일 문제가 잘 풀리거나 쉬운 문제 같은 경우는 2~3문제, 어려운 문제라면 1시간씩 고민해가면서 풀고 정 풀리지 않으면 해답을 참고하되 저만의 논리구조를 머릿속에 구상해서 다시 풀어보았습니다. 평균적으로 1일 1문제 정도는 꼬박꼬박 풀었습니다.</p>\n<blockquote>\n<p><a href=\"https://github.com/BecomeWeasel/daily_algo_challenge\">https://github.com/BecomeWeasel/daily_algo_challenge</a> 에 업로드하면서 성취감을 느꼈습니다. 여러분도 참고해보세용!</p>\n</blockquote>\n<p>3개월간은 정말 재밌게, 그리고 제가 느끼기에도 성장한다는 것을 느낄정도로 열심히 했습니다. 하지만 문제가 생겼습니다. 10월쯤 되어서 조금씩 귀찮아지기 시작했고, 다시 로스트아크라는 게임에 열중하게 되면서 알고리즘을 완전 뒤편으로 미루게 되었고 시간을 좀 허비하게 되었습니다.</p>\n<blockquote>\n<p>로스트아크는 정말 재밌게 했습니다. 진짜 재밌었어요..</p>\n</blockquote>\n<h2 id=\"다시-시작하기\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%8B%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\" aria-label=\"다시 시작하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다시 시작하기</h2>\n<p>21년도 4~5월쯤 되어서야 흘러가는 시간이 너무 아깝다고 느껴서 다른 개발 공부와 알고리즘 풀이를 다시 시작했습니다. 이전의 감각을 찾기 위해서 무리하지 않고 평일에만 1문제씩 풀고, <strong>주말은 무리하지 않고 알고리즘 공부가 아닌 다른 개발 공부를 했습니다.</strong> 또 백준뿐만 아니라 리트코드와 프로그래머스 문제들도 풀었습니다.\n개인적으로 문제들의 다양성은 백준이 좋지만, <strong>질은 리트코드가 압도적</strong>이라고 생각합니다.\n또 동아리 <strong>후배 둘과 스터디를 구성해 알고리즘 스터디</strong>를 시작했습니다.\n<strong>개인적으로 이게 정말 정말 많은 도움이 되었습니다.</strong> 여러분들도 단기적인 스터디 말고 긴 호흡의 스터디를 구성하는걸 추천드립니다.</p>\n<blockquote>\n<p>같이 스터디를 하면서 함께 성장한 IS 오렌지와 CS 강민이 정말 고마웡,,🙇‍♂️</p>\n</blockquote>\n<h2 id=\"뜬금없는-블라인드-공채\" style=\"position:relative;\"><a href=\"#%EB%9C%AC%EA%B8%88%EC%97%86%EB%8A%94-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EA%B3%B5%EC%B1%84\" aria-label=\"뜬금없는 블라인드 공채 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>뜬금없는 블라인드 공채</h2>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/5581e750-3b37-4de6-81de-911e61947bf4/image.png\" alt=\"\">\n알고리즘 문제를 조금씩 풀면서 스터디를 해가던 중 카카오에서 <strong>2022 신입 개발자 블라인드 채용</strong> 공고를 올린 것을 보게 되었습니다. 일반적으로 코딩테스트의 난이도를 생각했을때 문제의 질이나 난이도적인 측면에서 높은 기업이기에 이전에도 종종 카카오 코테를 참고하곤 했습니다.</p>\n<p>입시를 준비할때도 실전모의고사가 가장 효과가 좋듯 정말 가볍게 코딩테스트만 보기로 마음먹고 지원을 해보았습니다. 모두들 아시다시피 카카오는 지원을 할때 필수적인 정보만 적고 <strong>자기소개서나 학력같은걸 일체 명시하지 않습니다.</strong></p>\n<p>지원자격도 <strong>학력 및 전공에 제한이 없고 남성의 경우 군필의 제한만</strong> 있었습니다.\n저는 지원할때는 아직 소집해제 전이였지만, <strong>입사전에는 소집해제를 하기 때문에 지원을 해보았습니다.</strong>\n<img src=\"https://images.velog.io/images/hsw0194/post/43ba3e2a-6774-4919-9331-410c62d0a86c/image.png\" alt=\"\">\n또 저는 3학년까지 밖에 마치지 않았고 졸업하기까지는 1년이 남았지만 , <strong>일반적인 기업에서 요구하는 것처럼 졸업이나 졸업예정자 조건을 카카오는 요구하지 않았습니다.</strong>\n<img src=\"https://images.velog.io/images/hsw0194/post/f3d6ed09-882a-44fe-b997-b496aa4ad9d9/image.png\" alt=\"\">\n저는 아래처럼 4개의 전형절차중에서 1단계인 1차 온라인 코딩테스트만 <strong>찍먹</strong>만 해보려고 지원을 했습니다.\n<img src=\"https://images.velog.io/images/hsw0194/post/275e3e8e-2218-4b39-85bd-0b70f386a5a4/image.png\" alt=\"\">\n지원과정에서 입사를 희망하는 계열사를 1지망 2지망으로 선택하는데 저는 <strong>카카오페이</strong>와 <strong>카카오 본사</strong>를 각각 선택했습니다.</p>\n<h2 id=\"1차-코딩테스트\" style=\"position:relative;\"><a href=\"#1%EC%B0%A8-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"1차 코딩테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1차 코딩테스트</h2>\n<p>1차 코딩테스트는 9월 11일로 지원하고 일주일 정도의 시간이 있었습니다. 엄청 대단한것을 준비하지는 않았고, 기출문제들을 풀어보면서 카카오 코테들의 <strong>경향성을 파악</strong>하는데 시간을 들였습니다. 이 경향성 분석이 조금 도움이 되었던 것 같습니다. 기본적인 자료구조와 알고리즘을 다시 복습하고, 제가 스스로 정리한 문제 분류별 해결방법을 다시 읽어보면서 기다렸습니다.</p>\n<p>9월 11일이 되어서 5시간동안의 1차 코딩 테스트를 응시했습니다. 1차 코딩테스트의 후기는 다른 글에도 많이 정리되어있으니 크게 다루지는 않겠습니다.\n총 7개의 문제가 있었고, 확실히 이전보다는 난이도가 많이 낮았습니다. 난이도는 체감상 실버 2문제, 골드 3문제, 플래티넘 이상 2문제 정도였습니다.</p>\n<p>그렇지만 첫 코딩테스트이기도 하고 시간이 정해져있다는 압박감에 5번문제(양과 늑대) 같은 쉬운 탐색 문제나 6번문제 (구간합)문제를 보고 머리가 하얗게 변했습니다. 풀이도 잘 떠오르지 않았습니다.</p>\n<p>결과적으로 <strong>4.5개</strong>의 문제만 해결할 수 있어서 탈락을 직감했습니다.</p>\n<p>그렇게 지내던 중, <strong>[카카오] 2022 신입 개발자 블라인드 채용 1차코딩테스트 결과 안내드립니다.</strong> 라는 제목의 메일을 받게 되었고, 뒹굴거리면서 확인을 했는데 결과는 충격적이게도 <strong>합격</strong>이었습니다.</p>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/c3afa1e2-dd1f-46d5-94b7-dd15e590c67f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-12-15%2021.07.57.png\" alt=\"\">\n기쁘다는 감정보다 <strong>이때까지 공부하던것이 그렇게 헛되지 않았구나</strong>라는 감정을 먼저 느끼게 되었습니다.</p>\n<h2 id=\"2차-코딩테스트\" style=\"position:relative;\"><a href=\"#2%EC%B0%A8-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"2차 코딩테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2차 코딩테스트</h2>\n<p>그리고 정말 급급하게 2차 코딩테스트를 준비해야 했습니다. 2차 코딩테스트를 준비하면서 알게된 점이 2차 코딩테스트는 엄청난 알고리즘 실력보다 디자인(<em>그 디자인이 아닌 설계</em>)과 최적화에 집중해야 한다는 것을 알게 되었습니다.</p>\n<p>기출 문제와 채점하는 환경이 대부분 공개되어 있기때문에 2021,2020 블라인드 공채 2차 코테문제를 스터디원 중 한명과 같이 풀어보았습니다. 그런데 아무리 해봐도 풀리지가 않았습니다. 전날까지 보고갔는데도 도저히 모르겠더라구요..\n<strong>자포자기의 심정이었습니다.</strong></p>\n<p>그렇게 9.25일이 되어서 2차 코딩테스트를 치루게 되었습니다. 2차 코딩테스트는 10문항 정도의 CS 객관식+주관식 문제와 하나의 문제인 시스템 설계와 최적화 파트로 구성되어 있습니다. 중간 중간 휴식시간을 포함해서 총 7시간 정도 응시하고, 캠과 화면 모니터링을 켜고 봐야합니다.</p>\n<h3 id=\"cs-문제\" style=\"position:relative;\"><a href=\"#cs-%EB%AC%B8%EC%A0%9C\" aria-label=\"cs 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CS 문제</h3>\n<p>대부분의 문제는 <strong>CS 코어 과목에서 출제되었고 기본에 충실한 문제들이었습니다.</strong> 학부 수업을 충실하게 들은 전공자라면 큰 부담이 되지 않는 문제 8문제 정도와 살짝 헷갈릴 수 있는 2문제 정도로 구성되어 있습니다. 저는 10문제 중에서 7개 정도 맞았던 걸로 기억합니다.</p>\n<blockquote>\n<p>CS 테스트는 점수보다 적부라는 썰이 있습니다.</p>\n</blockquote>\n<h3 id=\"설계와-최적화-문제\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EA%B3%84%EC%99%80-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%AC%B8%EC%A0%9C\" aria-label=\"설계와 최적화 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설계와 최적화 문제</h3>\n<p>어차피 해설이 올라올 것이고 아직은 민감할 수 있기 때문에 자세히는 언급하지 않고 간단하게 말씀드리겠습니다.</p>\n<p>2차 코딩테스트는 ICPC같은 대회처럼 응시자들의 점수와 나의 등수를 실시간으로 확인할 수 있기에 부담이 되었습니다. 저는 부담을 최대한 덜 받기 위해서 잘 확인하지 않았습니다.\n문제가 시나리오1,2로 구성되기에 합산점수로 최종점수가 매겨집니다.</p>\n<p>복수의 사용자들의 실력에 맞게끔 정렬하는 것이 최종 목적인데, 사용자들의 실제 실력을 알 수 없기 때문에 온라인 게임에서 많이 볼 수 있는 <strong>랭크 기반 매칭시스템</strong>을 구현하는 것이 방법입니다.</p>\n<p>제한적인 검색이 가능하기 때문에 사례를 많이 찾아보았고 Elo 시스템을 채택하였습니다. 그 후 적당히 최적화 방법을 계속 구현해 최종점수를 조금씩 끌어올렸습니다. 응시 종료 30분전 점수판이 프리징되는데 그 때 기준으로 <strong>300등대 초반으로 마무리했습니다.</strong></p>\n<p>2차 코테를 끝내고 카카오가 3자리수대의 채용을 한다고 했으니 약간 희망을 품었지만,신경쓰지 않고 얼마 안남은 소집해제만 대비하며 내년 복학준비만 생각하고 있었습니다.</p>\n<p>그러던 와중 <strong>소집해제일인 10.14일</strong>이 되었고 뭔가 기분이 묘한 감정을 느끼던 와중에\n<strong>[카카오] 2022 신입 개발자 블라인드 채용 2차코딩테스트 안내드립니다.</strong> 라는 제목의 메일을 받게 되엇습니다.\n<img src=\"https://images.velog.io/images/hsw0194/post/dfc98ef1-4c7c-43cd-901b-aa770ee2cd65/image.png\" alt=\"\">\n1지망으로 작성한 카카오페이에 <strong>합격</strong>이었습니다. 뭔가 <strong>일이 이상하게 굴러가고 있다</strong>는 것을 느끼게 되었고 기분이 이상했습니다.</p>\n<h2 id=\"hr-인터뷰\" style=\"position:relative;\"><a href=\"#hr-%EC%9D%B8%ED%84%B0%EB%B7%B0\" aria-label=\"hr 인터뷰 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HR 인터뷰</h2>\n<h3 id=\"자기소개서와-hr-인터뷰-준비하기\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EA%B8%B0%EC%86%8C%EA%B0%9C%EC%84%9C%EC%99%80-hr-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0\" aria-label=\"자기소개서와 hr 인터뷰 준비하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자기소개서와 HR 인터뷰 준비하기</h3>\n<p>특이하게도 카카오페이는 1차가 기술인터뷰가 아닌 HR인터뷰였습니다.\n일반적으로 최종면접이 인성면접인데 <strong>순서가 반대였습니다.</strong></p>\n<blockquote>\n<p>후에 알게되었지만, 다 이유가 있었습니다.</p>\n</blockquote>\n<p>HR인터뷰 단어가 생소했지만, 컬쳐핏 면접이나 인성면접으로 생각했습니다. 소집해제 날부터 급하게 자기소개서를 준비했습니다.</p>\n<p>공대생치고는 드림클래스나 서포터즈,교내 홍보대사같은 대외활동을 많이 해본편이어서 여러 대외활동을 위한 자기소개서는 꽤 써보았지만, 취업준비를 당연히 해본적이 없기에 <strong>자기소개서부터 걱정이였습니다.</strong> 하지만 다행히도 문항들은 평이한 수준이었고, 프로젝트 경험과 같은 일반적인 질문들로 구성되었습니다.</p>\n<p>입대하기전 <strong>SKT에서 수상했던 AI 공모전 우승</strong>경험을 중점적으로 작성했고 그 과정에서 접근방식과 해결방식 위주로 작성했습니다. (후술하겠지만 이 부분에서 굉장히 좋은 평가를 받았습니다.) 또 아주 조그만 프로젝트도 작성했습니다.</p>\n<p>자기소개서와 포트폴리오를 작성하면서 느낀 점이 프로젝트 경험이 많이 부족하다는 점을 절실히 깨닫게 되었습니다.</p>\n<blockquote>\n<p><strong>알고리즘+CS+프로젝트</strong> 이 삼박자가 완벽해야 취준에 성공할 수 있어보입니다.</p>\n</blockquote>\n<p>자기소개서를 제출하고는 급하게 HR인터뷰를 준비했습니다. 경험이 전무하다보니 어디서부터 접근해야할지 몰라 많이 헤맸지만, <strong>교내 홍보대사 활동을 통해서 다양한 전공의 사람들과 많이 만날수 있게 되었고, 대부분이 취업준비를 하거나 이미 취업을 한 상태여서 주변에서 정말 정말 많은 도움을 받게 되었습니다.</strong></p>\n<blockquote>\n<p>학교생활을 하면서 다양한 전공의 사람들과 <strong>교류하며 인맥을 넓히는 것은 확실하게 도움이 됩니다.</strong></p>\n</blockquote>\n<p>또 카카오페이라는 테크핀 기업에 대한 분석과 <strong>결제&#x26;송금 도메인에 대한 지식</strong>을 공부하게 되었습니다. 여러 유튜브를 참고하면서 인성면접 빈출문제에 대한 답변과 개발회사에 국한되는 가치관 질문을 거의 다 준비했습니다.</p>\n<h3 id=\"인터뷰를-마치고\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%B7%B0%EB%A5%BC-%EB%A7%88%EC%B9%98%EA%B3%A0\" aria-label=\"인터뷰를 마치고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터뷰를 마치고</h3>\n<p>HR인터뷰는 10월 말경에 <strong>화상으로 진행되었습니다.</strong>\n덜덜 떨면서 참여했는데, 면접관분이 긴장을 풀어주시려고 많이 노력해주셨고 <strong>면접관의 태도나 질문에서 따뜻함</strong>을 느낄 수 있어서 결과에 상관없이 카카오페이에 대한 이미지가 매우 좋게 각인되었습니다.\n인터뷰는 다행히도 일반적인 수준과 익숙한 질문들로 구성되었지만 면접관분이 <strong>가끔 정말 날카로운 질문으로 답변 내용을 확인하고는 하셨습니다.</strong></p>\n<p>1,2차 코딩테스트를 마치고는 둘다 탈락했다고 생각했지만, HR인터뷰를 마치고는 합격에 대한 아주 조금의 확신을 가지게 되었습니다.\n자세히는 말씀드리기 어렵지만, 복수의 파트에서 좋은 평가를 받게 되어 조금의 희망이 생겼습니다.</p>\n<p>1,2차 코딩테스트를 응시할때는 정말 <em><strong>모의고사</strong> 느낌으로 보자, 경험만 쌓자</em> 였지만,\nHR인터뷰를 마치고부터는 정말 <strong>진심모드로 최선을 다해서 준비해야겠다</strong>는 생각을 하게 되었습니다.</p>\n<p>면접을 마치고 일주일쯤 뒤에 메일 제목부터 강한 <strong>스포일러</strong>를 당했습니다.\n<strong>[카카오페이] HR 인터뷰 전형 합격을 축하드립니다!</strong> 라는 메일을 받게 되었습니다.\n이제 그렇게 열망하던 <strong>카카오 입사까지 1단계만 남았다는 것이 실감나게 되었습니다.</strong>\n<img src=\"https://images.velog.io/images/hsw0194/post/da4aa7bf-0b5f-4373-91a9-7c73034893f3/image.png\" alt=\"\"></p>\n<h2 id=\"기술-인터뷰\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%88%A0-%EC%9D%B8%ED%84%B0%EB%B7%B0\" aria-label=\"기술 인터뷰 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기술 인터뷰</h2>\n<h3 id=\"기술인터뷰-준비하기\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%88%A0%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0\" aria-label=\"기술인터뷰 준비하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기술인터뷰 준비하기</h3>\n<p>기술 인터뷰, 2차 인터뷰, 최종 면접 다 맞는 말이지만 <strong>기술 인터뷰</strong>라고 하겠습니다.</p>\n<p>얼렁뚱땅 시작한 공채 지원도 이제 마지막 단계, 그리고 가장 어려운 단계만 남기고 있었습니다.\n당연하게도 기술면접 경험이 없었기에 주변의 개발자들에게 조언을 많이 구했고 캐치카페와 같은 사이트도 참조하면서 기술면접을 준비했습니다.</p>\n<p>일반적으로 기술면접은 <strong>포트폴리오에 명시한 프로젝트+CS 기본기</strong>로 진행됩니다. 저는 포트폴리오가 처참할정도로 빈약하기에 CS 기본기에 올인했습니다.</p>\n<p>CS 기본기는 github 저장소에 정말 많은 자료들이 있습니다. 예를 들자면</p>\n<ol>\n<li><a href=\"https://github.com/JaeYeopHan/Interview_Question_for_Beginner\">한재엽님의 CS 질문 저장소</a> : 대체적으로 많이 참고되는 저장소입니다.</li>\n<li><a href=\"https://github.com/WooVictory/Ready-For-Tech-Interview\">Woovicotry님의 CS 질문 저장소</a> : 1번과 비교해서 상대적으로 덜 알려져 있지만 퀄리티는 뒤지지 않습니다.</li>\n</ol>\n<p>이런 저장소들을 참고해서 공부했습니다.</p>\n<p>단, <strong>반드시 명심해야할 것이 인터넷의 자료는 완벽하지 않고 실제로 명백하게 틀린 부분도 꽤 많아서</strong> 저는 저장소에서는 질문을 참고했고 실제 답변은 <strong>영문 공식문서나 원서를 주로 참고</strong>했습니다.</p>\n<p>또 기술 면접은 <strong>DFS</strong>로 준비해야 한다는 말을 많이 들었습니다. 그래서 단순히 안다 or 모른다가 아니라 아래와 같은 기준으로 깊게 준비했습니다.</p>\n<ul>\n<li><strong>왜 이 기술이 사용되었는지</strong></li>\n<li><strong>내부 구조는 어떻게 되어있는지</strong></li>\n<li><strong>왜 A가 아닌 B를 선택해야 하는지</strong></li>\n<li><strong>실제 활용은 어떻게 되는지</strong></li>\n</ul>\n<p>제가 가장 좋아하는 자료구조인 <strong>HashTable</strong>을 예로 들어서 설명드리겠습니다.</p>\n<ul>\n<li><strong>왜 이 기술이 사용되었는지</strong>일반적으로 $$O(1)$$ 시간복잡도로 조회,삽입,수정이 가능하다.</li>\n<li><strong>내부 구조는 어떻게 되어있는지</strong> : hashtable은 충돌을 잘 관리해야하는데, 일반적으로 개방주소법/분리연결법이 사용된다.</li>\n<li><strong>왜 A가 아닌 B를 선택해야 하는지</strong> : 개방주소법은 구현이 간단하고, 캐시에서의 이점이 있지만 로드팩터에 민감하고 삭제가 어렵지만 분리연결법은 로드팩터에 영향을 조금 덜 받고 hashtable의 확장이 더디게 일어나지만 추가적인 오버헤드가 있다.</li>\n<li><strong>실제 활용은 어떻게 되는지</strong> : Python 3에서는 개방주소법,Java에서는 분리연결법을 사용한다.</li>\n</ul>\n<h3 id=\"부족함\" style=\"position:relative;\"><a href=\"#%EB%B6%80%EC%A1%B1%ED%95%A8\" aria-label=\"부족함 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>부족함</h3>\n<p>사실 위는 꽤 자세하게 준비한 것 같지만 <strong>저는 절대적으로 부족하다고 생각합니다.</strong>\n예를 들어 개방주소법은 왜 캐시효율이 좋을까요? 또 개방주소법에서도 여러가지 기법이 있고, 그에 따른 추가적인 트레이드오프가 있습니다. 분리연결법에서도 버킷에 연결리스트를 구성하는 방법과 트리로 구성하는 방법등이 있습니다.</p>\n<p>그러면 왜 트리를 사용할까요? 또 <strong>Java는 왜 분리연결법</strong>을 사용할까요? Java 8 부터 사용하는 분리연결법은 트리와 연결리스트를 동시에 사용하는데, 이때 <strong>균형이진트리인 RB 트리를 사용</strong>합니다.\nAVL이나 Splay도 있는데 왜 RB 트리일까요?\n이렇게 준비할때도 끊임없이 하나씩 의문을 제기하면서 deep 하게 준비했습니다.</p>\n<blockquote>\n<p>이처럼 노션을 활용해서 대략 50개 정도의 질문들 하나하나를 깊게 준비했습니다.<img src=\"https://images.velog.io/images/hsw0194/post/01d2caeb-0101-439e-88f6-b588596d4eb0/image.png\" alt=\"\"></p>\n</blockquote>\n<p>포트폴리오는 제가 했던 프로젝트의 설계와 DB 모델링을 다시 점검하고, 특정 기술을 사용한 이유에 대해서 고민하며 준비했지만 매우 빈약했습니다 ㅠㅠ</p>\n<h3 id=\"기술-인터뷰-1\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%88%A0-%EC%9D%B8%ED%84%B0%EB%B7%B0-1\" aria-label=\"기술 인터뷰 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기술 인터뷰</h3>\n<p>기술 인터뷰 역시 화상으로 진행되었으며 1:N 방식으로 1시간 가량 진행되었습니다.\n단순히 <em>이거 알아요?</em> 보다는 <em>이 기술을 사용한 이유가 뭐에요?</em> 부터 시작하는 꼬리물기 형태의 질문으로 인터뷰 전체가 흘러갔습니다. 또 포트폴리오 질문은 단순히 <strong>포트폴리오 질문이 아니라 CS로 자연스럽게 이어지는 질문이었습니다.</strong></p>\n<p>다만 CS 질문이 다른 계열사처럼 폭포수처럼 쏟아지지는 않았고 <strong>핵심적인 부분만 질문하셨습니다</strong>. 또 흥미로운게 제가 제출한 블로그의 글들을 보시고 그와 관련된 질문들을 하셨는데, 이것도 굉장히 깊숙히 질문하셨습니다.\n인터넷에 정말 많은 기술글들처럼 <em>단순히 글을 실어 나른것인지</em> 가 아니라 <strong><em>내부구조부터 깊게 고민해보았는지</em></strong> 에 대한 질문들이셨습니다.</p>\n<p>면접이 끝나고 사실 반반의 심정이였습니다. 아쉽게도 제가 준비한 모든것을 보여드리진 못했지만, 급급하게 준비한거치고는 방어를 적당히 한것 같다라는 느낌이였습니다.</p>\n<p>꽤 긴 기다림의 시간끝에 <strong>[카카오페이] 안녕하세요. 카카오페이입니다.</strong> 라는 제목의 메일을 받게 되었습니다.\n<img src=\"https://images.velog.io/images/hsw0194/post/6858a3c6-29fa-4ac9-bedf-1c9363907297/image.png\" alt=\"\">\n아쉽게도 결과는 <strong>불합격</strong>이었습니다. 어찌보면 <strong>당연한 결과라고 생각했습니다.</strong> 준비를 하면서 알게된 점이 입사하시는 분들의 공통점은 <strong>꾸준함과 탁월함</strong>임을 알게되었는데, 저는 두 부분 모두 빈약했던것 같습니다.</p>\n<h2 id=\"과정을-끝내고\" style=\"position:relative;\"><a href=\"#%EA%B3%BC%EC%A0%95%EC%9D%84-%EB%81%9D%EB%82%B4%EA%B3%A0\" aria-label=\"과정을 끝내고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>과정을 끝내고</h2>\n<p><strong>얼렁뚱땅 시작된 공채지원이였지만, 최종면접까지 가게 되었습니다.</strong> 저는 최종탈락이라는 결과에 주목하기보다는 그 과정까지 가면서 준비하면서 제가 <strong>부족한 점이 무엇인지</strong> 확실히 깨닫게 되었습니다.\n또 여러 과정, 특히 인터뷰를 하면서 카카오라는 기업이 정말 젠틀하고, 지원자 중심에서 생각해주는 기업이라는 점을 알게 되어 카카오에 입사하고 싶은 열망이 더 커지게 되었습니다.</p>\n<blockquote>\n<p>내년에도 다시 1,2차 코테부터 할 생각하니까 아찔하긴 합니다.</p>\n</blockquote>\n<p>3학년을 갓 마치고, 조금의 특수성은 있지만 군 복무를 마친 직후에 해본 첫 시도가 <strong>가장 챌린징스럽고 배운점이 많아 굉장히 뿌듯했습니다.</strong> 아마 이제는 복학을 준비하면서, 제가 <strong>부족했던 부분을 돌아보면서 그 부분을 개선하는 방식</strong>으로 진행할것 같습니다.</p>\n<p>굉장히 긴 글이여서 쓰는 저 만큼이나 읽으시는 분들이 부담스러울텐데 투머치토커의 기질을 숨기기 쉽지않네요. 이 글을 읽으시는 모든 분들이 모두 원하는 회사에 합류하기를 기원합니다🙏</p>\n<blockquote>\n<p>진짜 소집해제 한날부터 면접날까지 제대로 쉰 날이 없엇기에 이젠 좀 편하게 쉬면서 공부하려구요..<img src=\"https://images.velog.io/images/hsw0194/post/c1941b7e-bb97-454d-b747-08070f4e0f2c/image.png\" alt=\"\"></p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%A1%B0%EA%B8%88-%EB%8A%A6%EC%9D%80-%EC%8B%9C%EC%9E%91\">조금 늦은 시작</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%B5%EA%B4%80-%EB%93%A4%EC%9D%B4%EA%B8%B0%EC%99%80-%EC%8B%A4%ED%8C%A8\">습관 들이기와 실패</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A4%EC%8B%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\">다시 시작하기</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%9C%AC%EA%B8%88%EC%97%86%EB%8A%94-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EA%B3%B5%EC%B1%84\">뜬금없는 블라인드 공채</a></p>\n</li>\n<li>\n<p><a href=\"#1%EC%B0%A8-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8\">1차 코딩테스트</a></p>\n</li>\n<li>\n<p><a href=\"#2%EC%B0%A8-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8\">2차 코딩테스트</a></p>\n<ul>\n<li><a href=\"#cs-%EB%AC%B8%EC%A0%9C\">CS 문제</a></li>\n<li><a href=\"#%EC%84%A4%EA%B3%84%EC%99%80-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%AC%B8%EC%A0%9C\">설계와 최적화 문제</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#hr-%EC%9D%B8%ED%84%B0%EB%B7%B0\">HR 인터뷰</a></p>\n<ul>\n<li><a href=\"#%EC%9E%90%EA%B8%B0%EC%86%8C%EA%B0%9C%EC%84%9C%EC%99%80-hr-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0\">자기소개서와 HR 인터뷰 준비하기</a></li>\n<li><a href=\"#%EC%9D%B8%ED%84%B0%EB%B7%B0%EB%A5%BC-%EB%A7%88%EC%B9%98%EA%B3%A0\">인터뷰를 마치고</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B8%B0%EC%88%A0-%EC%9D%B8%ED%84%B0%EB%B7%B0\">기술 인터뷰</a></p>\n<ul>\n<li><a href=\"#%EA%B8%B0%EC%88%A0%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0\">기술인터뷰 준비하기</a></li>\n<li><a href=\"#%EB%B6%80%EC%A1%B1%ED%95%A8\">부족함</a></li>\n<li><a href=\"#%EA%B8%B0%EC%88%A0-%EC%9D%B8%ED%84%B0%EB%B7%B0-1\">기술 인터뷰</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B3%BC%EC%A0%95%EC%9D%84-%EB%81%9D%EB%82%B4%EA%B3%A0\">과정을 끝내고</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 16, 2021","title":"3학년의 2022 카카오 블라인드 공채 도전기","categories":"회고","author":"weasel","emoji":"📓"},"fields":{"slug":"/junior-student-challege-to-kakao-2022/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/how-spring-handler-mapping-works-2/","nextSlug":"/java-gc/","prevSlug":"/junior-student-challege-to-kakao-2022/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}