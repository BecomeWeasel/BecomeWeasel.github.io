{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/starategy-design-pattern-with-in-spring-boot-application/",
    "result": {"data":{"cur":{"id":"38eb533d-218e-57a9-bff7-fb7a95946fca","html":"<blockquote>\n<p>본 글은 <a href=\"https://medium.com/@ravthiru/strategy-design-pattern-with-in-spring-boot-application-2ff5a7486cd8\">Strategy Design Pattern with in Spring Boot application.</a>을 번역한 글입니다.</p>\n</blockquote>\n<blockquote>\n<p>잘 쓰여진 글을 정리 하는 겸 한글로 공유하고 싶어서 번역했습니다.</p>\n</blockquote>\n<p>전략 디자인 패턴은 실행 중에 알고리즘을 선택하게 해주는 행동 디자인 패턴이다.</p>\n<p>전략 디자인 패턴의 의도는 다음과 같다 :\n“알고리즘 집합을 선언하고, 각각을 캡슐화하며 그것들을 교체가 가능하게 만든다. 전략 패턴은 알고리즘을 사용하는 유저와는 독립적으로 알고리즘을 다양하게끔 한다.”</p>\n<h2 id=\"uml-class와-sequence-diagram\" style=\"position:relative;\"><a href=\"#uml-class%EC%99%80-sequence-diagram\" aria-label=\"uml class와 sequence diagram permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UML Class와 sequence diagram</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Strategy_pattern\"><img src=\"https://images.velog.io/images/hsw0194/post/354b2fad-7109-48e0-b5ee-8c00099a6f4b/image.png\" alt=\"전략 패턴의 다이어그램\"></a>\n전략 디자인 패턴을 설명하고 다양한 언어로 그것을 구현하는 많은 글들이 시중에 있다.\n이 글의 목적은 스프링 부트 어플리케이션에서 전략 패턴을 어떻게 구현하는지 알려주는 것이다.</p>\n<h2 id=\"스프링-부트\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8\" aria-label=\"스프링 부트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링 부트</h2>\n<p>스프링 부트는 Java microservice 개발의 실질적 표준이 되었다. 스프링 부트 어플리케이션에서 자주 쓰이는 디자인 패턴들을 어떻게 구현하는지 아는 것은 유용할 것이다.</p>\n<p>스프링은 의존성 주입을 위해 <code class=\"language-text\">@Autowired</code> annotation을 도입했다. 모든 스프링 구성요소는 주입이 가능하다. 구성요소에는 <code class=\"language-text\">components</code>, <code class=\"language-text\">configurations</code>, <code class=\"language-text\">services</code>, <code class=\"language-text\">bean</code>들이 있다.</p>\n<p>이 글에서 우리는 의존성 주입에 전략 디자인 패턴을 구현할 것이다.</p>\n<p>첫번째로, 우리는 전략 패턴에 필요한 알고리즘 집합을 구현하면서 시작한다.\n아래가 전략 패턴을 위한 인터페이스다. 그리고 <code class=\"language-text\">enum</code>으로 정의된 <code class=\"language-text\">StrategyName</code>을 이용해서 각각의 전략을 구분한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Strategy</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token class-name\">StrategyName</span> <span class=\"token function\">getStrategyName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">StrategyName</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">StrategyA</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token class-name\">StrategyB</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token class-name\">StrategyC</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>아래는 전략 패턴을 위한 세가지 알고리즘이다. 각각의 알고리즘은 <code class=\"language-text\">StrategyName</code>을 기준으로 구분된다. 전략들을 구분하는데 있어서 <code class=\"language-text\">String</code>보다는 <code class=\"language-text\">enum</code>을 사용하는 것이 더 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StrategyA</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Strategy</span><span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// 알고리즘 A 구현하기</span>\n\t<span class=\"token punctuation\">}</span>\n    \n\t<span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">StrategyName</span> <span class=\"token function\">getStrategyName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token class-name\">StrategyName<span class=\"token punctuation\">.</span>StrategyA</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StrategyB</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Strategy</span><span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// 알고리즘 B 구현하기</span>\n\t<span class=\"token punctuation\">}</span>\n    \n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">StrategyName</span> <span class=\"token function\">getStrategyName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token class-name\">StrategyName<span class=\"token punctuation\">.</span>StrategyB</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StrategyC</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Strategy</span><span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// 알고리즘 C 구현하기</span>\n\t<span class=\"token punctuation\">}</span>\n    \n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">StrategyName</span> <span class=\"token function\">getStrategyName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token class-name\">StrategyName<span class=\"token punctuation\">.</span>StrategyC</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 우리는 <code class=\"language-text\">StrategyFactory</code>를 다른 스프링 bean으로 만들고, 모든 전략을 factory에 주입한다. 여기서 <code class=\"language-text\">StrategyFactory</code>를 구성할 때 전략들을 Map을 이용해서 저장하는데, 이건 전략들을 <code class=\"language-text\">lookup</code>하는데 $$O(1)$$이 걸리게끔 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StrategyFactory</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">StrategyName</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Strategy</span><span class=\"token punctuation\">></span></span> strategies<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token annotation punctuation\">@Autowired</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">StrategyFactory</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Strategy</span><span class=\"token punctuation\">></span></span> strategySet<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token function\">createStrategy</span><span class=\"token punctuation\">(</span>strategySet<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Strategy</span> <span class=\"token function\">findStrategy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StrategyName</span> strategyName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">return</span> strategies<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>strategyName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">createStrategy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Strategy</span><span class=\"token punctuation\">></span></span> strategySet<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      strategies <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">StrategyName</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Strategy</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      strategySet<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span> \n   strategy <span class=\"token operator\">-></span>strategies<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>strategy<span class=\"token punctuation\">.</span><span class=\"token function\">getStrategyName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> strategy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 <code class=\"language-text\">StrategyFactory</code>를 <code class=\"language-text\">@Autowired</code>를 이용해서 주입받을 수 있게 되었다. 아래가 <code class=\"language-text\">StrategyFactory</code>를 사용한 예제 코드다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">StrategyFactory</span> strategyFactory<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">findSome</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 이름을 전달해서 전략을 가져올 수 있다.</span>\n    <span class=\"token class-name\">Strategy</span> strategy <span class=\"token operator\">=</span> strategyFactory<span class=\"token punctuation\">.</span><span class=\"token function\">findStrategy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StrategyName<span class=\"token punctuation\">.</span>StrategyA</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 이제 전략에 정의된 메소드를 호출할 수 있다.</span>\n    strategy<span class=\"token punctuation\">.</span><span class=\"token function\">doStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>지금까지 스프링 부트 어플리케이션에서 의존성 주입을 전략 패턴을 이용해서 하는 방법을 살펴보았다.</p>\n<p>더 많은 정보는 <a href=\"http://w3sdesign.com/?gr=b09&#x26;ugr=proble\">The Strategy design pattern</a>에서..</p>\n<blockquote>\n<p>첫 번역글인데 영문 어체를 한국어로 어색하지 않게 전달하는게 쉽지 않네요.</p>\n</blockquote>\n<blockquote>\n<p>전략 패턴을 사용하면 실행 중에 알고리즘을 교체할 수 있는데 원글에서 그런 부분 설명이 빠진점이 아쉽습니다.</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#uml-class%EC%99%80-sequence-diagram\">UML Class와 sequence diagram</a></li>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8\">스프링 부트</a></li>\n<li><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></li>\n</ul>\n</div>","excerpt":"본 글은 Strategy Design Pattern with in Spring Boot application.을 번역한 글입니다. 잘 쓰여진 글을 정리 하는 겸 한글로 공유하고 싶어서 번역했습니다. 전략 디자인 패턴은 실행 중에 알고리즘을 선택하게 해주는 행동 디자인 패턴이다. 전략 디자인 패턴의 의도는 다음과 같다 :\n“알고리즘 집합을 선언하고, 각각을 캡슐화하며 그것들을 교체가 가능하게 만든다. 전략 패턴은 알고리즘을 사용하는 유저와는 독립적으로 알고리즘을 다양하게끔 한다.” UML Class와 sequence diagram 전략 패턴의 다이어그램\n전략 디자인 패턴을 설명하고 다양한 언어로 그것을 구현하는 많은 글들이 시중에 있다.\n이 글의 목적은 스프링 부트 어플리케이션에서 전략 패턴을 어떻게 구현하는지 알려주는 것이다. 스프링 부트 스프링 부트는 Java microservice 개발의 실질적 표준이 되었다. 스프링 부트 어플리케이션에서 자주 쓰이는 디자인 패턴들을 어떻게 구…","frontmatter":{"date":"January 30, 2021","title":"스프링 부트 어플리케이션의 전략 패턴(Strategy Design Pattern with in Spring Boot application)","categories":"Spring","author":"weasel","emoji":"📓"},"fields":{"slug":"/starategy-design-pattern-with-in-spring-boot-application/"}},"next":null,"prev":{"id":"fab54913-676d-5548-a4f9-d4855a8db7cc","html":"<h3 id=\"문제-제목\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%A0%9C%EB%AA%A9\" aria-label=\"문제 제목 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 제목</h3>\n<p><a href=\"https://www.acmicpc.net/problem/12904\">12904번 A와 B</a></p>\n<h3 id=\"문제-설명\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\" aria-label=\"문제 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 설명</h3>\n<p>수빈이는 A와 B로만 이루어진 영어 단어가 존재한다는 사실에 놀랐다. 대표적인 예로 AB (Abdominal의 약자), BAA (양의 울음 소리), AA (용암의 종류), ABBA (스웨덴 팝 그룹)이 있다.</p>\n<p>이런 사실에 놀란 수빈이는 간단한 게임을 만들기로 했다. 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다.</p>\n<ol>\n<li>문자열의 뒤에 A를 추가한다.</li>\n<li>문자열을 뒤집고 뒤에 B를 추가한다.</li>\n</ol>\n<p>주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오.</p>\n<h3 id=\"입력\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EB%A0%A5\" aria-label=\"입력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입력</h3>\n<p>첫째 줄에 S가 둘째 줄에 T가 주어진다. (1 ≤ S의 길이 ≤ 999, 2 ≤ T의 길이 ≤ 1000, S의 길이 &#x3C; T의 길이)</p>\n<h3 id=\"출력\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EB%A0%A5\" aria-label=\"출력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출력</h3>\n<p>S를 T로 바꿀 수 있으면 1을 없으면 0을 출력한다.</p>\n<h3 id=\"예제-입출력\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5\" aria-label=\"예제 입출력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예제 입출력</h3>\n<p><strong>입력</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">B\nABBA\n\nAB\nABB</code></pre></div>\n<p><strong>출력</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1\n0</code></pre></div>\n<h3 id=\"풀이\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4\" aria-label=\"풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이</h3>\n<p>가장 먼저 생각난 풀이는 <strong>백트래킹</strong>을 사용해서 <strong>S</strong>가 <strong>T</strong>를 만드는 방법이였다. 매 노드에 대해서 <strong>뒤에 A를 뒤에 추가할지</strong>,<strong>뒤집어서 B를 뒤에 추가할지</strong>의 선택지 뿐이니 매우 간단할 것이라고 생각했지만, 첫 제출은 메모리 초과로 통과하지 못했다.</p>\n<p>그 이유는 입력조건을 잘 보면 알 수 있다. <strong>T</strong>의 최대 길이가 1000이니 매 노드에서 선택지가 두가지 뿐이라고 해도 1000번째 단계의 탐색에서는 선택지가 무려 <strong>2^1000</strong>개에 달한다.\n일반화했을때 <strong>T</strong>의 길이를 <strong>N</strong>이라 할때, 길이가 K(1&#x3C;=K&#x3C;=N)일때의 탐색일때 선택지는 <strong>2^K</strong>개에 달하니 당연히 메모리 초과가 발생할수 밖에 없었다.</p>\n<p>문제의 분류가 그리디 알고리즘이어서 그 다음 떠올린 풀이는 주어진 <strong>S</strong>에 특정 조건에 따라서 <strong>A</strong> 혹은 <strong>B</strong>를 덧붙일지 고려하는것이였는데,(<a href=\"https://www.acmicpc.net/problem/2138\">백준 2138번 전구와 스위치</a>와 비슷한 풀이를 떠올렸다.) 이것도 문제가 생겼다.</p>\n<p><strong>A</strong>는 단순히 뒤에 덧붙이는 것이지만, <strong>B</strong>는 문자열을 뒤집은후 덧붙이는것이기 때문에 경우의 수가 매우 많았다.</p>\n<p>문제를 최대한 단순하게 생각해서 바라보았다.</p>\n<blockquote>\n<p>S에 여러 가지 적당한 연산을 해서 T가 되었다는 것은 <strong>T’에 한가지 연산을 해서 T</strong>가 되었다는 것과, <strong>T”에 한가지 연산을 해서 T’</strong> 이 되는 것이 같다는 것을 생각하게 되었다.</p>\n</blockquote>\n<p>바꿔서 말하면 주어진 목표 문자인 <strong>T</strong>에 각 <strong>연산의 역원</strong>을 계속 수행하다 보면 <strong>S</strong>가 되는지 안 되는지 쉽게 알 수 있다는 것이다.</p>\n<p>예를 들어서 위에서 언급한 <strong>연산의 역원</strong>은 아래와 같다.</p>\n<blockquote>\n<p>문자열의 뒤에 A를 추가한다. -> 끝 문자열 하나를 삭제한다 (A 삭제)</p>\n</blockquote>\n<p>문자열을 뒤집고 뒤에 B를 추가한다. -> 끝 문자열 하나를 삭제하고 뒤집는다.</p>\n<p>그럼 어떤 <strong>연산의 역원</strong>을 수행할지만 판단하면 되는데 이건 판단하기 매우 쉽다. 단순하게 <strong>A</strong>로 끝나면 첫 번째 역원을, <strong>B</strong>로 끝나면 두 번째 역원을 수행하면 되는 것이다.</p>\n<p>이렇게 <strong>연산의 역원</strong>을 계속 수행해서 <strong>T</strong>가 <strong>S</strong>와 길이가 같게 되었을때, <strong>S</strong>와 <strong>T</strong>의 일치여부만 판단해주면 되는것이다.</p>\n<h3 id=\"풀이코드\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4%EC%BD%94%EB%93%9C\" aria-label=\"풀이코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> sys <span class=\"token keyword\">import</span> stdin\n\nS <span class=\"token operator\">=</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span>stdin<span class=\"token punctuation\">.</span>readline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rstrip<span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nT <span class=\"token operator\">=</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span>stdin<span class=\"token punctuation\">.</span>readline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rstrip<span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">sol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">global</span> S<span class=\"token punctuation\">,</span> T\n  <span class=\"token comment\"># 생각을 바꿔서 T에서 한단계씩 이전으로 되돌아가는것임</span>\n  <span class=\"token comment\"># T의 마지막이 A라면 이전은 무조건 T[:len(T)-1]이고</span>\n  <span class=\"token comment\"># T의 마지막이 B라면 이전은 T.pop() 후에 T[::-1]임</span>\n  <span class=\"token comment\"># 이렇게 이전으로 계속 되돌아갔을때 S와 T가 일치하는지만 보면됨</span>\n\n  <span class=\"token comment\"># ctrl-z를 해서 S로 되돌아갈수 잇느냐를 판단</span>\n  <span class=\"token keyword\">while</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># T의 마지막이 A라면 </span>\n    <span class=\"token keyword\">if</span> T<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">:</span>\n      T<span class=\"token operator\">=</span>T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># T의 마지막이 B라면</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n      T<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      T <span class=\"token operator\">=</span> T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\n  <span class=\"token keyword\">if</span> S <span class=\"token operator\">==</span> T<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>sol<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/b7570854-25d0-4a6b-8f28-65b97cad59da/image.png\" alt=\"\"></p>\n<blockquote>\n<p>구현 난이도는 브론즈 수준이였지만 구현 아이디어가 골드 난이도였다.</p>\n</blockquote>\n<blockquote>\n<p>이 문제를 통해서 느낀 점은 도착점에서 출발점으로 돌아가는 것도 풀이의 방법이다 라는것이다.</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%A0%9C%EB%AA%A9\">문제 제목</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\">문제 설명</a></li>\n<li><a href=\"#%EC%9E%85%EB%A0%A5\">입력</a></li>\n<li><a href=\"#%EC%B6%9C%EB%A0%A5\">출력</a></li>\n<li><a href=\"#%EC%98%88%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5\">예제 입출력</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4\">풀이</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4%EC%BD%94%EB%93%9C\">풀이코드</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 30, 2021","title":"백준 12904 - A와 B","categories":"PS","author":"weasel","emoji":"📓"},"fields":{"slug":"/12904-A-and-B/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/starategy-design-pattern-with-in-spring-boot-application/","nextSlug":"","prevSlug":"/12904-A-and-B/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}