{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/process-and-thread/",
    "result": {"data":{"cur":{"id":"47d4a3c9-8311-5002-8347-5782768ff95b","html":"<p>프로세스란, <strong>실행중인 프로그램</strong>을 의미한다.\r\n프로그램을 실행하기 위해서는 <strong>주소공간,파일,메모리</strong> 등이 필요한데 <strong>운영체제로부터 이런 것을 할당받은 프로그램을 프로세스</strong>라 한다.</p>\n<blockquote>\n<p>프로그램은 어떤 작업을 수행하기 위한 파일로써 <strong>정적인 상태</strong>이고, 프로세스는 그 작업을 수행하는 <strong>동적인 상태</strong>다.</p>\n</blockquote>\n<h2 id=\"프로세스의-메모리-구조\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\"프로세스의 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스의 메모리 구조</h2>\n<p>프로세스는 아래 그림과 같은 메모리 구조를 띄고 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.1111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC+klEQVQ4y2WUCW/bOhCE/f9/2bsKJE7i+lAcS7Fu3ockH/H3ILppU1TAQgQ4HM7u7HIBcKws26xFSI9QnqazaOnR/264XK7cuH/DeGa1bmhah3MjQoZ0Rj2+co5TwiyMHdkfRAI+r2qWzyX/LY/k2wb313da4blePzidLnS952FZsnyueHyq+Odbkc7pv9fYzqHdxGIGnc+XxD6dJqyzTNOIj4F4mShryfV6I8YTWg8Jd7t9YJxL+HEaGU4j1gXazrPoRWAczwloreFxuWS92fDw9MTzasVb0fLxcWMYTigdE+58mthlGY9PT2yzjG8PD+RFmTJYdH1ICs8fN3oXaZWh7HqGIaaoG5NSvhPeFao40lvPse3Q1jKOA9YGOhFYCBFQYaR0Ay+dI5OeTAXsdEVPV3oZuCTCM0JFzHTmpbWsOsdGeMRwSrg4XZi5FlJGGhNxweOswTmH8x5tLJUJPwnH4UyvBnoff+As1nm89zTKYsKEkPGTMCCMpqobttkrq/UGrTVHoZOquXXmlKUeqbWlaVve8pzH52e0Vhx7gbQRqRJhoHMDfogYY1BaI5XCWEvvB2bTfimMqX4xBqxzCRu8R/qIjadfCmvtU3HLquJQFDRzsY2hVDaBPhUKPdAaR1mW7N/eEt7OuF6i3ID8mrI0muL9nc1uR7bf0/U9lXZ/EHazu2XJJstYb7e0XUsl1FfCQGsjNviUsv1hirU2leKry7MpMgxpb8aEGPHeIazHz13w6XKtZ4Um3fx9u2W1uZtSSvubKeKHKUnhbpeav6qqlLIff7ZNoLMDyhqklEnhbMq87lz8ovCEmNvGzQ+CTKOntEEpRacd7qvCOWWpFUWRs91tOeSHtG5t+L1tzH1Civc8jV5e5LzuMxqpCJ+N3feBSnoOrWSdH1ntC9Z5yaaoyIWlbiyX652w6TyH3rA+lLzsC1Zv76wPR3aVQLnxPss+nKhbR9V56j7QiJj+KVqf3r7b7ZZU1q2hmqNz1P2Mdymqbr5Y48PE/1WXBQNFAZ7vAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/91a393f9cb795ceb248a279f8b935fc0/37523/process_memory_1.png\"\n        srcset=\"/static/91a393f9cb795ceb248a279f8b935fc0/e9ff0/process_memory_1.png 180w,\n/static/91a393f9cb795ceb248a279f8b935fc0/f21e7/process_memory_1.png 360w,\n/static/91a393f9cb795ceb248a279f8b935fc0/37523/process_memory_1.png 720w,\n/static/91a393f9cb795ceb248a279f8b935fc0/50383/process_memory_1.png 740w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>프로세스는 각자 본인이 사용하는 메모리 영역과 레지스터 값을 가진다.</p>\n<p>프로세스의 메모리 영역은 <strong>코드,데이터,힙,스택</strong> 영역으로 구성된다.</p>\n<ul>\n<li><strong>코드</strong> : 사용자가 작성한 프로그램 함수들의 코드가 기계어 명령 형태로 변경되어 저장되는 공간</li>\n<li><strong>데이터</strong> : <strong>전역 변수 또는 static 변수</strong> 등 프로그램이 사용하는 데이터를 저장하는 공간</li>\n<li><strong>스택</strong> : <strong>함수의 복귀주소와 지역변수,매개변수,반환값</strong>을 저장하는 공간. 재귀함수가 반복되거나 지역변수가 너무 많으면 stack overflow 발생. <strong>가변적이다</strong>.</li>\n<li><strong>힙</strong> : 프로세스 실행 중에 <strong>런타임에 할당</strong>되는 영역. 이곳에 메모리를 할당하는 것을 <strong>동적 할당</strong>이라고 한다. <strong>가변적이다</strong>.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 221px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 160%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAgCAYAAAASYli2AAAACXBIWXMAAAsTAAALEwEAmpwYAAADx0lEQVRIx41WaU8bSRDl/3/c/bRKAkS7EClRPiyKE7CJYTyHx+O5L18iQRw+1jZJZAQxYN6qam6Po92Rnrq7uuf1q+pWVW8JggBFUSBJEp6fn3F+fg5V02A5LkzbKcCwbBi2zW1mt3NwsDUajXB5eYmLiwvQ1+31oLR1WH4A0/VS0NgNu3CCEG7Ygen5hfkEW1j7+oMBWobJP1qez6B+SzdQq59AkGVuDceF7QfpGoLt+dgiN1erFYO+Xr8PVTdSQtrV63RxWK3h5fY2dnZ3sb2zg6bWLmyagAkTMCErtOCEHVhewCpsP+R+EgY7CGN7BCvXLxFyDFUVlkOHYMFMQUG3YLvxQeTstC5BSriKCe3BGQ6MDo7DL6j6ZylqwRmO3D72qiKqfjRXY3zhNhmXFAZXY9THd2h+W0G5eWTISTt7wNt2D/L8KbUV1swfywr9yxHq1ws0Z0vI058p1JtHHH+d4fd3FTTnj5Cn91By8wRler+JcIj6cIHm/KG4eP6AxvUtDtyvUGbRnDJbQpkuocxozZI3+F+ESqyWSLXvzxkZ2/OEy3IM2eUC4TJVIk+XBbIU0w0K00MpEf5MFcj/LNNNCsrJNvsFYaTwNiXMXIv6dDgllf9NmClUcnEUx3eonk3TDZL5iDDy5Bcu30KdPxQUqN+e+Nr89rYC9eaJfy7FcrbccMoXQxxf/eB7Jk7uUkiTe742b2QX4uQeEtsyiHFbIvQ6HRyJCkTDgtA2ILRNnLZNNHhsoiY10dBN7udxGrcll/uDPjTdgEsZxfPgeD7cIGCbbllso8zMc77P83YMZ2P66vfR1A1ORUkWpnz494cPePnqFXZfv8YfL15AM61iVqd86PqbFA7QtmwmoQTqhFHKp+SpmSYUTcOpJKelwAk60ToaB2EuhnHGDsIQn08FKC0NUlON0YKsqpDVFoOyNdmy+Qwlwk63C0GSoRkm1LbOtYRAY50qn+2wB1QmMujp2o0uU3yowlEcE9eIpHJ4iINKBZ8FIXY3ctWOWyfvclZTikUqqXrkzl/7+1yg3r1/z6dqbcDmU6a6vF536WqQ4rBTuAGlurweQ8/38alagyBJOGk0cNIQGfVGg12tE9iezaV9QdwcQyr0bqwkAV2JsD9A0OsV7OsoKUwKPQU6ccPtdPGxWsXe/hv8ubcPsalGzxF6omyK4fpTJDrlTCH1JbWFyqdDfDw6gm7ZJQ84vnmFw+GQVVKhbyhNvnNEnEDPvWXoCuXn8uDHEhHato3FYsG4ur7GeDLBaDwuYDgagV5r6/Y8/gXjNvCLZWC8owAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/d46dc5a982cd97a7828a89636b927e6e/cccdc/process_memory_2.png\"\n        srcset=\"/static/d46dc5a982cd97a7828a89636b927e6e/e9ff0/process_memory_2.png 180w,\n/static/d46dc5a982cd97a7828a89636b927e6e/cccdc/process_memory_2.png 221w\"\n        sizes=\"(max-width: 221px) 100vw, 221px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이처럼 프로세스는 <strong>각자의 메모리 영역</strong>을 가지기에 프로세스간의 메모리는 서로 침범 할 수 없다.</p>\n<h2 id=\"프로세스-제어-블록-process-control-block-pcb\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9D-process-control-block-pcb\" aria-label=\"프로세스 제어 블록 process control block pcb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 제어 블록 (Process Control Block, PCB)</h2>\n<p>PCB(Process Control Block)는 <strong>특정 프로세스에 대한 중요한 정보를 저장</strong>하고 있는 운영체제의 자료구조이다. 그렇기에 PCB는 일반적으로 보호된 메모리 영역,예를 들면 커널 스택등에 위치한다.</p>\n<p>OS는 프로세스를 관리하기 위해 <strong>프로세스를 생성함과 동시에 고유한 PCB를 생성한다.</strong></p>\n<p>프로세스는 CPU를 할당받아 작업하다가도 context-switching이 일어나면, 진행하던 작업을 저장하고 CPU를 반환해야하는데, 이때의 <strong>작업 진행상황이 PCB에 저장</strong>된다.\r\n그 후 다시 CPU를 할당받게 되면 PCB 안에 있던 정보들을 불러와서 작업이 멈추었던 시점에서부터 다시 시작한다.</p>\n<ul>\n<li>\n<p>프로세스 식별자 : PID</p>\n</li>\n<li>\n<p>프로세스 상태 : <code class=\"language-text\">new,ready,running,waiting,terminated</code></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3UlEQVQ4y+VU2W7aUBC9AgRm+f/PqCAhjR9wVSoWEWynNirGZbcRYRVgDJj1RDMSVprnPlTqSEfjO8u5c2dGFkII/GX864TJZBLRaBSRSASSJCGTySCVSiGdToN8BDqTJv/9TKBYslFuLBbjHCHLMuRnGfnHPAqFAprNJvr9PmzbxnA4xGg0Qq/XDb9J93o9jrEsC4qiIPsli6f8E3K5HIRhGHCGDvrdPjqdDmazGd7exphMJgiCAMvlksld18HlcgHJdDrFer3GeDyG3bJh/bJg/jRRq9YgKPFwOGCz2eB0OnFCu91GtVqFrutsJ6Lz+czVl8tl6K86/J3PsefTGZ7n4Xg8cjFiPp+z43a7sSZjwzRRKVXQMBrodjtsXywWKP4o4uHxAdlcFqqmhjl3IS5BBB+FqqEnaaqGltWC7/uh3f5tQ/mmcGu2222Yc71ew2KYkHq12+0Y+/2e4Y5cJtZ1DS/1F1QqZR4G9Zv89ES6jPSdkOIF9YgMnrfhfhGo9CA4cIDVtFCv1WEaJlRV5X7RxTSU1WoVDoqEcoWmaeE6OI4TwnVdHkLxe5HXQv4qo1QqYTAY/BFHZ67ccXiIIpFIQJISIP0ZtMTxeBzxRJwXl5aY8Dnuo138fz+Hd45V7ag5zclUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/37523/process_state.png\"\n        srcset=\"/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/e9ff0/process_state.png 180w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/f21e7/process_state.png 360w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/37523/process_state.png 720w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/302a4/process_state.png 1080w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/21b4d/process_state.png 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>프로그램 카운터,<strong>PC</strong> : 프로세스가 <strong>다음에 실행할 명령어 주소</strong></p>\n</li>\n<li>\n<p>CPU <strong>레지스터</strong></p>\n</li>\n<li>\n<p>CPU <strong>스케쥴링 정보</strong> : 우선순위, 스케쥴 큐에 대한 포인터 ← 이것을 바탕으로 MLFQ나 RR이 동작한다.</p>\n</li>\n<li>\n<p><strong>메모리</strong> 관리 정보 : <strong>페이지 테이블 또는 세그먼트 테이블에 대한 정보 포함</strong></p>\n</li>\n<li>\n<p>입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록</p>\n</li>\n<li>\n<p>어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호</p>\n</li>\n</ul>\n<p>이 PCB들은 <strong>커널 스택과 같은 보호된 메모리 영역 내에서 Linked List 형태로 관리된다.</strong> PCB List Head에 PCB들이 생성될때 붙는 방식으로 관리가 된다.</p>\n<h2 id=\"스레드thread\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9Cthread\" aria-label=\"스레드thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드(Thread)</h2>\n<p><strong>스레드는 프로세스가 할당받은 자원을 이용하는 실행 단위다.</strong></p>\n<p>한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.</p>\n<p>스레드는 스레드 ID,PC,레지스터 집합, 그리고 각자의 스택으로 구성된다(독립적인 메모리는 아니고, 스택 포인터로 표시한다).</p>\n<p>이를 통해 멀티 쓰레딩을 달성할 수 있는데 멀티쓰레딩은 하나의 프로세스를 여러개의 실행단위(스레드)로 나누어서 자원을 공유하며 자원의 생성과 관리의 중복을 줄여 수행능력을 높이는 것이다.</p>\n<ul>\n<li>공유\n<ul>\n<li>같은 프로세스에 속하는 스레드들은 <strong>힙,데이터,코드 영역을 공유한다.</strong> 추가적으로 open된 파일등도 공유한다.</li>\n</ul>\n</li>\n<li>공유하지 않는 것\n<ul>\n<li>각자의 스택과 레지스터(PC 포함)은 공유하지 않는다.</li>\n</ul>\n</li>\n</ul>\n<p>이렇게 하나의 프로세스 내에서 다수의 실행 단위인 스레드로 구분하여 공유할 자원은 공유하고, 독립적인것은 따로 두어 수행 능력을 향상시키는 것을 멀티스레딩이라 한다.</p>\n<h3 id=\"스레드에서의-메모리-구조\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\"스레드에서의 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드에서의 메모리 구조</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABoUlEQVQoz42SV4/CQAyE9///LR6QQqih9957JwHm9FlaxMOddJac4jI7Hq9bLpfa7/fCdrudZrOZttut+fF4NH+9Xspms6rVahoOh/YdRZG63a6q1ary+bwmk4kWi4Xc+XyWt1arpVQqpUqlovV6/Ynf73flcjlzwMIwVCaTURAEBphOpy03n8/lOAVkmuI4tvf1etV0OjVfrVa63W46HA6W5x9PksQAmIQ4xGDpBoOBTqeTMWGcdrut0WhkjhyA0wBr8s1mU8ViUf1+X41Gw2TodDrq9XrW4wqFgkqlkiUJoBen0VCv1y3HWMiB0YhmGIzK5bKez6ftAXKOJhbB2BRgl8vFADmA+Hg8NuYYcRhiSMJh7/fbJDFACtGEJTASIGyWJAcQ5w1D9IIhU9FDDSNDCD1tZLbGWOgAEy8wjejG9UA3PzIMAfQjw/DxeNiVM4Y8/Ob8yAASZyk4cW7Dv0bmPkEbRjAk+c3Qs/trKdTQ81kKJ4LunQT00RPW/p86GNEEKGD+qkCEerR0jLTZbEx8/waIBXzH+Sf+2zc1OIR+AJ9ndsk2MQsNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/d86cddb51ebd04f91e872a4c148a77f9/6af66/thread_memory.png\"\n        srcset=\"/static/d86cddb51ebd04f91e872a4c148a77f9/e9ff0/thread_memory.png 180w,\n/static/d86cddb51ebd04f91e872a4c148a77f9/f21e7/thread_memory.png 360w,\n/static/d86cddb51ebd04f91e872a4c148a77f9/6af66/thread_memory.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>스레드 역시 프로세스와 단짝인 개념인데, 짧게 말하면 <em><strong>프로세스가 할당받은 자원을 이용하는 실행의 단위</strong></em> 이다. 위의 그림처럼, 여러개의 스레드는 각자의 레지스터와 스택을 가지지만, 나머지 영역은 가지지 않는다. 대신에 <strong>코드,힙,데이터</strong> 영역을 공유해서 병렬적인 수행이 가능하다.</p>\n<ul>\n<li>\n<p><strong>TMI : 왜 스레드는 각자의 스택을 가지고 있을까?</strong></p>\n<p>스레드가 하나의 실행의 context라는 것을 생각하면 자명하다. 그 context내에서 아주 간단하게 여러개의 지역변수,파라미터,반환값,복귀주소등을 가지는데, 그 스레드들이 만약 서로의 스택을 공유하게 된다면, 그 context가 서로 섞이게 된다. 사실 각자의 스택을 가지기 때문에 스레드가 종종 Lightweight Process라고 불리는 이유다. <strong>그리고 각자의 스택을 가지고 있다고 얘기하지만 사실은 하나의 메모리공간을 stack pointer를 이용해서 분리하는 것이다.</strong></p>\n</li>\n<li>\n<p><strong>TMI2 : 그럼 스레드는 왜 각자의 PC와 register도 있을까?</strong></p>\n<p>위의 답과 비슷한 이유인데, PC(Program Counter)나 레지스터의 역할은 <strong>현재 명령어가 어디까지 수행되었는지,수행될때 쓰던 데이터는 무엇이었는지</strong> 알려주는 것이다. 스레드는 CPU를 할당받을때 프로세스처럼 스케쥴러에 의해 결정되는데, 그렇기에 명령어가 연속적으로 실행됨을 보장하지 못하기에 <strong>어디까지 실행되었는지 기록</strong>할 필요가 있는데 그래서 스레드가 각자의 PC를 가지는 것이다.</p>\n</li>\n</ul>\n<h3 id=\"스레드의-장점과-단점\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90\" aria-label=\"스레드의 장점과 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드의 장점과 단점</h3>\n<ul>\n<li><strong>장점</strong>\n<ul>\n<li><strong>반응성</strong>\n<ul>\n<li>특정 스레드가 I/O 작업을 처리중이거나(blocked) 긴 작업을 수행중이여도 다른 스레드는 본인의 일을 계속 할 수 있다.</li>\n</ul>\n</li>\n<li><strong>자원 공유</strong>\n<ul>\n<li>프로세스는 shared memory나 message passing과 같은 기법을 이용해서 자원을 공유할 수 있지만, 스레드끼리는 프로세스의 자원을 서로 공유한다.</li>\n</ul>\n</li>\n<li><strong>경제적</strong>\n<ul>\n<li>프로세스의 자원을 공유하기 때문에 새로운 메모리 주소공간을 할당받을 필요가 없어 생성에 자원이 적게 들어간다.</li>\n<li>스레드 간에 컨텍스트 스위칭을 할 때 캐시 메모리 안비워도 된다. 어차피 같은 메모리 주소공간을 사용하니까 오버헤드가 적다.</li>\n<li>근데 이것도 극복하려고 thread pool이라는 기술도 있다.</li>\n</ul>\n</li>\n<li>확장가능성</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li><strong>공유자원</strong>을 사용하기 때문에 <strong>동기화 문제</strong>를 고려해야 한다.\n<ul>\n<li>lock을 함으로써 공유자원에 대한 동기화를 해결할 수 있는데 이게 병목현상이 될 수 있다.</li>\n<li>그러므로 적절한 부분만 lock을 하는 것이 필요하다. → Critical Section Only</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"멀티-프로세싱-vs-멀티-스레드\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"멀티 프로세싱 vs 멀티 스레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>멀티 프로세싱 vs 멀티 스레드</strong></h1>\n<ul>\n<li>멀티 프로세싱\n<ul>\n<li>두 개 이상의 다수의 프로세스가 협력적으로 하나의 작업을 동시에 병렬적으로 처리하는 것</li>\n<li>프로세스간 메모리 공유는안되기 때문에, <strong>IPC</strong>를 이용해 소통</li>\n<li>하나의 프로세스에서 문제가 생겨도 다른 프로세스는 계속 진행할 수 있음.</li>\n<li><strong>컨텍스트 스위칭 비용이 높음</strong></li>\n</ul>\n</li>\n<li>멀티 스레딩\n<ul>\n<li>단일 프로세스 내에서 여러 쓰레드로 나누어 동시에 실행</li>\n<li><strong>컨텍스트 스위칭 비용이 거의 없음</strong></li>\n<li>스택을 제외한 <strong>데이터,코드,힙 영역을 공유</strong>하기 때문에 <strong>공유하는데 편리</strong>함</li>\n<li>임계영역의 문제가 있음</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">프로세스의 메모리 구조</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9D-process-control-block-pcb\">프로세스 제어 블록 (Process Control Block, PCB)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9Cthread\">스레드(Thread)</a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">스레드에서의 메모리 구조</a></li>\n<li><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90\">스레드의 장점과 단점</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"프로세스란, 실행중인 프로그램을 의미한다.\r\n프로그램을 실행하기 위해서는 주소공간,파일,메모리 등이 필요한데 운영체제로부터 이런 것을 할당받은 프로그램을 프로세스라 한다. 프로그램은 어떤 작업을 수행하기 위한 파일로써 정적인 상태이고, 프로세스는 그 작업을 수행하는 동적인 상태다. 프로세스의 메모리 구조 프로세스는 아래 그림과 같은 메모리 구조를 띄고 있다.  프로세스는 각자 본인이 사용하는 메모리 영역과 레지스터 값을 가진다. 프로세스의 메모리 영역은 코드,데이터,힙,스택 영역으로 구성된다. 코드 : 사용자가 작성한 프로그램 함수들의 코드가 기계어 명령 형태로 변경되어 저장되는 공간 데이터 : 전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터를 저장하는 공간 스택 : 함수의 복귀주소와 지역변수,매개변수,반환값을 저장하는 공간. 재귀함수가 반복되거나 지역변수가 너무 많으면 stack overflow 발생. 가변적이다. 힙 : 프로세스 실행 중에 런타임에 할당되는 영역…","frontmatter":{"date":"December 25, 2021","title":"프로세스와 쓰레드","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/process-and-thread/"}},"next":{"id":"4da436d2-89ae-5ba6-88ef-af8c03da2522","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEDBf/aAAwDAQACEAMQAAAB042MOwD/AP/EABcQAAMBAAAAAAAAAAAAAAAAAAECESD/2gAIAQEAAQUCawFrj//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABoQAAICAwAAAAAAAAAAAAAAAAERACECIIH/2gAIAQEABj8CoMy8V3X/xAAZEAEAAwEBAAAAAAAAAAAAAAABESFRACD/2gAIAQEAAT8hQbkExPNoDbef/9oADAMBAAIAAwAAABD/AO//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAWEQEBAQAAAAAAAAAAAAAAAAABERD/2gAIAQIBAT8QEkmf/8QAGxAAAgEFAAAAAAAAAAAAAAAAAREhACBBUbH/2gAIAQEAAT8QB6GGWRp4oKCyYcFb/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"kakaopay logo\"\n        title=\"kakaopay logo\"\n        src=\"/static/d1f66dccbc3f0f4a7eba3d6bb104b50e/80e3c/kakaopay_logo.jpg\"\n        srcset=\"/static/d1f66dccbc3f0f4a7eba3d6bb104b50e/4ec73/kakaopay_logo.jpg 180w,\n/static/d1f66dccbc3f0f4a7eba3d6bb104b50e/158ba/kakaopay_logo.jpg 360w,\n/static/d1f66dccbc3f0f4a7eba3d6bb104b50e/80e3c/kakaopay_logo.jpg 720w,\n/static/d1f66dccbc3f0f4a7eba3d6bb104b50e/6a068/kakaopay_logo.jpg 960w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>도전기? 후기? 어느단어를 써야할지 한참 고민하다가 도전기로 선택했습니다.\r\n<strong>도전기로 선택한 이유는 결과와 상관없이 공채의 모든 과정에서 배운점이 굉장히 많았거든요.</strong></p>\n<blockquote>\n<p>그런면에선 개발자 취준생인 저의 성장기도 맞는 것 같습니다.</p>\n</blockquote>\n<blockquote>\n<p>글이 <strong>굉장히,매우</strong> 호흡이 깁니다. 적당히 스크롤 내려가면서 스킵하면서 읽어주세요.. 공채 얘기만 궁금하시면 뜬금없는 블라인드 공채 목차쯤부터 보시면 됩니다.</p>\n</blockquote>\n<h2 id=\"조금-늦은-시작\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%EA%B8%88-%EB%8A%A6%EC%9D%80-%EC%8B%9C%EC%9E%91\" aria-label=\"조금 늦은 시작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>조금 늦은 시작</h2>\n<p>저는 서울 소재 H대학교에서 컴퓨터계열을 전공하다 3학년을 수료하고 20년도 초에 사회복무요원으로 입대하게 되었습니다.\r\n여러가지 사정들로 군 복무가 굉장히 늦어졌고, 3학년을 마칠때까지 아직 <strong>진로에 대해서 확실히 정하지 못했습니다.</strong> 분명 개발을 좋아하고 적당히 실력도 있었지만, 그만큼 컴퓨터공학에 대한 열정도 있어서 진학 후 연구도 하고 싶었습니다. 개발자와 진학 중 하나를 선택하기 위해서는 일단 군 문제 먼저 해결해야한다고 생각해 일단 복무를 시작했습니다.</p>\n<p>그러던 중, 5월쯤 취업한 친한 과 동기를 만나서 여러가지 얘기를 하던 중, 본인의 입사동기 중 한명은 <em><strong>매일 백준에서 알고리즘 1문제를 꾸준히 풀었다</strong></em> 라는 말을 듣게 되었습니다. 일반적인 사람이라면 흘려듣거나 or 조언을 받아들일텐데 저는 태생적으로 <strong>반골</strong>기질이 있어서인지 <strong>그게 그렇게 어렵고 대단한 일인가?</strong> 라는 생각이 먼저 들게 되었습니다. 그 노력을 폄하하려는게 절대 아니라 <strong>정말 순수하게 궁금했습니다.</strong></p>\n<blockquote>\n<p>사실 이전까지 알고리즘 문제를 단 한번도 풀어보지 않았지만 갑자기 저런 당돌한 생각이 들더라구요.</p>\n</blockquote>\n<h2 id=\"습관-들이기와-실패\" style=\"position:relative;\"><a href=\"#%EC%8A%B5%EA%B4%80-%EB%93%A4%EC%9D%B4%EA%B8%B0%EC%99%80-%EC%8B%A4%ED%8C%A8\" aria-label=\"습관 들이기와 실패 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>습관 들이기와 실패</h2>\n<p>학부때 배운 알고리즘 지식을 제외하고 PS계통에 대한 지식은 전무했습니다. 자료구조와 알고리즘에 대한 조금의 배경지식은 있었지만, 그것을 제외하고는 완전한 뉴비수준이었습니다.\r\n일반적으로 근무지에서 정해진 일을 하고 난 후에 어느정도의 개인시간이 보장되기에 노트북을 들고와 대략 6월부터 <a href=\"https://www.acmicpc.net/\">백준</a>사이트에서 아주 난이도가 낮은 문제부터 한 문제씩 풀기 시작했습니다.</p>\n<p>구현, 자료구조, 탐색, DP 와 같은 알고리즘 분류도 조금씩 신경쓰면서 풀었습니다. 매일 문제가 잘 풀리거나 쉬운 문제 같은 경우는 2~3문제, 어려운 문제라면 1시간씩 고민해가면서 풀고 정 풀리지 않으면 해답을 참고하되 저만의 논리구조를 머릿속에 구상해서 다시 풀어보았습니다. 평균적으로 1일 1문제 정도는 꼬박꼬박 풀었습니다.</p>\n<blockquote>\n<p><a href=\"https://github.com/BecomeWeasel/daily_algo_challenge\">https://github.com/BecomeWeasel/daily_algo_challenge</a> 에 업로드하면서 성취감을 느꼈습니다. 여러분도 참고해보세용!</p>\n</blockquote>\n<p>3개월간은 정말 재밌게, 그리고 제가 느끼기에도 성장한다는 것을 느낄정도로 열심히 했습니다. 하지만 문제가 생겼습니다. 10월쯤 되어서 조금씩 귀찮아지기 시작했고, 다시 로스트아크라는 게임에 열중하게 되면서 알고리즘을 완전 뒤편으로 미루게 되었고 시간을 좀 허비하게 되었습니다.</p>\n<blockquote>\n<p>로스트아크는 정말 재밌게 했습니다. 진짜 재밌었어요..</p>\n</blockquote>\n<h2 id=\"다시-시작하기\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%8B%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\" aria-label=\"다시 시작하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다시 시작하기</h2>\n<p>21년도 4~5월쯤 되어서야 흘러가는 시간이 너무 아깝다고 느껴서 다른 개발 공부와 알고리즘 풀이를 다시 시작했습니다. 이전의 감각을 찾기 위해서 무리하지 않고 평일에만 1문제씩 풀고, <strong>주말은 무리하지 않고 알고리즘 공부가 아닌 다른 개발 공부를 했습니다.</strong> 또 백준뿐만 아니라 리트코드와 프로그래머스 문제들도 풀었습니다.\r\n개인적으로 문제들의 다양성은 백준이 좋지만, <strong>질은 리트코드가 압도적</strong>이라고 생각합니다.\r\n또 동아리 <strong>후배 둘과 스터디를 구성해 알고리즘 스터디</strong>를 시작했습니다.\r\n<strong>개인적으로 이게 정말 정말 많은 도움이 되었습니다.</strong> 여러분들도 단기적인 스터디 말고 긴 호흡의 스터디를 구성하는걸 추천드립니다.</p>\n<blockquote>\n<p>같이 스터디를 하면서 함께 성장한 IS 오렌지와 CS 강민이 정말 고마웡,,🙇‍♂️</p>\n</blockquote>\n<h2 id=\"뜬금없는-블라인드-공채\" style=\"position:relative;\"><a href=\"#%EB%9C%AC%EA%B8%88%EC%97%86%EB%8A%94-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EA%B3%B5%EC%B1%84\" aria-label=\"뜬금없는 블라인드 공채 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>뜬금없는 블라인드 공채</h2>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/5581e750-3b37-4de6-81de-911e61947bf4/image.png\" alt=\"\">\r\n알고리즘 문제를 조금씩 풀면서 스터디를 해가던 중 카카오에서 <strong>2022 신입 개발자 블라인드 채용</strong> 공고를 올린 것을 보게 되었습니다. 일반적으로 코딩테스트의 난이도를 생각했을때 문제의 질이나 난이도적인 측면에서 높은 기업이기에 이전에도 종종 카카오 코테를 참고하곤 했습니다.</p>\n<p>입시를 준비할때도 실전모의고사가 가장 효과가 좋듯 정말 가볍게 코딩테스트만 보기로 마음먹고 지원을 해보았습니다. 모두들 아시다시피 카카오는 지원을 할때 필수적인 정보만 적고 <strong>자기소개서나 학력같은걸 일체 명시하지 않습니다.</strong></p>\n<p>지원자격도 <strong>학력 및 전공에 제한이 없고 남성의 경우 군필의 제한만</strong> 있었습니다.\r\n저는 지원할때는 아직 소집해제 전이였지만, <strong>입사전에는 소집해제를 하기 때문에 지원을 해보았습니다.</strong>\r\n<img src=\"https://images.velog.io/images/hsw0194/post/43ba3e2a-6774-4919-9331-410c62d0a86c/image.png\" alt=\"\">\r\n또 저는 3학년까지 밖에 마치지 않았고 졸업하기까지는 1년이 남았지만 , <strong>일반적인 기업에서 요구하는 것처럼 졸업이나 졸업예정자 조건을 카카오는 요구하지 않았습니다.</strong>\r\n<img src=\"https://images.velog.io/images/hsw0194/post/f3d6ed09-882a-44fe-b997-b496aa4ad9d9/image.png\" alt=\"\">\r\n저는 아래처럼 4개의 전형절차중에서 1단계인 1차 온라인 코딩테스트만 <strong>찍먹</strong>만 해보려고 지원을 했습니다.\r\n<img src=\"https://images.velog.io/images/hsw0194/post/275e3e8e-2218-4b39-85bd-0b70f386a5a4/image.png\" alt=\"\">\r\n지원과정에서 입사를 희망하는 계열사를 1지망 2지망으로 선택하는데 저는 <strong>카카오페이</strong>와 <strong>카카오 본사</strong>를 각각 선택했습니다.</p>\n<h2 id=\"1차-코딩테스트\" style=\"position:relative;\"><a href=\"#1%EC%B0%A8-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"1차 코딩테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1차 코딩테스트</h2>\n<p>1차 코딩테스트는 9월 11일로 지원하고 일주일 정도의 시간이 있었습니다. 엄청 대단한것을 준비하지는 않았고, 기출문제들을 풀어보면서 카카오 코테들의 <strong>경향성을 파악</strong>하는데 시간을 들였습니다. 이 경향성 분석이 조금 도움이 되었던 것 같습니다. 기본적인 자료구조와 알고리즘을 다시 복습하고, 제가 스스로 정리한 문제 분류별 해결방법을 다시 읽어보면서 기다렸습니다.</p>\n<p>9월 11일이 되어서 5시간동안의 1차 코딩 테스트를 응시했습니다. 1차 코딩테스트의 후기는 다른 글에도 많이 정리되어있으니 크게 다루지는 않겠습니다.\r\n총 7개의 문제가 있었고, 확실히 이전보다는 난이도가 많이 낮았습니다. 난이도는 체감상 실버 2문제, 골드 3문제, 플래티넘 이상 2문제 정도였습니다.</p>\n<p>그렇지만 첫 코딩테스트이기도 하고 시간이 정해져있다는 압박감에 5번문제(양과 늑대) 같은 쉬운 탐색 문제나 6번문제 (구간합)문제를 보고 머리가 하얗게 변했습니다. 풀이도 잘 떠오르지 않았습니다.</p>\n<p>결과적으로 <strong>4.5개</strong>의 문제만 해결할 수 있어서 탈락을 직감했습니다.</p>\n<p>그렇게 지내던 중, <strong>[카카오] 2022 신입 개발자 블라인드 채용 1차코딩테스트 결과 안내드립니다.</strong> 라는 제목의 메일을 받게 되었고, 뒹굴거리면서 확인을 했는데 결과는 충격적이게도 <strong>합격</strong>이었습니다.</p>\n<p><img src=\"https://images.velog.io/images/hsw0194/post/c3afa1e2-dd1f-46d5-94b7-dd15e590c67f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-12-15%2021.07.57.png\" alt=\"\">\r\n기쁘다는 감정보다 <strong>이때까지 공부하던것이 그렇게 헛되지 않았구나</strong>라는 감정을 먼저 느끼게 되었습니다.</p>\n<h2 id=\"2차-코딩테스트\" style=\"position:relative;\"><a href=\"#2%EC%B0%A8-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"2차 코딩테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2차 코딩테스트</h2>\n<p>그리고 정말 급급하게 2차 코딩테스트를 준비해야 했습니다. 2차 코딩테스트를 준비하면서 알게된 점이 2차 코딩테스트는 엄청난 알고리즘 실력보다 디자인(<em>그 디자인이 아닌 설계</em>)과 최적화에 집중해야 한다는 것을 알게 되었습니다.</p>\n<p>기출 문제와 채점하는 환경이 대부분 공개되어 있기때문에 2021,2020 블라인드 공채 2차 코테문제를 스터디원 중 한명과 같이 풀어보았습니다. 그런데 아무리 해봐도 풀리지가 않았습니다. 전날까지 보고갔는데도 도저히 모르겠더라구요..\r\n<strong>자포자기의 심정이었습니다.</strong></p>\n<p>그렇게 9.25일이 되어서 2차 코딩테스트를 치루게 되었습니다. 2차 코딩테스트는 10문항 정도의 CS 객관식+주관식 문제와 하나의 문제인 시스템 설계와 최적화 파트로 구성되어 있습니다. 중간 중간 휴식시간을 포함해서 총 7시간 정도 응시하고, 캠과 화면 모니터링을 켜고 봐야합니다.</p>\n<h3 id=\"cs-문제\" style=\"position:relative;\"><a href=\"#cs-%EB%AC%B8%EC%A0%9C\" aria-label=\"cs 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CS 문제</h3>\n<p>대부분의 문제는 <strong>CS 코어 과목에서 출제되었고 기본에 충실한 문제들이었습니다.</strong> 학부 수업을 충실하게 들은 전공자라면 큰 부담이 되지 않는 문제 8문제 정도와 살짝 헷갈릴 수 있는 2문제 정도로 구성되어 있습니다. 저는 10문제 중에서 7개 정도 맞았던 걸로 기억합니다.</p>\n<blockquote>\n<p>CS 테스트는 점수보다 적부라는 썰이 있습니다.</p>\n</blockquote>\n<h3 id=\"설계와-최적화-문제\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EA%B3%84%EC%99%80-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%AC%B8%EC%A0%9C\" aria-label=\"설계와 최적화 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설계와 최적화 문제</h3>\n<p>어차피 해설이 올라올 것이고 아직은 민감할 수 있기 때문에 자세히는 언급하지 않고 간단하게 말씀드리겠습니다.</p>\n<p>2차 코딩테스트는 ICPC같은 대회처럼 응시자들의 점수와 나의 등수를 실시간으로 확인할 수 있기에 부담이 되었습니다. 저는 부담을 최대한 덜 받기 위해서 잘 확인하지 않았습니다.\r\n문제가 시나리오1,2로 구성되기에 합산점수로 최종점수가 매겨집니다.</p>\n<p>복수의 사용자들의 실력에 맞게끔 정렬하는 것이 최종 목적인데, 사용자들의 실제 실력을 알 수 없기 때문에 온라인 게임에서 많이 볼 수 있는 <strong>랭크 기반 매칭시스템</strong>을 구현하는 것이 방법입니다.</p>\n<p>제한적인 검색이 가능하기 때문에 사례를 많이 찾아보았고 Elo 시스템을 채택하였습니다. 그 후 적당히 최적화 방법을 계속 구현해 최종점수를 조금씩 끌어올렸습니다. 응시 종료 30분전 점수판이 프리징되는데 그 때 기준으로 <strong>300등대 초반으로 마무리했습니다.</strong></p>\n<p>2차 코테를 끝내고 카카오가 3자리수대의 채용을 한다고 했으니 약간 희망을 품었지만,신경쓰지 않고 얼마 안남은 소집해제만 대비하며 내년 복학준비만 생각하고 있었습니다.</p>\n<p>그러던 와중 <strong>소집해제일인 10.14일</strong>이 되었고 뭔가 기분이 묘한 감정을 느끼던 와중에\r\n<strong>[카카오] 2022 신입 개발자 블라인드 채용 2차코딩테스트 안내드립니다.</strong> 라는 제목의 메일을 받게 되엇습니다.\r\n<img src=\"https://images.velog.io/images/hsw0194/post/dfc98ef1-4c7c-43cd-901b-aa770ee2cd65/image.png\" alt=\"\">\r\n1지망으로 작성한 카카오페이에 <strong>합격</strong>이었습니다. 뭔가 <strong>일이 이상하게 굴러가고 있다</strong>는 것을 느끼게 되었고 기분이 이상했습니다.</p>\n<h2 id=\"hr-인터뷰\" style=\"position:relative;\"><a href=\"#hr-%EC%9D%B8%ED%84%B0%EB%B7%B0\" aria-label=\"hr 인터뷰 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HR 인터뷰</h2>\n<h3 id=\"자기소개서와-hr-인터뷰-준비하기\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EA%B8%B0%EC%86%8C%EA%B0%9C%EC%84%9C%EC%99%80-hr-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0\" aria-label=\"자기소개서와 hr 인터뷰 준비하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자기소개서와 HR 인터뷰 준비하기</h3>\n<p>특이하게도 카카오페이는 1차가 기술인터뷰가 아닌 HR인터뷰였습니다.\r\n일반적으로 최종면접이 인성면접인데 <strong>순서가 반대였습니다.</strong></p>\n<blockquote>\n<p>후에 알게되었지만, 다 이유가 있었습니다.</p>\n</blockquote>\n<p>HR인터뷰 단어가 생소했지만, 컬쳐핏 면접이나 인성면접으로 생각했습니다. 소집해제 날부터 급하게 자기소개서를 준비했습니다.</p>\n<p>공대생치고는 드림클래스나 서포터즈,교내 홍보대사같은 대외활동을 많이 해본편이어서 여러 대외활동을 위한 자기소개서는 꽤 써보았지만, 취업준비를 당연히 해본적이 없기에 <strong>자기소개서부터 걱정이였습니다.</strong> 하지만 다행히도 문항들은 평이한 수준이었고, 프로젝트 경험과 같은 일반적인 질문들로 구성되었습니다.</p>\n<p>입대하기전 <strong>SKT에서 수상했던 AI 공모전 우승</strong>경험을 중점적으로 작성했고 그 과정에서 접근방식과 해결방식 위주로 작성했습니다. (후술하겠지만 이 부분에서 굉장히 좋은 평가를 받았습니다.) 또 아주 조그만 프로젝트도 작성했습니다.</p>\n<p>자기소개서와 포트폴리오를 작성하면서 느낀 점이 프로젝트 경험이 많이 부족하다는 점을 절실히 깨닫게 되었습니다.</p>\n<blockquote>\n<p><strong>알고리즘+CS+프로젝트</strong> 이 삼박자가 완벽해야 취준에 성공할 수 있어보입니다.</p>\n</blockquote>\n<p>자기소개서를 제출하고는 급하게 HR인터뷰를 준비했습니다. 경험이 전무하다보니 어디서부터 접근해야할지 몰라 많이 헤맸지만, <strong>교내 홍보대사 활동을 통해서 다양한 전공의 사람들과 많이 만날수 있게 되었고, 대부분이 취업준비를 하거나 이미 취업을 한 상태여서 주변에서 정말 정말 많은 도움을 받게 되었습니다.</strong></p>\n<blockquote>\n<p>학교생활을 하면서 다양한 전공의 사람들과 <strong>교류하며 인맥을 넓히는 것은 확실하게 도움이 됩니다.</strong></p>\n</blockquote>\n<p>또 카카오페이라는 테크핀 기업에 대한 분석과 <strong>결제&#x26;송금 도메인에 대한 지식</strong>을 공부하게 되었습니다. 여러 유튜브를 참고하면서 인성면접 빈출문제에 대한 답변과 개발회사에 국한되는 가치관 질문을 거의 다 준비했습니다.</p>\n<h3 id=\"인터뷰를-마치고\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%B7%B0%EB%A5%BC-%EB%A7%88%EC%B9%98%EA%B3%A0\" aria-label=\"인터뷰를 마치고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터뷰를 마치고</h3>\n<p>HR인터뷰는 10월 말경에 <strong>화상으로 진행되었습니다.</strong>\r\n덜덜 떨면서 참여했는데, 면접관분이 긴장을 풀어주시려고 많이 노력해주셨고 <strong>면접관의 태도나 질문에서 따뜻함</strong>을 느낄 수 있어서 결과에 상관없이 카카오페이에 대한 이미지가 매우 좋게 각인되었습니다.\r\n인터뷰는 다행히도 일반적인 수준과 익숙한 질문들로 구성되었지만 면접관분이 <strong>가끔 정말 날카로운 질문으로 답변 내용을 확인하고는 하셨습니다.</strong></p>\n<p>1,2차 코딩테스트를 마치고는 둘다 탈락했다고 생각했지만, HR인터뷰를 마치고는 합격에 대한 아주 조금의 확신을 가지게 되었습니다.\r\n자세히는 말씀드리기 어렵지만, 복수의 파트에서 좋은 평가를 받게 되어 조금의 희망이 생겼습니다.</p>\n<p>1,2차 코딩테스트를 응시할때는 정말 <em><strong>모의고사</strong> 느낌으로 보자, 경험만 쌓자</em> 였지만,\r\nHR인터뷰를 마치고부터는 정말 <strong>진심모드로 최선을 다해서 준비해야겠다</strong>는 생각을 하게 되었습니다.</p>\n<p>면접을 마치고 일주일쯤 뒤에 메일 제목부터 강한 <strong>스포일러</strong>를 당했습니다.\r\n<strong>[카카오페이] HR 인터뷰 전형 합격을 축하드립니다!</strong> 라는 메일을 받게 되었습니다.\r\n이제 그렇게 열망하던 <strong>카카오 입사까지 1단계만 남았다는 것이 실감나게 되었습니다.</strong>\r\n<img src=\"https://images.velog.io/images/hsw0194/post/da4aa7bf-0b5f-4373-91a9-7c73034893f3/image.png\" alt=\"\"></p>\n<h2 id=\"기술-인터뷰\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%88%A0-%EC%9D%B8%ED%84%B0%EB%B7%B0\" aria-label=\"기술 인터뷰 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기술 인터뷰</h2>\n<h3 id=\"기술인터뷰-준비하기\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%88%A0%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0\" aria-label=\"기술인터뷰 준비하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기술인터뷰 준비하기</h3>\n<p>기술 인터뷰, 2차 인터뷰, 최종 면접 다 맞는 말이지만 <strong>기술 인터뷰</strong>라고 하겠습니다.</p>\n<p>얼렁뚱땅 시작한 공채 지원도 이제 마지막 단계, 그리고 가장 어려운 단계만 남기고 있었습니다.\r\n당연하게도 기술면접 경험이 없었기에 주변의 개발자들에게 조언을 많이 구했고 캐치카페와 같은 사이트도 참조하면서 기술면접을 준비했습니다.</p>\n<p>일반적으로 기술면접은 <strong>포트폴리오에 명시한 프로젝트+CS 기본기</strong>로 진행됩니다. 저는 포트폴리오가 처참할정도로 빈약하기에 CS 기본기에 올인했습니다.</p>\n<p>CS 기본기는 github 저장소에 정말 많은 자료들이 있습니다. 예를 들자면</p>\n<ol>\n<li><a href=\"https://github.com/JaeYeopHan/Interview_Question_for_Beginner\">한재엽님의 CS 질문 저장소</a> : 대체적으로 많이 참고되는 저장소입니다.</li>\n<li><a href=\"https://github.com/WooVictory/Ready-For-Tech-Interview\">Woovicotry님의 CS 질문 저장소</a> : 1번과 비교해서 상대적으로 덜 알려져 있지만 퀄리티는 뒤지지 않습니다.</li>\n</ol>\n<p>이런 저장소들을 참고해서 공부했습니다.</p>\n<p>단, <strong>반드시 명심해야할 것이 인터넷의 자료는 완벽하지 않고 실제로 명백하게 틀린 부분도 꽤 많아서</strong> 저는 저장소에서는 질문을 참고했고 실제 답변은 <strong>영문 공식문서나 원서를 주로 참고</strong>했습니다.</p>\n<p>또 기술 면접은 <strong>DFS</strong>로 준비해야 한다는 말을 많이 들었습니다. 그래서 단순히 안다 or 모른다가 아니라 아래와 같은 기준으로 깊게 준비했습니다.</p>\n<ul>\n<li><strong>왜 이 기술이 사용되었는지</strong></li>\n<li><strong>내부 구조는 어떻게 되어있는지</strong></li>\n<li><strong>왜 A가 아닌 B를 선택해야 하는지</strong></li>\n<li><strong>실제 활용은 어떻게 되는지</strong></li>\n</ul>\n<p>제가 가장 좋아하는 자료구조인 <strong>HashTable</strong>을 예로 들어서 설명드리겠습니다.</p>\n<ul>\n<li><strong>왜 이 기술이 사용되었는지</strong>일반적으로 $$O(1)$$ 시간복잡도로 조회,삽입,수정이 가능하다.</li>\n<li><strong>내부 구조는 어떻게 되어있는지</strong> : hashtable은 충돌을 잘 관리해야하는데, 일반적으로 개방주소법/분리연결법이 사용된다.</li>\n<li><strong>왜 A가 아닌 B를 선택해야 하는지</strong> : 개방주소법은 구현이 간단하고, 캐시에서의 이점이 있지만 로드팩터에 민감하고 삭제가 어렵지만 분리연결법은 로드팩터에 영향을 조금 덜 받고 hashtable의 확장이 더디게 일어나지만 추가적인 오버헤드가 있다.</li>\n<li><strong>실제 활용은 어떻게 되는지</strong> : Python 3에서는 개방주소법,Java에서는 분리연결법을 사용한다.</li>\n</ul>\n<h3 id=\"부족함\" style=\"position:relative;\"><a href=\"#%EB%B6%80%EC%A1%B1%ED%95%A8\" aria-label=\"부족함 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>부족함</h3>\n<p>사실 위는 꽤 자세하게 준비한 것 같지만 <strong>저는 절대적으로 부족하다고 생각합니다.</strong>\r\n예를 들어 개방주소법은 왜 캐시효율이 좋을까요? 또 개방주소법에서도 여러가지 기법이 있고, 그에 따른 추가적인 트레이드오프가 있습니다. 분리연결법에서도 버킷에 연결리스트를 구성하는 방법과 트리로 구성하는 방법등이 있습니다.</p>\n<p>그러면 왜 트리를 사용할까요? 또 <strong>Java는 왜 분리연결법</strong>을 사용할까요? Java 8 부터 사용하는 분리연결법은 트리와 연결리스트를 동시에 사용하는데, 이때 <strong>균형이진트리인 RB 트리를 사용</strong>합니다.\r\nAVL이나 Splay도 있는데 왜 RB 트리일까요?\r\n이렇게 준비할때도 끊임없이 하나씩 의문을 제기하면서 deep 하게 준비했습니다.</p>\n<blockquote>\n<p>이처럼 노션을 활용해서 대략 50개 정도의 질문들 하나하나를 깊게 준비했습니다.<img src=\"https://images.velog.io/images/hsw0194/post/01d2caeb-0101-439e-88f6-b588596d4eb0/image.png\" alt=\"\"></p>\n</blockquote>\n<p>포트폴리오는 제가 했던 프로젝트의 설계와 DB 모델링을 다시 점검하고, 특정 기술을 사용한 이유에 대해서 고민하며 준비했지만 매우 빈약했습니다 ㅠㅠ</p>\n<h3 id=\"기술-인터뷰-1\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%88%A0-%EC%9D%B8%ED%84%B0%EB%B7%B0-1\" aria-label=\"기술 인터뷰 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기술 인터뷰</h3>\n<p>기술 인터뷰 역시 화상으로 진행되었으며 1:N 방식으로 1시간 가량 진행되었습니다.\r\n단순히 <em>이거 알아요?</em> 보다는 <em>이 기술을 사용한 이유가 뭐에요?</em> 부터 시작하는 꼬리물기 형태의 질문으로 인터뷰 전체가 흘러갔습니다. 또 포트폴리오 질문은 단순히 <strong>포트폴리오 질문이 아니라 CS로 자연스럽게 이어지는 질문이었습니다.</strong></p>\n<p>다만 CS 질문이 다른 계열사처럼 폭포수처럼 쏟아지지는 않았고 <strong>핵심적인 부분만 질문하셨습니다</strong>. 또 흥미로운게 제가 제출한 블로그의 글들을 보시고 그와 관련된 질문들을 하셨는데, 이것도 굉장히 깊숙히 질문하셨습니다.\r\n인터넷에 정말 많은 기술글들처럼 <em>단순히 글을 실어 나른것인지</em> 가 아니라 <strong><em>내부구조부터 깊게 고민해보았는지</em></strong> 에 대한 질문들이셨습니다.</p>\n<p>면접이 끝나고 사실 반반의 심정이였습니다. 아쉽게도 제가 준비한 모든것을 보여드리진 못했지만, 급급하게 준비한거치고는 방어를 적당히 한것 같다라는 느낌이였습니다.</p>\n<p>꽤 긴 기다림의 시간끝에 <strong>[카카오페이] 안녕하세요. 카카오페이입니다.</strong> 라는 제목의 메일을 받게 되었습니다.\r\n<img src=\"https://images.velog.io/images/hsw0194/post/6858a3c6-29fa-4ac9-bedf-1c9363907297/image.png\" alt=\"\">\r\n아쉽게도 결과는 <strong>불합격</strong>이었습니다. 어찌보면 <strong>당연한 결과라고 생각했습니다.</strong> 준비를 하면서 알게된 점이 입사하시는 분들의 공통점은 <strong>꾸준함과 탁월함</strong>임을 알게되었는데, 저는 두 부분 모두 빈약했던것 같습니다.</p>\n<h2 id=\"과정을-끝내고\" style=\"position:relative;\"><a href=\"#%EA%B3%BC%EC%A0%95%EC%9D%84-%EB%81%9D%EB%82%B4%EA%B3%A0\" aria-label=\"과정을 끝내고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>과정을 끝내고</h2>\n<p><strong>얼렁뚱땅 시작된 공채지원이였지만, 최종면접까지 가게 되었습니다.</strong> 저는 최종탈락이라는 결과에 주목하기보다는 그 과정까지 가면서 준비하면서 제가 <strong>부족한 점이 무엇인지</strong> 확실히 깨닫게 되었습니다.\r\n또 여러 과정, 특히 인터뷰를 하면서 카카오라는 기업이 정말 젠틀하고, 지원자 중심에서 생각해주는 기업이라는 점을 알게 되어 카카오에 입사하고 싶은 열망이 더 커지게 되었습니다.</p>\n<blockquote>\n<p>내년에도 다시 1,2차 코테부터 할 생각하니까 아찔하긴 합니다.</p>\n</blockquote>\n<p>3학년을 갓 마치고, 조금의 특수성은 있지만 군 복무를 마친 직후에 해본 첫 시도가 <strong>가장 챌린징스럽고 배운점이 많아 굉장히 뿌듯했습니다.</strong> 아마 이제는 복학을 준비하면서, 제가 <strong>부족했던 부분을 돌아보면서 그 부분을 개선하는 방식</strong>으로 진행할것 같습니다.</p>\n<p>굉장히 긴 글이여서 쓰는 저 만큼이나 읽으시는 분들이 부담스러울텐데 투머치토커의 기질을 숨기기 쉽지않네요. 이 글을 읽으시는 모든 분들이 모두 원하는 회사에 합류하기를 기원합니다🙏</p>\n<blockquote>\n<p>진짜 소집해제 한날부터 면접날까지 제대로 쉰 날이 없엇기에 이젠 좀 편하게 쉬면서 공부하려구요..<img src=\"https://images.velog.io/images/hsw0194/post/c1941b7e-bb97-454d-b747-08070f4e0f2c/image.png\" alt=\"\"></p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%A1%B0%EA%B8%88-%EB%8A%A6%EC%9D%80-%EC%8B%9C%EC%9E%91\">조금 늦은 시작</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%B5%EA%B4%80-%EB%93%A4%EC%9D%B4%EA%B8%B0%EC%99%80-%EC%8B%A4%ED%8C%A8\">습관 들이기와 실패</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A4%EC%8B%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\">다시 시작하기</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%9C%AC%EA%B8%88%EC%97%86%EB%8A%94-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EA%B3%B5%EC%B1%84\">뜬금없는 블라인드 공채</a></p>\n</li>\n<li>\n<p><a href=\"#1%EC%B0%A8-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8\">1차 코딩테스트</a></p>\n</li>\n<li>\n<p><a href=\"#2%EC%B0%A8-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8\">2차 코딩테스트</a></p>\n<ul>\n<li><a href=\"#cs-%EB%AC%B8%EC%A0%9C\">CS 문제</a></li>\n<li><a href=\"#%EC%84%A4%EA%B3%84%EC%99%80-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%AC%B8%EC%A0%9C\">설계와 최적화 문제</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#hr-%EC%9D%B8%ED%84%B0%EB%B7%B0\">HR 인터뷰</a></p>\n<ul>\n<li><a href=\"#%EC%9E%90%EA%B8%B0%EC%86%8C%EA%B0%9C%EC%84%9C%EC%99%80-hr-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0\">자기소개서와 HR 인터뷰 준비하기</a></li>\n<li><a href=\"#%EC%9D%B8%ED%84%B0%EB%B7%B0%EB%A5%BC-%EB%A7%88%EC%B9%98%EA%B3%A0\">인터뷰를 마치고</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B8%B0%EC%88%A0-%EC%9D%B8%ED%84%B0%EB%B7%B0\">기술 인터뷰</a></p>\n<ul>\n<li><a href=\"#%EA%B8%B0%EC%88%A0%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0\">기술인터뷰 준비하기</a></li>\n<li><a href=\"#%EB%B6%80%EC%A1%B1%ED%95%A8\">부족함</a></li>\n<li><a href=\"#%EA%B8%B0%EC%88%A0-%EC%9D%B8%ED%84%B0%EB%B7%B0-1\">기술 인터뷰</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B3%BC%EC%A0%95%EC%9D%84-%EB%81%9D%EB%82%B4%EA%B3%A0\">과정을 끝내고</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 16, 2021","title":"3학년의 2022 카카오 블라인드 공채 도전기","categories":"회고","author":"weasel","emoji":"📓"},"fields":{"slug":"/junior-student-challege-to-kakao-2022/"}},"prev":{"id":"867e7d2b-13b3-5749-8198-b6d3c099538d","html":"<p>일단 프로세스 스케쥴링 알고리즘에 대해서 언급하기 전에, 프로세스의 상태와 Context-Switching에 대해서 알아야 한다.</p>\n<p>여러가지 프로세스의 상태를 기반으로 전이(Transition)되며 이를 바탕으로 스케쥴링 알고리즘이 이루어진다.</p>\n<h2 id=\"프로세스의-상태\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\" aria-label=\"프로세스의 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>프로세스의 상태</strong></h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3UlEQVQ4y+VU2W7aUBC9AgRm+f/PqCAhjR9wVSoWEWynNirGZbcRYRVgDJj1RDMSVprnPlTqSEfjO8u5c2dGFkII/GX864TJZBLRaBSRSASSJCGTySCVSiGdToN8BDqTJv/9TKBYslFuLBbjHCHLMuRnGfnHPAqFAprNJvr9PmzbxnA4xGg0Qq/XDb9J93o9jrEsC4qiIPsli6f8E3K5HIRhGHCGDvrdPjqdDmazGd7exphMJgiCAMvlksld18HlcgHJdDrFer3GeDyG3bJh/bJg/jRRq9YgKPFwOGCz2eB0OnFCu91GtVqFrutsJ6Lz+czVl8tl6K86/J3PsefTGZ7n4Xg8cjFiPp+z43a7sSZjwzRRKVXQMBrodjtsXywWKP4o4uHxAdlcFqqmhjl3IS5BBB+FqqEnaaqGltWC7/uh3f5tQ/mmcGu2222Yc71ew2KYkHq12+0Y+/2e4Y5cJtZ1DS/1F1QqZR4G9Zv89ES6jPSdkOIF9YgMnrfhfhGo9CA4cIDVtFCv1WEaJlRV5X7RxTSU1WoVDoqEcoWmaeE6OI4TwnVdHkLxe5HXQv4qo1QqYTAY/BFHZ67ccXiIIpFIQJISIP0ZtMTxeBzxRJwXl5aY8Dnuo138fz+Hd45V7ag5zclUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/37523/process_state.png\"\n        srcset=\"/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/e9ff0/process_state.png 180w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/f21e7/process_state.png 360w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/37523/process_state.png 720w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/302a4/process_state.png 1080w,\n/static/3cd3f8aa2252e3e8c5282a5fa75d52c9/21b4d/process_state.png 1280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>프로세스의 상태는 OS에 따라서 개수도 다르고, 명칭도 조금 다르지만, 가장 대표적인 그림은 위의 상태와 같다.</p>\n<ul>\n<li><code class=\"language-text\">new</code> : 프로세스가 생성된 상태이다. 이때는 Readuy Queue 안에 들어 있지 않기 때문에 <strong>CPU를 받을 대상이 아니다.</strong></li>\n<li><code class=\"language-text\">ready</code> : 프로세스가 <strong>CPU를 할당받기 위해 대기</strong>하는 상태이다. 보통 <strong>Ready Queue 안</strong>에 들어와있는 상태라고 얘기한다. <strong>스케쥴링의 대상</strong>이 된다.</li>\n<li><code class=\"language-text\">running</code> : 현재 CPU를 할당받아 <strong>작업중인</strong> 상태다. Single core 시스템에서는 1개다.</li>\n<li><code class=\"language-text\">wating</code> : 프로세스가 <strong>입출력이나 이벤트가 끝나기를 기다리는</strong> 상태이다.</li>\n<li><code class=\"language-text\">terminated</code> : 프로세스가 <strong>종료된</strong> 상태다. 단 프로세스 구조체가 사라진 것은 아니다.</li>\n</ul>\n<p>그림에서 프로세스의 상태가 특정 작업들로 인하여 변하는 것을 볼 수 있는데 이것을 프로세스의 <strong>상태 전이(Transition)</strong> 라고 한다.</p>\n<ul>\n<li><code class=\"language-text\">admitted</code> : 생성된 프로세스가 CPU를 받을 준비가 되어서 <strong>Long-term Scheduler(Job Scheduler)</strong> 에 의해서 선택받아 Reaudy queue로 옮겨지는 작업이다.\n<ul>\n<li><strong>Long Term Scheduer :</strong> 어떠한 프로세스를 레디큐로 옮길지 선택하는 스케쥴러다. 자주 일어나지 않고, <strong>멀티프로그래밍의 정도(DOM)</strong> 가 이것에 영향을 받는다.\n<ul>\n<li>일반적으로 많은 프로세스가 한꺼번에 메모리에 올라오면, 일부는 디스크에 저장된다.</li>\n<li>존재하는 이유는 기존의 프로세스들이 자원을 확보하기 위해서 존재한다. 무턱대고 다 RQ로 올리면 기존의 프로세스는 작업이 진행되지 않는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"language-text\">scheduler dispatch</code> : <code class=\"language-text\">ready</code> 상태에 있는 프로세스를 <strong>Short term Scheduler</strong>가 선택해서 자원을 할당한 후 실행시키는 행위다.\n<ul>\n<li><strong>Short Term Scheduler :</strong> RQ에 있는 프로세스 중에서 어떠한 것이 다음으로 실행될지, CPU를 할당할지 선택하는 스케쥴러다.\n<ul>\n<li>빈번하게 발생한다. 그렇기에 이 스케쥴러의 오버헤드를를 줄여야 전체 오버헤드를 줄일 수 있다.</li>\n<li>스케쥴링 알고리즘과 아주 깊은 연관이 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"language-text\">interrupt</code>  : 인터럽트는 조금 논란이 있는데, 저 그림상에서는 입출력 이벤트는 포함하지 않는다. <strong>Context-switching이 일어난다.</strong>\n<ul>\n<li>선점식(preemptive) 방식에서는 타이머(<strong>Timer)</strong> 이벤트가 있다. 인터럽트 핸들러가 인터럽트를 일으켜서 STS에게 다른 프로세스를 선택할지, 지금 프로세스를 그대로 둘지 결정하게끔 한다. 만약 바뀐다면 전이가 일어난다.</li>\n<li>비선점식(non-preemptive 혹은 cooperative) 방식에서는 양보(<strong>Yield</strong>)가 있다. 이 방식에서는 OS가 프로세스를 스케쥴링할때 인터럽트를 사용,허용하지 않는다. 대신에 작동중인 프로세스가 자발적으로 양보를 해서 스케쥴러가 다른 프로세스를 스케쥴링할 수 있는 방식을 쓴다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">I/O or event wait</code> : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 끝날때까지 대기 상태로 만드는 것. <strong>Context-switching이 일어난다.</strong>\n<ul>\n<li>여기서 왜 <strong>ready로 안보내는지가 중요하다.</strong> 왜냐면, 이 프로세스는 ready로 가서 자원을 할당받을 자격이 없다. <strong>이벤트나 입출력이 끝나지 않았으니 자원을 받아도 사용하지 못하기 때문이다.</strong></li>\n</ul>\n</li>\n<li><code class=\"language-text\">I/O or event completion</code> : 입출력/이벤트가 끝난 프로세스를 ready 상태로 만들어 STS에게 선택될수 있게끔 한다. <code class=\"language-text\">wait</code> 과는 다르게 자원을 할당받기만 하면 작업을 이어나갈 수 있기 때문이다.</li>\n</ul>\n<h2 id=\"context-switching\" style=\"position:relative;\"><a href=\"#context-switching\" aria-label=\"context switching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Context-switching?</strong></h2>\n<p>정확한 정의는 ”<strong>CPU</strong>가 <strong>다른 프로세스로 스위치</strong>할때, 시스템(OS)이 <strong>기존의 프로세스의 상태를 저장</strong>하고, <strong>다음</strong> 진행될 <strong>프로세스의 저장된 상태값을 불러오는것</strong>“이다.</p>\n<ul>\n<li>이 때 중요한것이 PCB 등인데, PCB 안에는 CPU 레지스터에 대한 정보, PC,페이지 테이블과 관련된 정보가 있다. 그렇기에 PCB는 프로세스의 문맥을 보관하고 있는 것이다.</li>\n<li>다시 작업을 수행할때 이것을 참조해서 어디부터 다시 시작할지 참고 할 수 있다. 그렇기에 새로운 프로세스로 선택될때도 PCB를 불러와야하고, ready 상태나 waiting 상태로 프로세스가 전이될때도 PCB를 저장해야한다.</li>\n</ul>\n<p>일반적으로 context switch하는 시간은 순전한 오버헤드다. 대부분의 시스템은 이 전환 시간동안 어떤 의미있는 작업을 하지 않는다.</p>\n<p>또 가장 중요한 부분이 <strong>context-swtichg을 하면서 Cache flushing이 일어난다</strong>. 그렇기에 그 다음에는 <strong>연속적인 캐시 미스</strong>(successive cache misses)가 발생한다. 이 과정이 대부분의 오버헤드를 차지한다.</p>\n<blockquote>\n<p>💡 캐시를 날리는 이유는 새로운 프로세스는 새로운 virtual adrress를 가지는 새로운 메모리 주소다. 그렇기 때문에 기존의 캐시된 메모리의 주소 영역을 사용할 필요가 없기에 기존의 캐시된 메모리를 Flush 하는 것.</p>\n</blockquote>\n<blockquote>\n<p>참고로 스레드도 컨텍스트스위칭을 한다. 그치만 <strong>쓰레드들끼리는 주소공간을 공유</strong>하기 때문에 캐시를 flush할 필요가 없다.</p>\n</blockquote>\n<h3 id=\"process-context-switching-vs-thread-context-switching\" style=\"position:relative;\"><a href=\"#process-context-switching-vs-thread-context-switching\" aria-label=\"process context switching vs thread context switching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Process context switching vs Thread context switching</strong></h3>\n<p>프로세스만 context switching을 하는 것이 아닌 쓰레드끼리도 context switching을 한다. 다만 아래와 같은 차이점이 있다.</p>\n<ul>\n<li>프로세스간 context switching\n<ul>\n<li>커널 단에서 스위칭이 일어난다.</li>\n<li>메모리 주소 공간의 전환이 일어난다.</li>\n<li>프로세서의 <strong>캐시와 TLB 모두 Flush 된다. → 연속적인 캐시 미스와 TLB 미스가 일어난다.</strong></li>\n<li>메모리 주소공간이 전환되고, 캐시미스가 <strong>필연적으로 동반되므로 훨씬 비용이 비싸다</strong>.</li>\n</ul>\n</li>\n<li>쓰레드간 context switching\n<ul>\n<li>커널 단에서 스위칭이 마찬가지로 일어난다.</li>\n<li>같은 프로세스 내에서 일어나는 스위칭이기에 메모리 주소공간을 그대로 사용한다.</li>\n<li>프로세서의 <strong>캐시와 TLB 정보가 유지된다.</strong></li>\n<li>레지스터의 값과 스택 포인터 전환 정도만 일어나니 훨씬 저렴하다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"cpu-스케쥴링-알고리즘이란\" style=\"position:relative;\"><a href=\"#cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80\" aria-label=\"cpu 스케쥴링 알고리즘이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>CPU 스케쥴링 알고리즘이란?</strong></h2>\n<p>스케쥴링 알고리즘은 레디 큐에 있는 프로세스들을 대상으로 다음으로 실행할(CPU를 할당받을) 프로세스를 고르는 작업이다.</p>\n<p>일단 프로세스의 상태를 다이어그램으로 먼저 보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACAUlEQVQoz3WTXXOaQBSG/f+/xpvOtI1Jc9FpY2KN1GoQWFQEBTZ+gAqClaeza0LTJGXmsGeW3Wff95ylEd+m+B/WJMMMMlgIi7lwyLKMPMsoiwMyjvHsOWPLI4ojXNdFCMF7T+PxIcHteozHAX1zxN33GzzHJklT5rFk5I4JV0t6zTbmRZ/OfYfrL9eEYchyuSRNUx1BEJDnOQ2oCGVIxxlzaQxpC48Hy6LTvedzt89Fb8Ct5eI8/GQqLC4vr2g2mxq4Wq10xMqB552B1amq5W7TlDiKkLHUJ46GA3ZJUn8vylJv2u127Pf79y2r16kooCjIsvx80iHHtGw+tbu0un1atz+YzWaEi0W9UanabDY6P51OOqqqOgMrGeEP70mOB47Vb2SyIowiDNOibfRx/Tnr9Vrbs21b25VS6lAQzXgaGzwlw2iCMRuxybbsDhmzmc/IEZiOwBKutqhCQZIk0bZfgv4CgX2R8U0YXI3uGMwF1emE5we0egOu+iZff5kapBTW9d5ua9AzrAbmZYEVTZlvJOss1QsepeR4yCn2Oz0qdWVZ1pDXCv8BqsnieF5MBd50ii0EFx2Dj3c9us5EX3RVO9V9de+Sp+6/Ab6cULnqllKjrog58bgx+rR7BpPJGfrczde1e6PwdS3UX7CUkkUQMHYF0+mUKIr0vO/7/7X8B9PZjIsssUPCAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/8bdbc78afd4ec9a6165a99fcfe0f71fe/37523/queue_diagram.png\"\n        srcset=\"/static/8bdbc78afd4ec9a6165a99fcfe0f71fe/e9ff0/queue_diagram.png 180w,\n/static/8bdbc78afd4ec9a6165a99fcfe0f71fe/f21e7/queue_diagram.png 360w,\n/static/8bdbc78afd4ec9a6165a99fcfe0f71fe/37523/queue_diagram.png 720w,\n/static/8bdbc78afd4ec9a6165a99fcfe0f71fe/9d5da/queue_diagram.png 871w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>레디큐 뿐만 아니라, 새로 만들어지는 큐를 담는 큐도 있고, block(I/O wait) 큐도 있다. 일반적으로 CPU 스케쥴링 알고리즘은 <strong>Short-term scheduling</strong>을 얘기한다.</p>\n<p>스케쥴링 알고리즘을 얘기하기 전에 <strong>멀티 프로그래밍(Multi Programming)</strong> 과 <strong>시분할(Time sharing)</strong> (혹은 <strong>멀티 태스킹(Multi Tasking))</strong> 에 대해서 먼저 얘기를 해야한다.</p>\n<ul>\n<li><strong>멀티 프로그래밍</strong>\n<ul>\n<li>작업들을 적절히 구성해 <strong>항상 CPU가 프로세스를 실행</strong>하도록 한다.</li>\n<li>어떤 프로세스가 CPU를 할당받아 사용하다 I/O 작업등 CPU를 필요로 하지 않는 순간이 오면,</li>\n</ul>\n다른 프로세스로 교체해서 그 프로세스가 CPU를 계속 사용할 수 있도록 한다.\n<ul>\n<li>이것의 목적은 <strong>CPU 사용률</strong>(CPU Utilization)을 최대화함에 있다.</li>\n</ul>\n</li>\n<li><strong>시분할(멀티 태스킹)</strong>\n<ul>\n<li>CPU가 일할때 <strong>매우 빈번하게 수행중인 작업을 교체</strong>해서 사용자가 상호작용할 수 있는것이다.</li>\n<li>반응하는데 걸리는 시간(Response time)이 충분히 작아야 프로그램들이 동시에 진행하는것처럼 보인다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"스케쥴링의-발생과-목적\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81%EC%9D%98-%EB%B0%9C%EC%83%9D%EA%B3%BC-%EB%AA%A9%EC%A0%81\" aria-label=\"스케쥴링의 발생과 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케쥴링의 발생과 목적</h3>\n<p>CPU 스케쥴링은 아래와 같은 상황에서 일어난다.</p>\n<ul>\n<li><code class=\"language-text\">running</code> 에서 <code class=\"language-text\">waiting</code> 으로 갈 때 (I/O Request)</li>\n<li><code class=\"language-text\">running</code> 에서 <code class=\"language-text\">ready</code> 로 갈 때 (timeout), <strong>Preemptive</strong></li>\n<li><code class=\"language-text\">waiting</code> 에서 <code class=\"language-text\">ready</code> 로 갈 때 (I/O Finish, <strong>이때 스케쥴링 해주는 이유는, I/O가 끝난 이후에 핸들링을 해줘야 하기 때문이다</strong>. 기존의 <code class=\"language-text\">running</code> 프로세스는 고려하지 않음),<strong>Preemptive</strong></li>\n<li><code class=\"language-text\">running</code> 에서 <code class=\"language-text\">terminated</code> 로 갈 때 (프로세스의 종료)</li>\n</ul>\n<p>만약 스케쥴링이 1번과 4번에서만 일어난다면 , non-preempitve지만, 그렇지 않다면 <strong>preemptive</strong> 스케쥴링이다.</p>\n<p>스케쥴링 알고리즘에 대한 기준은 몇가지가 있다</p>\n<ul>\n<li><strong>CPU 이용률</strong> : CPU를 가능한 바쁘게 해야 한다. 높을 수록 좋음</li>\n<li><strong>Throughput</strong> : 단위시간당 프로세스 처리 수,batch 시스템에선 중요함, 높을 수록 좋음</li>\n<li><strong>Turnaround time</strong> : 특정 프로세스가 도착시간에서부터 끝날때까지 걸린 시간, 낮을 수록 좋음</li>\n<li><strong>Waiting time</strong> : 레디큐에서 기다린 시간의 합 , 범용적으로 중요하고, 낮을 수록 좋음</li>\n<li><strong>Response time</strong> : 요청이 들어왔을때 첫번째 응답까지 걸리는 시간,일반적인 PC에서 중요하다. Throughput과는 반대의 관계이며 낮을수록 좋다.</li>\n</ul>\n<h3 id=\"스케쥴링-알고리즘\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"스케쥴링 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케쥴링 알고리즘</h3>\n<ul>\n<li><strong>FCFS</strong> (First-Come, First-Served)\n<ul>\n<li><strong>비선점</strong></li>\n<li>먼저 CPU를 요청한 프로세스에게 먼저 CPU가 할당된다. <strong>공평하다</strong>.</li>\n<li>큐를 이용하면 쉽게 구현이 가능하다</li>\n<li>도착순서를 바꿈으로써 전체 waiting time이 바뀐다. <strong>CPU bound job을 뒤로 하면 확 줄어든다</strong></li>\n<li><strong>Convoy Effect</strong> : <strong>시간이 짧게 걸리는 프로세스가 시간이 오래 걸리는 프로세스 뒤에 있으면 CPU 전체 사용률이 줄어든다.</strong></li>\n</ul>\n</li>\n<li><strong>SJF</strong> (Shortest Job First)\n<ul>\n<li><strong>기본적으로 비선점</strong> 방식</li>\n<li>CPU burst time이 가장 작은 프로세스를 먼저 CPU 할당시킨다.</li>\n<li><strong>선점방식으로 구현하는것을 SRTF</strong>(Shortest Remaining Time First) 방법은, 현재 프로세스의 남은 시간보다 더 짧은 프로세스가 새로 들어오면, 선점해버리는 방식이다.\n<ul>\n<li>컨텍스트 스위칭에 드는 <strong>오버헤드를 고려하지 않을시에는 SJF보다 성능이 좋다.</strong></li>\n<li>만약 선점방식이라면, CPU burst time이 긴 프로세스는 계속 실행되지 못하는 <strong>기아(starvation)</strong> 현상이 발생 할 수 있다.</li>\n</ul>\n</li>\n<li>하지만 현실적으로 SJF는 구현하기 어려운데, <strong>CPU의 남은 시간을 예측불가</strong>하기 때문이다. 그래서 평균 waiting time이 최소인 Optimal한 알고리즘이다.</li>\n<li>그나마 유사하게 접근 하는 방식은 <strong>이전 CPU burst time을 기반으로 예측</strong>하는 것이다.</li>\n</ul>\n</li>\n<li><strong>Priority Scheduling</strong>\n<ul>\n<li>각 프로세스에게 우선순위 지시자가 연결되어 있다.</li>\n<li><strong>가장 높은 우선순위</strong>(일반적으로 가장 낮은 숫자)를 가진 프로세스에게 CPU가 할당된다</li>\n<li>SJF도 CPU burst time이라는 우선순위를 가지는 우선순위 스케쥴링 방식이다.</li>\n<li>선점과 비선점 방식 모두 구현이 가능하다.\n<ul>\n<li>선점 : 새<strong>로 도착한 프로세스의 우선순위가 기존의 것보다 높으면 CPU 교체</strong> (SRTF)</li>\n<li>비선점 : 신경쓰지 않고 새로운 프로세스를 <strong>그저 레디큐 맨 앞에 배치</strong></li>\n</ul>\n</li>\n<li>우선순위가 낮은 프로세스는 계속 실행되지 못하는 <strong>기아(starvation) 현상</strong>이 발생하는데, 시간이 지날때마다 프로세스의 우선순위를 올려주는 <strong>에이징(Aging) 방식으로 해결 가능</strong></li>\n</ul>\n</li>\n<li><strong>RR</strong>(Round-Robin) Scheduling\n<ul>\n<li>각각의 프로세스는 <strong>Time quantum</strong>이라 불리는 짧은 시간을 부여받음.</li>\n<li>이 시간이 <strong>끝나면</strong>, 프로세스는 <strong>다른 프로세스로 무조건 교체되고</strong>(선점) 레디큐의 마지막으로 돌아간다.(FCFS의 측면)</li>\n<li>q초의 quantum을 가지는 n개의 프로세스가 있으면, q초마다 한번씩은 1/n의 CPU 타임을 보장받는다.</li>\n</ul>\n→ *<em>최대 (n-1)<em>q 초까지만 기다리면 무조건 보장받는다. 이를 통해서 waiting time의 upper bound를 보장받게 된다.</em></em>\n<ul>\n<li>q의 사이즈를 적절히 고르는 것이 중요하다.\n<ul>\n<li>q가 너무 <strong>크면</strong> → <strong>FCFS</strong>랑 다를게 없다.</li>\n<li>q가 너무 <strong>작으면</strong> → 잦은 컨텍스트 스위칭, 그로 인한 <strong>오버헤드가 커지기 때문에 throughput이 감소한다.</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Multi-Level Queue</strong>\n<ul>\n<li>레디큐를 두개 이상으로 구분해 <strong>I/O bound job</strong>과 <strong>CPU bound job</strong>으로 구분한다. 그 이유는 <strong>I/O bound job은 interaction이 많아서 response를 빨리 얻어야 하기 때문이다</strong>. (우선순위를 높여야겠지?)</li>\n<li>크게 두 분류로 나누는데 foreground와 background로 나눈다.\n<ul>\n<li>foreground : <strong>interactive</strong>하고 , I/O job 위주이며, <strong>RR 알고리즘</strong>으로 동작하여 <strong>response time</strong>을 높이는데 주력으로 둔다.</li>\n<li>background : <strong>batch job</strong>(CPU bound job)위주이며, <strong>FCFS</strong>로 동작하며 throughput을 높이는데 집중한다.</li>\n</ul>\n</li>\n<li>각 큐들은 독립적인 스케쥴링을 가지고 있고, <strong>foreground가 다 수행되어야 background를 선택한다.</strong>\n<ul>\n<li>그렇기 때문에 <strong>background job들은 기아현상</strong>이 발생할 수 있다. (계속 foreground로 들어오면)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>MLFQ</strong>\n<ul>\n<li>\n<p>프로세스들은 <strong>큐들 사이에서 서로 이동</strong>이 가능하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 589px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACHElEQVQoz2VT144aQRDk73nkB7gHg1gL6bizOV4wQSevWMAscEs6cs45BxHKqkZ7wvJIrekJXVPdXWNpt9toNBrodDpotVro9XowDANOpxMuRcHL6wt8Ph/8fj/C4TDU3yrisTiSySTy+TwqlQqKxSIymYzMllwuh36/j8lkgvF4LIAMdrvdeH72wPHNge8uBW8/vQj4A0j80fHxYcBms8kDJDMcDlEulxGJRGAplUqYzWZYrVbYbrfiky39xXyOerUm1mq00Ov05HwwHEBVVfFJwBzNZhMWvmAOsqSNRiNhS38+n0vgdDr9OqMtl0tZm/Hn8xnVahWWer2Oy+UiG6yn6Q8GAykFgxlIwMVigdVyhfV6g8PhgNPphOv1KoCciSWAXBDEpJ9IJPD0ZIfD6YTiUuDxeBD4FcB7+B0pPY3PzyK8b14UCgVhygzYUMZ9MeQgC9YhlUoJs2qlAk3VENNiyBlZGCkD7dZdFXa7XQBZbxLa7/f3Lj8CctxuN+x2O2nSer3GZrO524PPs+PxKPe73e7/KROQGywqJcA0CMaZxtrR2KBHYxZM9x9As0vcYCPM9iuKIjqkqEOhEDRNEzEzTQZSbnzM7DBlxjPRIResQa1WE+UHg0EBiMfjItZXzw8E/SERND9CNpuF1WqVJlABJMLsotHonSGLyQ3zCxEonU5Lc/SEDi2iIarFBEDXdQnkL2EM2dJIhCn/BWrlXz6/huLOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/1b6079a67d732c3bf73f5859f845dda9/b1665/mlq.png\"\n        srcset=\"/static/1b6079a67d732c3bf73f5859f845dda9/e9ff0/mlq.png 180w,\n/static/1b6079a67d732c3bf73f5859f845dda9/f21e7/mlq.png 360w,\n/static/1b6079a67d732c3bf73f5859f845dda9/b1665/mlq.png 589w\"\n        sizes=\"(max-width: 589px) 100vw, 589px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>새로운 프로세스는 q=8인 큐로 진입하고, <strong>큐 내부적으로는 FCFS</strong>의 행동을 취한다. <strong>Q1과 Q2의 작업이 있으면 선점한다.</strong></p>\n</li>\n<li>\n<p>CPU를 얻으면 8ms동안 수행되고, 그 안에 <strong>끝나지 않으면 Q1으로 강등당한다.</strong></p>\n</li>\n<li>\n<p>Q2에서 16ms동안 수행되고, 그 안에 <strong>끝나지 않으면, Q2로 강등당한다.</strong> 이런 방식을 취함으로써 <strong>Convoy Effect를 방지할 수 있다.</strong> (CPU bound job은 우선순위가 낮으니)</p>\n</li>\n<li>\n<p>단, <strong>yield</strong>와 같이 I/O 작업으로 인해 q가 소진되기전에 CPU를 포기하면 <strong>강등당하지 않고 우선순위를 그대로 유지한다.</strong></p>\n</li>\n<li>\n<p>MLFQ는 burst time이 짧은 <strong>대화형 작업들을 빨리 처리하려고 해 response time에서 강점을 보이지만 , CPU bound job들은 기아 현상을 겪을수 있다.</strong></p>\n<ul>\n<li>주기적으로 모든 작업의 우선순위를 <strong>상향조정</strong> 할 수 있다. 예를 들어 모두를 Q0로 올려보낸다. 이 과정에서 CPU bound job들도 조금이나마 작업을 진행할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p><strong>의도적인 I/O 작업 호출</strong>로 <strong>우선순위를 유지하는 프로세스가 있을 수 있다</strong>. 이 프로세스는 예를 들어 7ms가 지난 후 의미 없는 I/O 작업으로 우선순위를 유지한다.</p>\n<ul>\n<li>누적적인 <strong>CPU 사용 시간을 기록</strong>해서 방지한다. PCB 안에 기록하지 않을까..?</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"선점식-vs-비선점식\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%A0%90%EC%8B%9D-vs-%EB%B9%84%EC%84%A0%EC%A0%90%EC%8B%9D\" aria-label=\"선점식 vs 비선점식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>선점식 vs 비선점식</strong></h1>\n<ul>\n<li>선점식은 프로세스에게 한번 실행될때 제한된 시간만큼 CPU를 할당한다. 작업 도중에 자원을 반납당하고 ready 상태로 진입한다. 비선점식은 프로세스가 종료되거나, yield를 통해서나 I/O를 위해서 자발적으로 ready에 가지 않는 한 자원을 반납하지 않는다.</li>\n<li>선점식만 실행 중에 인터럽트를 허용한다.</li>\n<li>선점식은 프로세스의 우선순위에 따라 스케쥴링을 하는데, 우선순위가 낮은 프로세스가 선택받지 못하는 기아(starvation)현상이 일어날 수 있다. 비선점식은 수행시간이 긴 프로세스(CPU-bound job)이 스케쥴링되면, 그 뒤의 작업들이 오랜 기간동안 선택받지 못한다.</li>\n<li>선점식은 context-swtiching이 자주 일어나 이로 인한 오버헤드가 크고, 비선점식은 필수적인 context-switching을 제외하면 자주 일어나지 않아 오버헤드가 비교적 적다.</li>\n<li>선점식은 우선순위에 따른 유연성을 가지지만(예를 들어 우선순위 promotion을 진행하는 MLFQ) 비선점식은 그렇지 않다.</li>\n</ul>\n<p>이러한 특징때문에 interactive한 시스템에선 반응성 때문에 선점식을, batch job을 자주 수행하는 시스템에선 비선점식을 사용하곤 한다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\"><strong>프로세스의 상태</strong></a></p>\n</li>\n<li>\n<p><a href=\"#context-switching\"><strong>Context-switching?</strong></a></p>\n<ul>\n<li><a href=\"#process-context-switching-vs-thread-context-switching\"><strong>Process context switching vs Thread context switching</strong></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80\"><strong>CPU 스케쥴링 알고리즘이란?</strong></a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81%EC%9D%98-%EB%B0%9C%EC%83%9D%EA%B3%BC-%EB%AA%A9%EC%A0%81\">스케쥴링의 발생과 목적</a></li>\n<li><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">스케쥴링 알고리즘</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 25, 2021","title":"프로세스 스케쥴링 알고리즘","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/process-scheduling-algorithm/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/process-and-thread/","nextSlug":"/junior-student-challege-to-kakao-2022/","prevSlug":"/process-scheduling-algorithm/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}