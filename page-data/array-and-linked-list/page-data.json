{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/array-and-linked-list/",
    "result": {"data":{"cur":{"id":"37b121af-aaea-5b5c-96bd-dbe71d964439","html":"<h2 id=\"array\" style=\"position:relative;\"><a href=\"#array\" aria-label=\"array permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array</h2>\n<p>논리적 저장순서와 물리적 저장순서가 일치한다. 다시 말해서 <code class=\"language-text\">a[2]</code> 와 다음에 오는 <code class=\"language-text\">a[3]</code> 는 물리적으로 연결되어 있다.\n하지만, 하나의 Array의 크기가 너무 커 하나의 page(혹은 frame) 안에 다 못들어오는 경우에는 <strong>virtual adress는 <em>연속적</em>으로 이어져있지만, physical adress에서도 그렇다는 보장은 없다.</strong></p>\n<blockquote>\n<p>💡 하지만 physical adress와 virtual address에 관한 문제는 OS가 처리할 일이고 프로그래머에게 보이지 않는 추상계층이기에 우리가 깊게 생각할 필요는 없다고 생각한다.</p>\n</blockquote>\n<p>또, 한번 사이즈가 정해지면 변할 수 없다. 이를 해결하는 방법이 Dynamic Array다.</p>\n<ul>\n<li>조회 : 인덱스를 기반으로 한 접근이 가능하다. 인덱스를 알고 있다면 <code class=\"language-text\">O(1)</code>의 시간 내에 접근이 가능한데 , <strong>이것을 Random Access</strong>라고 한다.</li>\n<li>삽입 : Array의 특정 위치에 삽입을 할때는 원소를 넣고 끝나는 것이 아니라, 기존의 원소들을 shift 해주는 비용이 생기기 때문에 <code class=\"language-text\">O(n)</code>의 비용이 든다.</li>\n<li>삭제 : 삽입과 마찬가지로 shift의 비용 때문에 <code class=\"language-text\">O(n)</code>이 소요된다. 만약 shift를 해주지 않는다면 삭제를 한 곳에 빈 공간이 생기게 될것이고, contiguous한 Array의 특성이 깨진다.</li>\n</ul>\n<h2 id=\"arraylist\" style=\"position:relative;\"><a href=\"#arraylist\" aria-label=\"arraylist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ArrayList</h2>\n<p>Java 기준으로 primitive만 저장 할 수 있는 Array와는 다르게 Object도 가능하다. ArrayList에 add를 사용하여 primitive한 데이터를 집어넣을때는 Auto-boxing이 사용된다. 또 제네릭이 사용 가능하다.</p>\n<p>하지만 가장 큰 차이점은 <strong>ArrayList는 Dynamic Array라는 것이다.</strong> ArrayList는 내부적으로 Array와 사이즈 정보를 가지고 있다.</p>\n<p>Array의 초기 사이즈가 고정되어 있고 늘어나지 않는것에 비해서, ArrayList는 add를 이용해서 원소를 삽입하다가 원소가 가득차게 되면, 내부적인 Array의 크기를 두배 혹은 1.5배 정도로 늘여서 기존의 원소들을 다 옮기게 된다.</p>\n<p>이 과정에서의 시간 복잡도를 고민해보면, 기존 원소의 개수가 0개이고 사이즈가 <code class=\"language-text\">n</code>개라고 해보자.\n이때 <code class=\"language-text\">n</code>번의 add를 할때까지 내부 Array는 가득차지 않고 각각의 삽입연산의 시간복잡도는 <code class=\"language-text\">O(1)</code>이다.</p>\n<p>하지만 한번 더 add를 한다면 내부 Array를 두배로 늘리고 , 기존의 <code class=\"language-text\">n</code>개의 원소들을 모두 옮겨야 하니 <code class=\"language-text\">O(n)</code>의 시간이 소요된다.\n<code class=\"language-text\">n+1</code>번의 add에 걸리는 시간복잡도가 <code class=\"language-text\">O(1)*n+O(n)</code>이니, 평균적인 시간 복잡도는 <code class=\"language-text\">(O(1)*n+O(n))/(n+1)=O(1)</code>이 되는 것이다.</p>\n<p>이것을 분할 상환(Amortized Analysis)라고 한다.</p>\n<h2 id=\"linkedlist\" style=\"position:relative;\"><a href=\"#linkedlist\" aria-label=\"linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList</h2>\n<p>LinkedList는 불연속적인 데이터들의 집합이다. LinkedList는 Node라고 불리는 내부구조들의 chain으로 구성되어 있는데 구조는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\tNode<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이처럼 Node는 원소와 그 다음 Node를 가리키는 포인터로 구성된다. 각각의 원소들은 오직 자기 다음에 오는 Node의 정보만을 가리키고 있는 것이다.(Singly Linked List 기준). 물론 <code class=\"language-text\">next</code> 라는 포인터를 하나 더 유지하는 메모리 사용량도 무시할 순 없다.</p>\n<p>이것을 이용하여 삽입과 삭제를 <code class=\"language-text\">O(1)</code>만에 할 수 있다. 삽입을 할때는 단순히 <code class=\"language-text\">next</code> 만 교체하면 되고, 삭제 역시 마찬가지다.</p>\n<ul>\n<li>조회 : k번째 원소를 찾기 위해서는  <code class=\"language-text\">O(k)</code>만큼의 시간이 소요된다.</li>\n<li>삽입 : 동작 자체만으로는 <code class=\"language-text\">O(1)</code>이 걸리지만, 원하는 위치를 찾기 위해 LinkedList를 순회해야 하기 때문에 평균적으로 <code class=\"language-text\">O(n)</code>이 소요된다. 단, 맨 앞에 삽입하는 경우는 <code class=\"language-text\">O(1)</code>이 소요된다.</li>\n<li>삭제 : 삽입과 동일. 맨 앞 삭제는 <code class=\"language-text\">O(1)</code>, 맨 뒤 삭제는 <code class=\"language-text\">tail</code> 에 대한 정보가 있어도 <code class=\"language-text\">O(n)</code>이 걸리는데 그 이유는 마지막 원소를 가리키는 직전 원소를 찾기 위해 <code class=\"language-text\">O(n)</code>의 시간이 걸리기 때문이다.</li>\n</ul>\n<p>그럼에도 LinkedList가 중요한 이유는 Tree 구조를 이해할때 필수적이기 때문이다.</p>\n<h3 id=\"doubly-linked-list\" style=\"position:relative;\"><a href=\"#doubly-linked-list\" aria-label=\"doubly linked list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Doubly Linked List</h3>\n<p>앞서 살펴본 Linked List는 일반적으로 Singly Linked List를 지칭하는 말이다. Singly Linked List는 아래처럼 다음 원소를 가리키는 <code class=\"language-text\">next</code> 포인터 하나만을 가지고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\tNode<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이에 반해서 Doubly Linked List는 <code class=\"language-text\">next</code> 포인터와 그 직전 원소를 가리키는 <code class=\"language-text\">prev</code> 포인터 역시 가지고 있는 아래와 같은 구조를 띈다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\tNode<span class=\"token operator\">*</span> next<span class=\"token punctuation\">;</span>\n\tNode<span class=\"token operator\">*</span> prev<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또 일반 Singly Linked List와는 다르게 헤드 역시 Node로 이루어져 있다.</p>\n<ul>\n<li>\n<p>삽입 : new_node를 삽입하는 과정인데 살펴볼 필요가 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 465px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.222222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABgUlEQVQoz4WS/0sbQRDF7///SwqWqASvKBYFf4jWREETiTa2NWnOYBPvS27vdmf37lPuUuR6sXRgWGb3zePNm/UARAxP0ynL1aoqKcvyLdvRfHsvvZJNUxIlFNZtERRlSeEchdYURcH/wqv4VskrZ+NzepNLLr5dcT655Hh0RhRHGBHyJEHPA3KtEWN4jUL636/pPfZr/MXjgMPhKT9fAjy1TrmffWVn0OXT/Qn+wwl+r8PHqwN+LZeIteg0JV8s0GLQuebH/ImD3i7+8Aj/4ZT9m0M+XHeZLeZ4lUznHGIFYwURIVs8o1VWj1ARWqORMMQ6V2O1MaggQHS+6bFS39cjv2c8eY7Jsn/6ZLTGpQpantZLaW6uCqVU7RliidcRt9MRt7O7TU5H9CcDXJrilGJd4Vqb95rsza1WhLPJkP3+Ht3xMd3xZ/wbn86XDhLFVUONpfW9vLbk+vxTW2cJXp5RkhGrhDhLyEX/hWlbtqWwOX4UhgTzgExlW169KWsp/A3KKwBoS6V3QwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/9ec5b65f5a55161515d9d75b9fab7e31/9ff85/insert.png\"\n        srcset=\"/static/9ec5b65f5a55161515d9d75b9fab7e31/e9ff0/insert.png 180w,\n/static/9ec5b65f5a55161515d9d75b9fab7e31/f21e7/insert.png 360w,\n/static/9ec5b65f5a55161515d9d75b9fab7e31/9ff85/insert.png 465w\"\n        sizes=\"(max-width: 465px) 100vw, 465px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>new_node의 <code class=\"language-text\">prev</code>가 before을 가리키게 한다.</li>\n<li>new_node의 <code class=\"language-text\">next</code>가 before의 <code class=\"language-text\">next</code>를 가리키게 한다.</li>\n<li>before의 <code class=\"language-text\">next</code>의 <code class=\"language-text\">prev</code>가 new_node를 가리키게 한다.</li>\n<li>before의 <code class=\"language-text\">next</code>가 new_node를 가리키게 한다.</li>\n</ol>\n<p>이 과정에서 순서에 유의해야 하는데, 1번은 언제 일어나도 상관이 없다.\n하지만 2번,3번의 경우 4번보다 먼저 일어나야 하는데, 그렇지 않으면 before의 <code class=\"language-text\">next</code>가 가리키는 node를 접근 할 방법이 없어지기 때문이다. 또 당연히 첫 순서로 실행되어서는 안된다.</p>\n</li>\n<li>\n<p>삭제 : removed node를 삭제하려는 과정이다. removed의 이중 연결을 해제해주고, removed의 <code class=\"language-text\">next</code>와 <code class=\"language-text\">prev</code>를 서로 연결시켜준다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 541px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABa0lEQVQoz22Rb2/TMBDG8/2/CS/QJKatK7QrDE0MOtqmqhqgjEY04c3+FM1JY59j/1AcOrrSR3qsO/vu/NxdBOCcwxiD1jqwMhpTWwLqGlNVSKWDHeI96J34JteICW9RLZZJOuNo0qGTDDhLBrz6fMybURfE4axgqyrQWwEjpGnC6bTL6bxPZ37Oy9EJL4bHbFRJpDcVSfaNi8UV1/mUDz+u6Y37LPKvoAUvQqUUWhX4RoVYVtkN/VGP4Srm088J779/JM4TalsTsQfRhvXdQ7D90/EXvnWstdzf3nEIkfeehs0cG5j1GjWJsUq1ySKIMYgItbU479FZhponuLoO/21rNIzYudjaRaEoHhVxOuNk2uN8cUkvueBo3KEbv0X9fgyLYK9YUMizjv4VLYuS0c2Us9mAq2zM5XLI6y/viFcJzjr2hTy1fKjYFlYsD7f3reOez2o3btf+T2HLdht5/ovlMqUsNwfbO6TwD4qGsVHFw3W4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/3ff309f03e3a9cc570591c2c2562a1a0/9d576/remove.png\"\n        srcset=\"/static/3ff309f03e3a9cc570591c2c2562a1a0/e9ff0/remove.png 180w,\n/static/3ff309f03e3a9cc570591c2c2562a1a0/f21e7/remove.png 360w,\n/static/3ff309f03e3a9cc570591c2c2562a1a0/9d576/remove.png 541w\"\n        sizes=\"(max-width: 541px) 100vw, 541px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>removed의 prev가 removed의 <code class=\"language-text\">next</code>를 가리키게 한다.</li>\n<li>removed의 next가 removed의 <code class=\"language-text\">prev</code>를 가리키게 한다.</li>\n</ol>\n<p>두 연산은 순서를 바꿔도 상관이 없다.</p>\n</li>\n<li>\n<p>조회 : Doubly Linked List에는 <code class=\"language-text\">prev</code> 포인터가 있기 때문에, 최악의 경우 <code class=\"language-text\">O(n)</code>이 소모되었던 Singly Linked List와는 다르게 <code class=\"language-text\">O(n/2)</code>의 시간 안에 찾을 수 있다. 찾으려는 원소의 인덱스의 범위에 따라 <code class=\"language-text\">end</code>에서 <code class=\"language-text\">prev</code> 포인터를 이용해서 돌아가거나, <code class=\"language-text\">head</code>에서 <code class=\"language-text\">next</code> 포인터를 이용해 찾는 방법이다. 또, 직전 원소를 찾는 before도 쉽게 구현 할 수 있다.</p>\n</li>\n</ul>\n<p>이런 장점을 이용해서 연속적인 탐색과 접근에 유리하지만 , 구현이 상대적으로 복잡하고 <code class=\"language-text\">prev</code> 포인터를 유지해야 하기 때문에 메모리 사용량이 2배 정도 증가한다.</p>\n<p>하지만 사용성때문에 플레이리스트, 되돌리기와 같은 기능에 사용되는 자료구조다.</p>\n<h2 id=\"array-vs-linkedlist\" style=\"position:relative;\"><a href=\"#array-vs-linkedlist\" aria-label=\"array vs linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array vs LinkedList</h2>\n<p>일반론적인 얘기에서 조회는 <strong>Random Access</strong>를 지원하는 Array가 <code class=\"language-text\">O(1)</code>의 시간복잡도를 가지고 있어서 LinkedList보다는 빠르다.</p>\n<p>삽입과 삭제는 모두 LinkedList가 빠르다고 하지만 이유에 대해서 조금 더 면밀하게 살펴볼 필요가 있다.</p>\n<p><em>빠르다</em> 라고 하는 것은 삽입과 삭제 그 자체에 주목하는 부분이다.\n만약 바꿔야 할(삽입 혹은 삭제) 위치를 정확히 아는 상태에서는 Array보다 LinkedList가 항상 빠르다. 단순히 <code class=\"language-text\">next</code> 포인터만 변경해주면 되기 때문이다.</p>\n<p>평균적인 경우에서는 Linkedlist는 <code class=\"language-text\">O(n/2)</code>개의 원소들을 살펴보아야 하고, Array도 동일한 원소의 개수들을 shift 해줘야하니 비슷하다.</p>\n<p>그렇기 때문에 Usage에 따라 두 자료구조를 적절히 아래와 같이 선택해야 한다.</p>\n<ul>\n<li>삽입과 삭제가 빈번하게 일어나는 경우 →  <strong>LinkedList</strong></li>\n<li>데이터에 대한 접근(Access)가 빈번하게 일어나는 경우 → <strong>Array</strong></li>\n</ul>\n<h3 id=\"cache\" style=\"position:relative;\"><a href=\"#cache\" aria-label=\"cache permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cache</h3>\n<p>또 한가지 더 깊게 생각해보자면, <strong>캐싱</strong>과 연관이 있다. 정확히 말하면 <strong>Spatial Locality.</strong></p>\n<p>CPU가 일을 처리할때는 메모리에서 필요한 데이터를 로드하고, 일부를 캐싱한다. 그 캐시 안에 들어있는 요소들을 레지스터로 가져와서 일을 처리하는데, 이 과정에서 차이가 발생한다.</p>\n<p>LinkedList는 데이터들의 주솟값들이 서로 연속적이지 않기 때문에, loop를 돌때 (Iterator든 뭐든) 매번 다음 메모리 주소를 찾아야 하고 , CPU가 메모리에 계속적으로 접근해서 로드하는 과정이 생길 수 있다.</p>\n<p><strong>불필요한 오버헤드가 생기는 것이다.</strong></p>\n<p>반대로 배열은 연결된 데이터 구조를 가지기 때문에, 특정 영역에 존재하는 데이터들을 한번에 로드해와서 bulk들을 캐싱한다.\n그렇기에 loop를 돌때도 Array가 매우 크지 않으면 이미 캐시되어 있는 리소스들을 사용할 수 있게 되고 LinkedList와 비교했을 때 상대적으로 적은 메모리 접근이 일어나니 더 빠르다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#array\">Array</a></p>\n</li>\n<li>\n<p><a href=\"#arraylist\">ArrayList</a></p>\n</li>\n<li>\n<p><a href=\"#linkedlist\">LinkedList</a></p>\n<ul>\n<li><a href=\"#doubly-linked-list\">Doubly Linked List</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#array-vs-linkedlist\">Array vs LinkedList</a></p>\n<ul>\n<li><a href=\"#cache\">Cache</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"Array 논리적 저장순서와 물리적 저장순서가 일치한다. 다시 말해서  와 다음에 오는  는 물리적으로 연결되어 있다.\n하지만, 하나의 Array의 크기가 너무 커 하나의 page(혹은 frame) 안에 다 못들어오는 경우에는 virtual adress는 연속적으로 이어져있지만, physical adress에서도 그렇다는 보장은 없다. 💡 하지만 physical adress와 virtual address에 관한 문제는 OS가 처리할 일이고 프로그래머에게 보이지 않는 추상계층이기에 우리가 깊게 생각할 필요는 없다고 생각한다. 또, 한번 사이즈가 정해지면 변할 수 없다. 이를 해결하는 방법이 Dynamic Array다. 조회 : 인덱스를 기반으로 한 접근이 가능하다. 인덱스를 알고 있다면 의 시간 내에 접근이 가능한데 , 이것을 Random Access라고 한다. 삽입 : Array의 특정 위치에 삽입을 할때는 원소를 넣고 끝나는 것이 아니라, 기존의 원소들을 shift 해주는 비용이…","frontmatter":{"date":"January 24, 2022","title":"Array와 Linked List","categories":"자료구조","author":"weasel","emoji":"📓"},"fields":{"slug":"/array-and-linked-list/"}},"next":{"id":"e48d5d5a-bf06-58d2-8af3-e6be8b866fd0","html":"<p>운영체제의 핵심 부분인 하나인 메모리 관리에 대해서 적겠다.</p>\n<p>대략 3편으로 구성되며 페이징,가상메모리,페이지 교체 알고리즘 순이다.</p>\n<h2 id=\"mmu\" style=\"position:relative;\"><a href=\"#mmu\" aria-label=\"mmu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MMU</h2>\n<p>CPU는 프로세스를 구동할 때 PC를 참조해서 다음 명령어를 메모리에서 가져온다. 명령어를 참고해 필요한 데이터가 있으면 메모리에서 가져오는데 이때 주소체계가 서로 다르다.</p>\n<p>아래의 그림처럼 base와 limit 레지스터 안에 있는 값들을 조합해서 CPU가 사용하는 주소(<strong>논리 주소</strong>)와 실제 메모리 주소(<strong>물리 주소</strong>)를 구할 수 있다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 698px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABm0lEQVQ4y5VT2W6DMBDM//9QFVVVlV5JlFZV3xoREsDmChQKNuBAYKp1DoX0tjRi2cXD7Hg9SNMUnLtwbAsmE1h6gOPYMJmC5TeYz19hLBawLAumacK27WO8Wq1gGAaWy6UGYwyDzWaDoiggpYAsGmQSOs5EjTRXeE9TCCE0siyDlBJ5nmtQ7hAfagN8Wt0x8jwXk+kMV1fXuLsfw/cD/LYGXdfhFLTquoaqFBh3cf8wwcXFELd3D7Adpuvb7Vajbft7CT2FB0KS7tgOkiQBWULvVVWhLMvP/XRdX+FXRXqSAiIgf4Mg0KSFlDrn+z4Y47p2TvqtQjrJOI41AZlPm9fhGlEUYTZ7xGh0gyRJfyY8L9abeqfI8zVhU9c6Tz+Io+j4/a8KC1noeSOF5GHTNFBKIVpHOjceTzEcXiIMw7+1TP4Rwc5DCZdzyH3bRE6tcs57nv9ISGNDm/NcQJQV3ulZlJD7Q/j3KdPkc8fG3ItxGyiMQ4Ubr8IiFnrw27bV+LNCukYuY7DCNzyHEi+hwJMvwFO5J+xfhFPCD7eM7DDg7OotAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"base_limit\"\n        title=\"base_limit\"\n        src=\"/static/53293237460e0580fd3e06096cae4618/487bb/base_limit.png\"\n        srcset=\"/static/53293237460e0580fd3e06096cae4618/e9ff0/base_limit.png 180w,\n/static/53293237460e0580fd3e06096cae4618/f21e7/base_limit.png 360w,\n/static/53293237460e0580fd3e06096cae4618/487bb/base_limit.png 698w\"\n        sizes=\"(max-width: 698px) 100vw, 698px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그러면 왜 두 주소를 구분하였을까?</p>\n<p><strong>가장 큰 이유는 보안이다.</strong> Limit 레지스터를 둠으로써, P1이 P2의 메모리 영역을 참조하는 Memory Illegal Access를 방지하는 Protection의 기능을 수행한다.</p>\n<p>MMU는 Memory-Management Unit의 약자로 위에서 말한 <strong>논리주소를 물리주소로 대응</strong>시켜주는 HW 장치이다.</p>\n<p>MMU 방식에서는 <strong>relocation 레지스터</strong>가 존재하는데, 프로세스가 메모리 주소를 만들때마다 relocation 레지스터 안의 값이 더해지고 이를 통해서 메모리에 접근할 수 있게 된다.</p>\n<blockquote>\n<p>base 레지스터와 역할이 동일하다고 생각하면 된다.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABW0lEQVQ4y6WT246CQAyGef+XWq+MMSGREC84JAh4ADkLCojQzd/NsCOL64VNyDB0+rX9Oyj0gV0uF9rv93Q+n+l4PFIURaQMw0CvnsfjQbfbjZqmGVdY3/e85nlOrutSEAQMDsOQFDjmYLDr9UpJkpBhGBwAwBToed4IRKWKCBYm7wFEW6vViispy/Lp7CxQOJFVwNAq9mgzTVPabDZkWeZY4f1+HzUEEK0+AYui4AoOhwNDlsslbbdbDhDCx3HM76fTiRZfCwYhGeIwEN/3f4HIsF6vSdM0yvOCLMvig/iOd3y3bXucpK7rDHYch/2qqpJpmj9TBrCqKj6ADDBMs+s6quuaW0d10BOP6AgGTf9U+N9QRKA8BNmyLJvXcHpdxAo9AYW20Asavr02c3+ADEfrnuuxLFOfAKJCJH0JnGtf3svA3W7HGgrw2wqxyndU9uE+onJIg4G1bUvfQ0rofzCBvQ0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mmu\"\n        title=\"mmu\"\n        src=\"/static/a464cc4a555c8d81e7c9044675a0c804/37523/mmu.png\"\n        srcset=\"/static/a464cc4a555c8d81e7c9044675a0c804/e9ff0/mmu.png 180w,\n/static/a464cc4a555c8d81e7c9044675a0c804/f21e7/mmu.png 360w,\n/static/a464cc4a555c8d81e7c9044675a0c804/37523/mmu.png 720w,\n/static/a464cc4a555c8d81e7c9044675a0c804/f1901/mmu.png 942w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"연속적인-할당contiguous-allocation\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D%EC%A0%81%EC%9D%B8-%ED%95%A0%EB%8B%B9contiguous-allocation\" aria-label=\"연속적인 할당contiguous allocation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속적인 할당(Contiguous Allocation)</h2>\n<p>메모리에 프로그램을 연속적으로 할당하는 방법이다. 간단하게 말해서 아래에서부터 차례차례 채워가는 방식. 메모리를 연속적으로 사용하기 때문에 간단한 MMU만으로 구현할 수 있다.</p>\n<p>일반적으로 커널은 낮은 메모리주소에 배치되고, 유저 프로세스는 높아지는 메모리 주소를 가진다.</p>\n<p>또 커널을 제외한 메모리 영역을 하나로 보는 방식과 여러개의 파티션으로 보는 방식이 있다.</p>\n<p>여러개의 파티션으로 할당하는 방법에서는 다수의 고정된 크기의 파티션으로 나누어져 있고, 2개 이상의 파티션에 할당할때는 합병(merge)해서 할당한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiUlEQVQoz42R2ZKiUBBE+f/fmumZMUJlAgVFEFlEmu3ilU2Ey5loZnvtiqi3zIo6mZrj+nx527De7Pj6tmajm2x1k2/ftxi7I39nnudPrabUhOs6rFY/OBwO6FsdwzAwzT3r9RrbdhCiQqmZz4w2TRN1XVMKQSne8QKbLI+Q8k5dS8Krix+eGF7tYngOD4TM6J93lFIo9ULWOY+mYBx7tH9IQC4i4tQir1yUGlHzi7S0ycSJpssWnZAht9SivHt80A1Ds3jS4kjblWiFkDRdT9sNpGVILhyEvDBNL9quw7AMzOOe9yxZDkaJy9ZaESX28kbbP9ifNtiXn7S9QNvZPkGc0j9HKnmjrFxkHdD2krwslgy9s4cfRrR9gx96BMFHDGdkLSmqFMff4V9NHk35H1kpKEREVp4Qd49JDTRtw97acbAt4iRedK53xjqY2I7NOI1U9wrd0NlZBmmefrSsUPPvBnOREMQn0iJYMhzHgeDmECUOdSv+aGIuV5tchAvyc2gXT5ye6XrJL9elWmhPvz4wAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"multiple\"\n        title=\"multiple\"\n        src=\"/static/daa64d9681c0e3b5e19c2c0a0bb87311/37523/multiple.png\"\n        srcset=\"/static/daa64d9681c0e3b5e19c2c0a0bb87311/e9ff0/multiple.png 180w,\n/static/daa64d9681c0e3b5e19c2c0a0bb87311/f21e7/multiple.png 360w,\n/static/daa64d9681c0e3b5e19c2c0a0bb87311/37523/multiple.png 720w,\n/static/daa64d9681c0e3b5e19c2c0a0bb87311/302a4/multiple.png 1080w,\n/static/daa64d9681c0e3b5e19c2c0a0bb87311/cdef6/multiple.png 1163w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그런데 그림에서 마지막 단계를 잘보면 P10과 P2 사이의 빈 공간이 보인다.\n이것을 <strong>Hole</strong>이라고 하는데, 단순히 말해서 할당가능한 메모리의 영역이다.</p>\n<p>이 Hole은 크기가 커서 프로세스를 할당받을 정도가 되면 문제가 되지 않지만, 그 크기가 작을때는 <strong>파편화</strong> 문제가 생길 수 있다.</p>\n<h2 id=\"파편화-fragmentation\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8E%B8%ED%99%94-fragmentation\" aria-label=\"파편화 fragmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파편화 (Fragmentation)</h2>\n<p>파편화 혹은 단편화는 메모리 내에서 할당가능한 영역이 존재하지만, 할당이 불가능한 상태를 의미한다. 두가지 종류가 있다.</p>\n<ul>\n<li><strong>내부 파편화</strong>\n<ul>\n<li>\n<p>할당을 하는 단위가 존재할때 생긴다.</p>\n</li>\n<li>\n<p>프로그램이 <strong>필요한 사이즈보다 더 큰 메모리가 할당</strong>되면서 <strong>파티션 내부적</strong>으로 <strong>메모리 공간이 낭비</strong>되는 상황</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 380px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 109.44444444444446%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD5ElEQVQ4y52VfUyVVRzHjzPBP8KARlr/9LLVbG01wkGgVquJLE3MLNcq2ly8ielwpU6trbW5IhWbreCCttYUWHWRF0nuBYLLa/ImIslSiAuXO2wC3tfnwn3u/bTneS6XV/ujZ/vunPM953ye3znnd3YE//Pz+/1L+sLtkdC16jnZWsTp1hJygypWvVOtxUHvdFsJOc3nKe6sDkI1zQGO2yZZdS4ZUfQK4kIi4sKmgBIRxa8hipNmvaLNiJ82En0+TZ3sWwo4Yb/Lo0XvIcq2E1r6JstL3yCs7B2erExl3W/7ib+cTWjpDu4r3cHKizsRv27lJf2B+cC5S56w3SWyZBeicguiPBlRvg1RkRzQdkTlTkT567P+xUTW6T9aAJxFCofTyaFzn5Ne8AlZhYfYE1BmoMwoPBj09p49zId52XxV8s38PZwHnJxk+Onn8N4fiRS5BiliNZ7wh5AeiEIKj8KjlIoXsRrpwUeYCgljMGkLXjVEXxAaBNonJrA8vAaEQBYCvxBMh6zA8sRjDDz7DKNrn1J9n6JlQh03GB83Hzh3D+0T41gjItWBM1Kg7pAQnCtDcKwKm9enaCgmekGEc4BOm43ryduwxsUysmE9I+sTsCTEM/pCHKNximJVT9XGDYw8H01fehryvZbsdHs4+EMzad83kZmvKUMpdc1kFTSTqQu085vYo2tm97cmvvy5fUEezkKFzSnx1hcGXj1cTdJRA5uOVLP1MyO7jteSmltD6qlaNh81kHikmqRjBl78+DJ7z5jueR2F3ekmI9fIuzl1pHxdx/uKcmpJyTGSkmNg9wmj2lb8D07U8fbxGo6dbcQluXF7PEiSxNT01GyESh529f2NeczNgMWG+baLlq6/MDR2U9/Wxy9VJrr7LZjHXAyM2hmwOrjaN0D/8Bi9N/6kqdlER2c7Xq9XA7pcDloqPqX70j66LmWr6qjYR3tZFn/oM2jTp9NZuT/Qd4DO8iyuGE7i9SlnIiP7vMiyPBuh3TaOtTwK6gX+OgGKfhf46gWyKRS/aYXmzahWMFQVq50yvsV76LBPYq16HBoF/oYQqF+G3BSOu20tzisxODoSNL9hOTSEqj8zV7+M168BF52yEqG5NBJqBNMGTR6jYMqgSQrUvUqfUSBXC26VxywCBvPQ43Fzs/NHhru+w9yVh7k7D0uPjtFrBVh6CrD26rD2FjLcnYe5K5+hzjMM9ui16zYDmwtcKp/sLh93Jj3YnD5u33Hxz7gL/+KkY6lHQKgh+2T8Pi/4ZbzTEv3917nWe5VbN2/Q1mqipaUBt8uhLdHn1cbPjXARMGDe6+FZ+DD915x/AWmzg8onJNYUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/4d25a9bbdf14f1297b598c1f475a84f6/3f520/1.png\"\n        srcset=\"/static/4d25a9bbdf14f1297b598c1f475a84f6/e9ff0/1.png 180w,\n/static/4d25a9bbdf14f1297b598c1f475a84f6/f21e7/1.png 360w,\n/static/4d25a9bbdf14f1297b598c1f475a84f6/3f520/1.png 380w\"\n        sizes=\"(max-width: 380px) 100vw, 380px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ul>\n</li>\n<li><strong>외부 파편화</strong>\n<ul>\n<li>\n<p>남아있는 메모리가 흩어져 있어서 <strong>총 메모리 양은 할당할 수 있을 정도인데 실제론 할당할 수 없을때</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 380px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACaklEQVQ4y42T20tUURSHN/jUvxP0EJmXShsHRBSCsuzFl7IXg3DQsSh8EIsIghQTgop6M5wu44zM0SJpbPCSppaZlzMXx3Gam3rOOJdzvpgzOSRJzIZv77Vg8WOvtX9bWD8OcPxdK1XDFsxOKzWOdk472ih908qEPEduZXUNHZ1ilihzdSLeViHsdYiRRoTzPMJei7BVY1sZN4oyWhZdL1Jw6GEXfc0mBq410H+1jsdX6hhoqae32czyjMco0jTNECxGVGxXnAIhDLSSIyBKCnliyGYU6ZlM/ixCVCx1WlkvO8lqjYmfOcxm1kxnWa4sZ9P9qVC4L/Y/DMFgPE4KUIHkH/bjJa+fDb8PJREran45UeGVA+wk9ojHFBKxXYN4TEXZVpHcc7z4ME8olW85uZdC2Uuj/kUuV5Ip0pn8w4nVcQubI0fZcJXhl87glyoJuk7gdxwjGnDz4+kTPDctJFfmuPvqKw13HDT1SFzodtHY7eJSj8S5LgfueTnf8uZoBQwL0k6BIglUl0BzCNI2wa8tF7RcJiMEY4ODWJ5/obrDSX2XRNO9MS72jFF7W8J8awTnxAIB3xpiZXYIefoR6zP9yNO9yNN9Rrw22YvPu4DnwX0m21qJL07R/myK0us2TFZ7geoOO+U3bLgml3MGQ4Qju/mBHjLk1+9neTk6hS+xY+RL8hbuxQ0834N8/pYnF7sXA4RjeR0RCPiIRraIRsIFYtEwkXAIrz+AnklBJm2Yu6hX3v8JyaSKqqooioKi7JLNZg/eXNfRNJ2sph1KwYe5LZ1OEwwGDUKhTbxemVQq9c/vONzMB439G90vz+rZV6N5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/e6c3534022ed6a8e9e75a1e42a4d30ac/3f520/2.png\"\n        srcset=\"/static/e6c3534022ed6a8e9e75a1e42a4d30ac/e9ff0/2.png 180w,\n/static/e6c3534022ed6a8e9e75a1e42a4d30ac/f21e7/2.png 360w,\n/static/e6c3534022ed6a8e9e75a1e42a4d30ac/3f520/2.png 380w\"\n        sizes=\"(max-width: 380px) 100vw, 380px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>내부 파편화와는 다르게 할당을 하는 단위가 존재해도 생기고, 존재하지 않아도 생길 수 있다.</p>\n<ul>\n<li>존재할때는 왜 생길까?\n<ul>\n<li>B프로세스의 다음 메모리 공간을 보자.<br>\n원래는 프로세스가 들어갈 자리인데도 그 프로세스가 끝나고 D가 끝나지 않았다면 C는 들어가지 못한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>즉, 사용가능한 메모리 영역은 있는데, <strong>연속적이지 않은것이다.</strong></p>\n</li>\n<li>\n<p><strong>압축</strong>(compaction) 기법을 통해서 해결 할 수 있는데, <strong>오버헤드가 크다.</strong> (JVM GC의 mark-and-compaction 생각해보자.)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"세그멘테이션-segmentation\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-segmentation\" aria-label=\"세그멘테이션 segmentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그멘테이션 (Segmentation)</h2>\n<p>페이징 방법에서는 가상 메모리를 서로 <strong>같은</strong> 크기로 분할했지만, 세그먼테이션 방법에서는 서로 크기가 다른 논리적 단위인 세그먼트로 분할한다.</p>\n<p>세그먼트들의 크기가 각각 다르기 때문에(code를 위한것,데이터를 위한것…) 필요할때마다 빈 공간을 찾아서 해결한다.</p>\n<p>프로세스가 딱 필요한 만큼만 메모리를 배정해주기 때문에 내부파편화 문제는 없지만, <strong>외부 파편화 문제는 존재한다.</strong></p>\n<ul>\n<li>아래 그림을 보자. (a)번 상황에서 Segement 1이 빠지고 S7이 들어오면, S7이 더 작기 때문에 공간에는 맞지만 S2와 S7 사이에 빈공간이 생긴다.<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 602px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB4UlEQVQozz2T167CMBBE8/8fxAMIIUAIiQeq6BC4lCTUhBK6mKuzKIlk7F2vZ2fGxgnDUNvt1sbr9dLpdLL1brfT+/2W53maTCY2Ho+HfN/XeDy2+H6/a7PZaDqd2iB2giBQs9nUbDbT7XYzsHa7rfl8bg1YZzIZ5fN5Xa9X9Xo9ZbNZVSoVQabVaqlQKCiXy+lwOMjhB6AoiuwAM0xgGsexHVoul8aU/GKxUK1WU7fbtRpm4lKppOPxKAfKg8HADgG83+81HA61Wq0MgHg0GhnQ8/lUp9NRsVhUuVw2RkgHrFqt6nK5/ABd1zUAGFGE3PV6nTZgH0AawBRG+Jj4jS2Qot48hDYgJGgACzwFgBifkktJAFAEIA1gR84AOUBxwohOyMH08/lsMZLIIanf76cSeQkoIsctGyCmI4cNrp2OMEqeATGvAB/xkMbso4gLBJSbTwEBgwUsYZAA4BEFxPV63WpoAGCj0TBfIZPUYxuvxKGIDjzY7/drIMR4yxfH13Sf73aL0/jzfqf1AH8+HzmLv4U8z5fvByabt7Tb7rRee5aPwsiY43XgB/K9wGTG8c3qN5utouikMIx0vz/k4IXrzn5jOjOg+fxP06mrYxjZ34/BDTNQhJfkmMn91i9j+A9nsXKkCM571AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/b1dbd33cde81c96667abffe610fab2d9/32056/3.png\"\n        srcset=\"/static/b1dbd33cde81c96667abffe610fab2d9/e9ff0/3.png 180w,\n/static/b1dbd33cde81c96667abffe610fab2d9/f21e7/3.png 360w,\n/static/b1dbd33cde81c96667abffe610fab2d9/32056/3.png 602w\"\n        sizes=\"(max-width: 602px) 100vw, 602px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></li>\n<li>비슷한 상황이 S4가 나가고 S5가 들어오는 상황에서도 생기고 3과 6의 상황에서도 생긴다.</li>\n</ul>\n<p>이런 빈 공간이 생기기 때문에 <strong>세그멘테이션은 외부파편화 문제</strong>가 여전히 존재한다.</p>\n<h2 id=\"페이징-paging\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-paging\" aria-label=\"페이징 paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 (Paging)</h2>\n<p><strong>논리적 메모리 주소 공간이 물리적인 메모리 공간에서 비연속적으로 배치하게끔 허용</strong>하는 기법을 의미한다.</p>\n<p>물리메모리를 고정된 사이즈의 <strong>프레임(Frame)</strong> 이라는 크기로 나누고, 동일한 사이즈로 논리메모리를 <strong>페이지(Page)</strong> 로 나눈다.</p>\n<p>즉 , 프로세스가 일정량의 페이지를 요구하면, 같은 양의 충분한 프레임을 찾아서 매치시켜준다. 그렇기 때문에 허용가능한 프레임을 추적해야한다.</p>\n<p>또 페이지와 매치되는 프레임을 찾기 위해 <strong>페이지 테이블</strong>을 관리해야 한다.</p>\n<p>하지만 외부 파편화 문제는 해결할 수 있지만(비연속적으로 배치하니) <strong>내부 파편화 문제는 여전히 존재한다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACqElEQVQoz3WT22/iRhTG8zf3vQ/7UqnaSiut2j7sQzfKUtQbDQlRkna33e2WBCUGG0IABwjGFzw2l0C4GBtj/yqbbPvUI535zoxmPp35vpk927bRNA2r0cCQygwUBUuWMSsV7H4f4bjYtsBxHFzXYfiUydxxxL8ohI3neewBBGufSalE+/SUai5Hs1Dg/uyMSdNmuoDpA4zH4Pu7DEP+N/aiOE4L+6JE5eQ3rn4tUC6cUyuc42k6ERBHMfNHCAIIfFgsdoeXS7CNLa4ZMJ0lK/GuQ4iwL8rI55eUTz4gn11wc1okMKyUcBsFzOYhQbjB32yYzTds4w1BGOILQeAKwqSxOGZvvYrYPi6xy3Wk6zuUaxVZuqNaauCZJv2JhTkcoOom5khgDAVdy8YaCwxhoJs9rARHBnFCODC2zK054kpG+qvK9R9XlD9UqL6vsNT7NEWHjqnT6HW5M/q0DY1m/x5V11CNPi1d4942aZh3xHGUXDmGKET8/pZaJov03T7yQYZGJovf6xESE2w81kGAJWZYbtKZwHQE89WCMApY+Wtm8+CTKTsVxd9Fqvk8lVwOJX/EbT6P1+t/kphwA/461T2NONq5HUWwCWC9fjIlfnJZFC9Qjgtc/fwLlaNj6kfHTFoG42lEt+PQbA4olTp0uwNubzVMc5ISjkYrLi9vGI/n/z2bOIoYvXtL6+CA+v4+ajZL502GhaqxDmHozpCkKo1GG13v0Ww2UNUWy9UixWLxI7PZdEeYDGG4xVY79JQ6bUmhV01QZjmepJsMQ8e0zLTWdQNJKqe/5XE05GH6gOu6rDxvR9hqDxm7gr52T7vdon6jUKvJKLUq0nWJ0sc/Ofwpy+GPGd6d5Mi9ecXrr5/z/Tcv+eHFc1599SXffvGMl59/xvvDA/4Br3Bn0n0sxVkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/da1e41f06c9203707421d30c09cc51a1/37523/4.png\"\n        srcset=\"/static/da1e41f06c9203707421d30c09cc51a1/e9ff0/4.png 180w,\n/static/da1e41f06c9203707421d30c09cc51a1/f21e7/4.png 360w,\n/static/da1e41f06c9203707421d30c09cc51a1/37523/4.png 720w,\n/static/da1e41f06c9203707421d30c09cc51a1/bf433/4.png 971w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 그림처럼 프로세스의 메모리주소를 <strong>같은 크기의 페이지</strong>로 나누고 물리 메모리의 <strong>프레임</strong>과 대응시킨다.</p>\n<p>이 대응이라는 것은 논리주소를 단순히 구성할 순 없고, 일반적으로 <code class=\"language-text\">2^m</code>바이트의 논리 메모리 사이즈와 페이지 사이즈가 <code class=\"language-text\">2^n</code>바이트일때, 아래와 같이 m 비트를 (m-n)비트,n비트로 구성한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABp0lEQVQoz12Si27aQBBF+f9/qlqhlNKC38bGdngZCiYBigs23vWuT2RHKCEjrbQzo3vn7KMnRMXhmNMfJoytOX+sJbafMhwneN4E27YxLRvX9RgbJo5lYzkextjEGBlYlo1hWKzSNdfrlR6A0g00kkbXaC3RSiJlhdaKpmm6pZSiqkS311ojZd1Ku7xWinv0LpecTVYycArMsGDklziR4OVYEU0DbMvB9yZM/IAwnHakYRDiOi5xnBBFcdf3/YD1evNOmOdn4mTGcrlit91heT5D0+TXaIQdBDiez3QaMV3McYIQ0/UYjsZYptUNcGyX/JzjeR69FvlrbLwJSf+JbRgR/+gzN+1uUPjtO7PhbxY/BwRPA9I0JUkS4jj+OPL9Hu7Gsq6RWUqznqGOO+r1DPn6l+J6ol4l1NslKkvRp+wB4u7R+1xo43Yruek9ggPi3zOCV6pmT1GskJwQlwWi3lKqHeXt2mnaR7rrHw0b0DSI/Ix8yZCnA3L2jNhniEYh/5+RqwXyeEAo2f2CzzAPhg+NuoaihPIG57zFfq9LCcfTR/7FrDV8A2k+pWerzZ9qAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/a4841b9d90ed38f138412d95f98dc2ee/6af66/5.png\"\n        srcset=\"/static/a4841b9d90ed38f138412d95f98dc2ee/e9ff0/5.png 180w,\n/static/a4841b9d90ed38f138412d95f98dc2ee/f21e7/5.png 360w,\n/static/a4841b9d90ed38f138412d95f98dc2ee/6af66/5.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>페이지 오프셋은 <code class=\"language-text\">2^n</code>바이트의 페이지 중에서 현재 몇번째 바이트를 지시하는지 알려주고, m-n비트의 페이지 넘버는 페이지 테이블 내에서 몇번째 프레임을 가리키는데 사용된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABxklEQVQ4y5VT23KbMBD1/39QOn1qp2ndJ2dMihMC2CBwQmKwwUjczOV0dhMxEPelO3NG0kp7OHthMQwD/hdkTdOgrmtem7oZ/Qva9H3P+Lyfnqcgv1IKVVUxYZ7nvF4RErRNg7VNVV4ul9FPSsuyfCf8eDk+PB6P46Umjg8HFKpA13Vo25ZRFAWTkq9QavzAgqRbTzaECNix3W7hOi6nQYjjGKZpQkqJ0+nEqaZpynd91zEhpUsrE2ZZhm/fb7G6W8P3BdbGPeI4YWUUuFrdYbN5QFkUrIoIlZS810aKR0IpFczNAzxfsIr9fo/dbocoimDbNgzDgOM4fEcfoHKQOiLuPhTq1GdN0cUduhZhkuFWpHAPZ1SFGmtHqVEwgRTqM8VpjhlhWVVwrEfYzzG++jn+vKSolMR5Mha623TWUzBLeUqYnc8Q3g7e2wk39gH3+wQYevhCwLIseJ7HpSCjGfxnDWcKVQlcWsRVjxsvh3V8L7xUilNcLpcMCqY0acSo81cpkyUqw4+nFX67BlKpYAWviJIUU6OGEIGOCcMQQRDM3iz0QKu6xE93jS+bX3h82cJ/FTBDG/abgPnswoq8kej6r+pG/AVx1esFOXKkYwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/786432a0051aae7f662255f805a5729f/37523/6.png\"\n        srcset=\"/static/786432a0051aae7f662255f805a5729f/e9ff0/6.png 180w,\n/static/786432a0051aae7f662255f805a5729f/f21e7/6.png 360w,\n/static/786432a0051aae7f662255f805a5729f/37523/6.png 720w,\n/static/786432a0051aae7f662255f805a5729f/7de01/6.png 794w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이러한 페이징 방식에서 논리주소 변환은 위의 구조를 가진다.<br>\n잘보면 offset인 d는 주소 변환에는 안쓰이고 바로 물리주소에 대응시켜버린다.<br>\n반대로 p인 페이지 넘버는 page table내부에서 frame number와 매치시키기 위해서 사용되는데 p→f 의 역할을 하드웨어의 지원을 받아서 수행된다.</p>\n<h3 id=\"페이지-테이블\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94\" aria-label=\"페이지 테이블 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 테이블</h3>\n<p>페이지 번호와 프레임 넘버를 매치시켜주는 구조를 페이지 테이블(Page Table)이라고 하는데 , <strong>메모리 안에 저장된다.</strong></p>\n<p>그렇기때문에 실제로 어떠한 메모리에 접근할때는 <strong>두 번의 메모리 접근</strong>이 필요하다.</p>\n<ol>\n<li>메모리에 있는 페이지 테이블 접근</li>\n<li>변환된 물리적 주소에 가서 메모리 접근</li>\n</ol>\n<p>이 메모리 접근은 꽤 비용이 큰 작업이기 때문에 <strong>TLB</strong>라는 새로운 하드웨어 캐시가 쓰인다.</p>\n<h3 id=\"tlb\" style=\"position:relative;\"><a href=\"#tlb\" aria-label=\"tlb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TLB</h3>\n<p>TLB는 Associative Memory라고도 불리는 하드웨어 캐시인데, 논리주소를 물리주소로 변환할때 메모리접근을 줄이기 위해서 사용된다.</p>\n<p>페이지테이블과 유사하게 페이지 번호와 프레임 번호가 대응되게 기록되어 있다.<br>\n다만, <strong>모든 페이지 번호가 TLB 안에 있는 것은 아니다.</strong></p>\n<p>물론 이 레코드들을 다 순차적으로 읽는것은 아니고, <strong>하드웨어의 지원을 받아 병렬적으로 읽기 때문에 매우 빠르다.</strong></p>\n<blockquote>\n<p>이에 관해서 좋은 답변이 있어서 공유한다. <a href=\"https://cs.stackexchange.com/questions/119744/%3Ehow-does-a-tlb-lookup-compare-all-keys-simultaneously\">How does a TLB lookup compare all keys simultaneously?</a></p>\n</blockquote>\n<blockquote>\n<p>요악하자면 단일 CPU 안에서라도 파이프라이닝 기법을 이용해서 병렬적으로 읽는다는 것. (컴퓨터구조 수업을 참고하자.)</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 435px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkklEQVQoz1WPbW/aQBCE+f//ox/7oaqiNgoRtCppJdoSB0KTKA5gbIhxjH1+u/PZvieyY0V0pdFqd3ZHMwP6MsZwWvbKYzJdcGe7aF3TNFCWFVVtsNce1tLG+rfiKLL//ganYlVdk2YReRGTZkeCo0+chN0s0pBjdCCXb1w7t8iKmKyIyIq00xlgzLugVIpIrFHSoZAOqtwi1RvSfE0snpDltuO6fXtXOEi5JhK7zv0A0zps3gVF7qIJUMZHNc+oak+pd+SFQ5Ks0NpDtaj3qMZHcUDjI1Kfqm76yH1+qUuS0EY/TVFbC7X5i1p8p7TGFL+HpL++Ul6PUC2Wk/5mhnb+EIt97/BiiLm4hC/n6PmC7NMHpDVCbmYo7wbpL5GxTZasiCMblW8owgfk820nKNcz5NUZ2eePNFXNgDTFRBEkKTJJSBwLfT+hmY/h7gdmPkJfX1JMz0mvztCzYQduv3V8dTOmfPyJ8B56hyeRy6rCj3eEiceLcAlit+uhcDkEK/b7R8LI6Xan/EviEoiAujG8AsZxWzbwNLfIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/1cce148d06dadcc98f64f766b8f297d8/330eb/7.png\"\n        srcset=\"/static/1cce148d06dadcc98f64f766b8f297d8/e9ff0/7.png 180w,\n/static/1cce148d06dadcc98f64f766b8f297d8/f21e7/7.png 360w,\n/static/1cce148d06dadcc98f64f766b8f297d8/330eb/7.png 435w\"\n        sizes=\"(max-width: 435px) 100vw, 435px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>TLB가 도입되면서 (p,d)의 논리주소를 물리적 주소로 변환하는 방법이 변했다.</p>\n<ol>\n<li><strong>TLB를 먼저 확인</strong>해서 p에 해당하는 프레임 번호가 있는지 찾는다.\n<ol>\n<li>있다면, <strong>프레임 넘버 f와 오프셋 d를 가지고 바로 메모리에 접근한다.</strong></li>\n<li>없다면 2번으로 간다.</li>\n</ol>\n</li>\n<li><strong>메모리</strong>에 있는 <strong>페이지 테이블을 확인</strong>한다.</li>\n<li>페이지 테이블에 적힌 <strong>프레임 넘버 f와 오프셋 d를 가지고 메모리에 접근한다.</strong></li>\n<li><strong>가장 최근에 사용된 (p,d)→(f,d) 를 TLB에 저장한다.</strong></li>\n</ol>\n<p>1,4번 때문에 TLB는 논리적→물리적 주소 변환에서 <strong>캐시 역할</strong>을 수행한다고 볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 672px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.44444444444443%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACbElEQVQ4y42Ui27aMBSG+/4vs6nbpKpq1fVCS6eNNgmES4FCIEAuQBJCSGKSb7KhbF1baZaOnIv1neP/P/ZRHMf48zlRFLFYLJhOphRFwXa7RQjxbsh/ZVmq+Hcc9fp9riu31BsmZsOkVnvg6alLEAQqyXsx9+cqqQSmWU6SpirSPN8BT8/OedB02p0Ov2o19HqdPBcqY/FOFWEYqiqhRBv5XI5WXI1jHu0lR2PbpmE26T8PVHZn5pAma567T6zCQM0izw4yyKrCIEBIYFmgT5bcOIKKu0VzYo7kArlYjmSzod1q8bPZ5bvW5s7sq9n2l68qlHK86KeAs4yKI9Bnq9fANE25q9xwUmtx0vU51gZ8a7s0rBl2q8lkMEBiVlGkth0FSx5Hc26cXAG1t8AMQ9P4cm9w3Bjzudblkz7EeLZJnSnL6RTbnmBZFoZRp9NsUht6VD4CbtIUezymava4ao04rTW5bI2wvN2WkyyjWr2nen/P0LKIo5AfvYmCvQtcr9ckSaKey61gFYYH3eS7dFX2qjRHuS9Nsfcauh8AZah22X+LViuMkYc2jRgvVkq//wYme6AoSjKxaxHX8zhvT/ja8Wm5EXEYIMQfoHFwOX/r8mazwXddxo06lq6RbTZ4nsdZY8hpb45uOYTLhVr/ApTNfOVsufYKHv4GvoTIc5qaRkvXqBsG09mM657Dt7ZD3fYpRa5gqoiyZOAGPNoLFX0vfA2UI16vua1WOb+4wDRN1knC3Sjg3Irp+LGqqijKw1kuhKDTNDF1HZFlb4FSw7nv47ru/rxCZ2jz2HlmNHUOhingfutC3Uw7zX8DMRps0mGweUoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/933f463afc5e7f327eec24db9e5f669c/30d16/8.png\"\n        srcset=\"/static/933f463afc5e7f327eec24db9e5f669c/e9ff0/8.png 180w,\n/static/933f463afc5e7f327eec24db9e5f669c/f21e7/8.png 360w,\n/static/933f463afc5e7f327eec24db9e5f669c/30d16/8.png 672w\"\n        sizes=\"(max-width: 672px) 100vw, 672px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>💡 다만 일반적인 CPU 캐시(L1,L2…)와는 목적 자체가 다르다. TLB는 주소 변환 속도 향상을 위한것이어서 MMU에 의한 주소변환시에 생기고 , CPU 캐시는 데이터를 가져올때 메인 메모리 접근을 줄이기 위하여 메인 메모리 접근시점에 참조된다.\n물론 둘 다 메인 메모리 접근을 줄이기 위함이라는 점은 비슷하다.</p>\n</blockquote>\n<blockquote>\n<p>A cache stores a memory location temporarily while a TLB is like a cache that stores address translation (virtual to physical address)</p>\n</blockquote>\n<p><strong>단 이 TLB도 컨텍스트 스위칭이 일어날때 비워진다.</strong></p>\n<p>그 이유는 새로운 프로세스가 CPU를 할당받게 되면, 다른 메모리 주소공간을 참조할것이기 때문이다.<br>\n이때문에 컨텍스트 스위칭 직후 TLB 미스가 연속적으로 생긴다.</p>\n<h3 id=\"페이지-사이즈\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%82%AC%EC%9D%B4%EC%A6%88\" aria-label=\"페이지 사이즈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 사이즈</h3>\n<p>페이지의 크기에 대해서도 얘기해보자.<br>\n페이지의 크기를 정하면, 페이지 테이블의 크기도 결정되므로 적절한 페이지 크기 선정이 중요하다.</p>\n<p>여기서 말하는 <strong>적절한</strong>의 기준이 뭘까?</p>\n<blockquote>\n<p>만약 모든 프로세스가 4K만 요구하는데 페이지 사이즈가 8K면?</p>\n</blockquote>\n<blockquote>\n<p>모든 페이지에 4K만큼의 내부 파편화가 생기는 것이다.</p>\n</blockquote>\n<ul>\n<li>만약 페이지 사이즈가 크다면?\n<ul>\n<li>페이지 테이블의 크기는 줄어든다.</li>\n<li>한 개의 페이지 테이블안에 들어있는 데이터가 많으니 <strong>공간 지역성</strong>을 잘 만족한다.</li>\n<li>한 번에 많은 양의 데이터를 디스크에서 가져오니 <strong>I/O 작업이 줄어든다.</strong></li>\n<li><strong>내부 파편화</strong> 문제가 증가한다.</li>\n<li>필요하지 않은 데이터가 메모리에 올라올 수 있다.</li>\n</ul>\n</li>\n<li>만약 페이지 사이즈를 작다면?\n<ul>\n<li>내부 파편화 문제가 감소한다.</li>\n<li>필요한 데이터만 메모리에 가져올 수 있다.</li>\n<li><strong>공간 지역성</strong>을 지키기 어려워 페이지 폴트 발생 확률이 늘어난다.</li>\n<li>페이지 테이블 내의 엔트리가 많아지니 페이지 테이블의 크기가 커진다. <strong>오버헤드가 발생한다.</strong></li>\n</ul>\n</li>\n</ul>\n<p>따라서 여러가지 트레이드 오프를 고려해서 페이지의 크기를 정하는 것이 중요한데,<br>\n일반적으로 메모리 크기도 커지고, 프로세스 크기도 커져서 페이지 사이즈의 크기도 커지고 있다.</p>\n<p>리눅스 16.04 기준 아래와 같은 명령어로 페이지 사이즈를 알 수 있는데 4096으로 4K다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">$ getconf PAGESIZE\n<span class=\"token operator\">></span> <span class=\"token number\">4096</span></code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#mmu\">MMU</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%97%B0%EC%86%8D%EC%A0%81%EC%9D%B8-%ED%95%A0%EB%8B%B9contiguous-allocation\">연속적인 할당(Contiguous Allocation)</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8C%8C%ED%8E%B8%ED%99%94-fragmentation\">파편화 (Fragmentation)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-segmentation\">세그멘테이션 (Segmentation)</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-paging\">페이징 (Paging)</a></p>\n<ul>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94\">페이지 테이블</a></li>\n<li><a href=\"#tlb\">TLB</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%82%AC%EC%9D%B4%EC%A6%88\">페이지 사이즈</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 17, 2022","title":"운영체제의 메모리 훔쳐보기 1편 - 페이징(Paging)","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/paging/"}},"prev":{"id":"0606884e-0e00-5db9-977f-c93b84fcca9a","html":"<p><a href=\"https://becomeweasel.me/paging/\">이전편 : 페이징</a></p>\n<h2 id=\"가상-메모리-virtual-memory\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-virtual-memory\" aria-label=\"가상 메모리 virtual memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 메모리 (Virtual Memory)</h2>\n<p>가상 메모리는 논리적 메모리와 물리 메모리를 분리시켜, <strong>프로세스 전체가 메모리내에 올라오지 않아도 실행가능하도록 하는 기법이다.</strong></p>\n<p>물론 프로그램이 실행되기 위해서는 메모리에 프로세스가 올라와야 하는것은 맞다. 하지만 특정 부분을 실행할때는 그 부분만 메모리 위에 올라와있어도 구동이 된다.</p>\n<p>그렇기 때문에 논리적 주소공간은 실제 물리적 주소공간보다 훨씬 커도 된다. 왜냐면, 어차피 일부만 실행할때 필요하니까..\n그럼 가장 핵심적인 기술은 프로세스를 실행할때, 필요한 메모리를 불러오고(<strong>swapped in</strong>) 필요하지 않은 부분은 내리는(<strong>swapped out</strong>) 과정이 필요하다.</p>\n<p>가상메모리는 <strong>요구 페이징(Demand Paging)</strong> 이라는 기술로 구현된다.</p>\n<p>특정 페이지에 대한 수요가 있을때, 즉 페이지에 대한 참조 요청이 들어왔을때 페이지를 메모리로 불러오는것이다.\n다시 말해서 기존의 방법과는 다르게 가상 메모리 방식을 취하면, 시작할때부터 아무 메모리도 올라와있지 않아도 되고 필요할때만 불러오는 방식이다.</p>\n<p>프로그램에서 사용되는 일부분만 메모리에 적재하는 가상 메모리를 통해서 아래와 같은것들이 가능하다.</p>\n<ul>\n<li>시스템 라이브러리가 여러 프로세스 사이에 공유가 가능하다.\n프로세스 입장에서는 자신의 주소공간에 라이브러리가 올라와있다고 생각하지만, 실제로 라이브러리가 들어 있는 물리 메모리는 하나로 모든 프로세스에 공유되는 방식이다.</li>\n<li><strong>프로세스가 만들어질때 훨씬 더 효율적이다.</strong> 왜냐면, 실제로 프로세스를 만들때 필요한 모든 메모리를 할당해주는것이 아니라 <strong>필요할때만</strong> 주기 때문에 <strong>훨씬 가볍고 효율적이다.</strong>\n<ul>\n<li>예를 들어서 <code class=\"language-text\">fork</code> 를 해서 프로세스를 생성한다고 해보자.\n이때 메모리를 직접 주는것이 아니라 <strong>기존의 메모리를 그대로 사용하게끔만 하고 프로세스는 이것을 독립적인 메모리 공간으로 인식한다.</strong></li>\n</ul>\n</li>\n<li><strong>실제 물리 메모리보다 더 큰 메모리를</strong> 요구하는 프로세스를 구동시킬 수 있다.</li>\n<li><strong>더 많은 프로세스가 구동이 가능하다.</strong></li>\n</ul>\n<h2 id=\"요구-페이징-demand-paging\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95-demand-paging\" aria-label=\"요구 페이징 demand paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요구 페이징 (Demand Paging)</h2>\n<p>페이지를 메모리에 올릴때 오직 그것이 필요할때만 수행하는것을 요구 페이징이라고 한다.\n이것을 Lazy Swapper이라고도 하는것같다.(그 페이지 필요할때까지 절대 페이지를 메모리에 올리지 않는다)</p>\n<ul>\n<li><strong>적은 I/O</strong> : 전체 코드내에서 접근 안되는 주소공간은 가져올 필요가 없으니.</li>\n<li><strong>적은 메모리 사용량</strong></li>\n<li><strong>빠른 응답</strong> : 모든 페이지가 올라와있을 필요가 없으니 시작이 빠르다.</li>\n<li><strong>더 많은 유저</strong> : ”<em>논리적 메모리 >> 물리적 메모리</em> ” 이니 더 많은 프로세스를 수용가능하다.</li>\n</ul>\n<p>만약에 특정 페이지가 필요하다고 하자. 그럼 그 페이지를 참조해야하는데, 아래와 같은 분기를 가지게 된다.</p>\n<ul>\n<li>페이지에 대한 잘못된 참조 → 에러</li>\n<li>메모리에 올라와있지 않음 → 데이터를 메모리에 적재함</li>\n</ul>\n<p>그럼 이 올라와있지 않거나 올라와 있는것을 어떻게 구분할까?<br>\n논리주소와 물리주소를 변환할때 쓰였던 페이지 테이블을 이용해 페이지 테이블의 엔트리에 <strong>valid-bit</strong>를 부착해서 구분한다.</p>\n<p>만약 valid-bit가</p>\n<ul>\n<li>True면\n<ul>\n<li>현재 그 메모리를 가져온다.</li>\n</ul>\n</li>\n<li>False면\n<ul>\n<li><strong>Page Fault 발생</strong></li>\n<li>Page fault에 대한 처리를 하는데 일반적으로 페이지에 해당하는 프레임을 찾아서 로드시킨다.</li>\n</ul>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACKElEQVQ4y22Ta0/bMBiF+///EB+mTZTBRppCoWLQAglN0lx7yYUQ5/5McZquoFl69dqy/ejo+HhU1zVlWVJVlaxuXtcVTdMc10VR9D0X3FlbZk5MWRQUcq+vgTFq25ZhDPMsy9hstvLQ6Wiqisk65trNoKmHW5/OjPjPME2L8fiSMAwlNNxt5bwuSyZWiOJ+UJUlflpgJQX+e05ZVT0wCAKpqCvP89B1Hcf1uPh5JSFpmvKwstlGCbQN04XO3YtB8C5Q7YTFJpXd2EQ98OzsjCgKmc1mqKpKEPgYhsn3H+fEcSxtuHh18eIPaGuUxYpbbY33njPfCLQgRjF26MEBaFoWpu3wounYnkdZ19i2w6/fCkmSSKOvNA9fAhtung3meg9UrJBbzebbg8FbEPZAd22xmt8T22vy7QaKHHNtM764kgo74PjV6xU2NdfGjqn7jpcIzp8d7lcu46WNPgDj/Q4cCwKPJvBBZHjBBkVRpX9lWaAuV/j7qPfwzzP3S10qvNR85gfgUeHw8O1JAIQQOLZNA9TZB+nDHWW4p6orFHPHjZdKhbeB4C0UTN30n4ed6UNx6N3LdxVFkQy4zGDbymBP1hGqlyGKEiMSOEkue1ZUn3N4hAKLxYLpdMrj4yOu67JcLtE0jSjco9qRzGFbnwa7PTI+BXsAdmEevlz3KF1G5TfMc5m5iZ/TNrVUP9Rwd/QVdvoVv65FlvG0WvNkuuRC9FYcYAPwL2VC3fsCCtw3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/e2212896f80472ad709b5b1b0057a2b1/37523/1.png\"\n        srcset=\"/static/e2212896f80472ad709b5b1b0057a2b1/e9ff0/1.png 180w,\n/static/e2212896f80472ad709b5b1b0057a2b1/f21e7/1.png 360w,\n/static/e2212896f80472ad709b5b1b0057a2b1/37523/1.png 720w,\n/static/e2212896f80472ad709b5b1b0057a2b1/8bd7c/1.png 845w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n위 그림을 보면 B,D,E,F,G,H는 valid-bit가 invalid로 되어있다.<br>\n만약 이때 B나 F와 같은 페이지를 참조하려 하면 <strong>Page Fault</strong>가 일어나는 것이다.</li>\n</ul>\n<p>그럼 <strong>페이지 폴트</strong> (Page Fault)가 뭘까?</p>\n<h2 id=\"페이지-폴트-page-fault\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8-page-fault\" aria-label=\"페이지 폴트 page fault permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 폴트 (Page Fault)</h2>\n<p>페이지 폴트는 valid-bit가 invalid 인 곳에 MMU가 접근을 할때 HW trap을 발생시키면서 생긴다.</p>\n<p>valid-bit가 invalid 하다는 것은 현재 메모리안에 내가 원하는 페이지가 존재하지 않음을 의미하므로,<br>\n원하는 페이지에 해당하는 프레임을 메모리로 가져온 후 프로그램이 계속 동작되게끔 해야한다.<br>\n이것을 페이지 폴트 핸들링이라고 한다.</p>\n<h3 id=\"페이지-폴트-핸들링\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81\" aria-label=\"페이지 폴트 핸들링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 폴트 핸들링</h3>\n<p>페이지 폴트는 결국에 인터럽트이기 때문에 ISR을 수행하는 처리과정을 거친다.</p>\n<p>아래는 프로세스가 특정한 페이지를 참조하려고 했을때의 과정에 Page Fault 핸들링하는 과정이 추가된것이다.</p>\n<ol>\n<li>프로세스가 <strong>논리주소</strong> (p,d) 를 가지고 메모리에 접근하려고 시도한다.</li>\n<li><strong>TLB를 먼저 확인</strong>해서 p에 해당하는 프레임 번호 f가 있는지 확인한다.\n<ol>\n<li><strong>TLB Hit</strong>,있다면 바로 메모리로 접근해서 (f,d)를 가져온다.</li>\n<li><strong>TLB Miss,</strong> 없으니 이제 페이지 테이블을 참조해야 한다.</li>\n</ol>\n</li>\n<li><strong>(p,d)를 가지고 페이지 테이블에 접근한다.</strong>\n<ol>\n<li>페이지 테이블에 p에 해당하는 f가 valid하면, 메모리에 접근해서 로드한다.\n<ul>\n<li>이때 <strong>TLB 엔트리도 갱신된다.</strong></li>\n</ul>\n</li>\n<li>만약 valid하지 않다면 현재 메모리에 올라와있지 않다는 것 → Page Fault</li>\n</ol>\n</li>\n<li>운영체제가 메모리 접근할때의 주소를 확인한다.\n<ol>\n<li>잘못된 접근인가? 그러면 중지시켜야 한다.</li>\n<li>아니라면 진행.</li>\n</ol>\n</li>\n<li>물리 메모리에서 적절히 빈공간을 찾는다.\n<ol>\n<li>만약 이때 없다면, <strong>적절하게 다른 프레임을 교체시켜야 한다.</strong> 이 교체의 방식이 매우 중요한데, 잘 골라야 다음에 replace가 일어날 확률을 줄인다.</li>\n</ol>\n</li>\n<li>저장소에서 매치되는 페이지를 프레임에 올린다.\n<ol>\n<li><strong>이때 프로세스는 <code class=\"language-text\">wait</code> 상태인데, 저장소 접근 자체가 I/O 이기 때문이다. 컨텍스트 스위칭 발생.</strong></li>\n<li>I/O가 끝나면, 페이지 테이블 엔트리가 업데이트 되고, valid-bit가 valid로 설정된다. 이때도 컨텍스트 스위칭 발생할것같다.</li>\n<li><strong>프로세스는 레디큐로 옮겨진다. 그리고 일반적으로 스케쥴링되는것처럼 기다려야 한다.</strong></li>\n</ol>\n</li>\n<li>CPU를 다시 할당받게 되면 페이지 폴트 트랩 처리가 끝난다.</li>\n<li>페이지 폴트를 촉발시켰던 명령어부터 다시 수행한다. (PC를 증가시키지 않기 때문에. 만약 PC 증가시키면 그 명령어는 강제로 건너띄는것이다.)</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 696px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAACpElEQVQ4y3VUi1LaUBTM//9FnbEfoKDQqlUjlJiENBiRRAgQ3i9FHkoCyXb26kWk0zOTIY9z9+zu3YuiqiqKxSJMw0A+n8P19RUMQ0floQxD16HfarAtE5l0CjfXlyg7NiyrCMf+g4eyg/L9He5KNjy3Al2/hYKdenl5wWg0wtPTE1ZhiLe3N8znc7RabZRKd/C8R0ynU8RxLPob9QZU9QbZTBZn5+dotVpQ+JHXZrPBYDBAr9dDvV5HEATiud1uYzabiZ4oisSQyWQCx3Fwlv2JnJrDj0wWB98OcHj4HUqSJODFGg6HqFQqAoiLCTIejwVzluxjaZqGX+eX4j4OYzi2g9PM6VdAgvi+j9fX1+1CSqYNUqb8rTfqSB2lsJgvkKwBy7CQPkl/eshGMqN/u2wIyCGr1eoLYLVWQyGvYTQcYdgbomTZSKXTUJbLJXiRFeVJwDAMxWL6R4ZywBawWoWW17CJ1nj0HmGZZHgCpdvtik3gDtFsLm42m3h+fhbe9ft9ASpZS+Cq7+N3roAkThA0gk9AgjFXtVpNSCaAYRhig/jMgZTLFKw3G0RCegL/3oGm5gR4J+jALtpI0UMyoUwpOWgG4pl5I2Mpk9/XcYxFrwsUVNSuLqAX9HfAVge2Zb8zlBLIgrI9zxPMyJCZJNBisRDvRuMx+o0GkskIFdfF5cUVojBCUA9g6iaOjo+hrNfrbWRYlEYfKZ3syZr3rlsRGXVdF9PZTATfcz0M+gMMegO0g7awRyEAi8CSLYG4MfKb8O9jMH85nCcoTmLs1xaQTbuA3CwJwggxj5TPiJG1X/OFJfRX7n6cJO9nWRq/e7R2K/z4o+BwAsoI7YLJd8r+GZUNu40Ekuzkidkv2auslvN/Qrt/L6LR6cA0TcH0f4OJ9RdOrgCAqwatNgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/2f4734fe442e726fab395b6a93b9a610/82158/2.png\"\n        srcset=\"/static/2f4734fe442e726fab395b6a93b9a610/e9ff0/2.png 180w,\n/static/2f4734fe442e726fab395b6a93b9a610/f21e7/2.png 360w,\n/static/2f4734fe442e726fab395b6a93b9a610/82158/2.png 696w\"\n        sizes=\"(max-width: 696px) 100vw, 696px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"쓰레싱-threshing\" style=\"position:relative;\"><a href=\"#%EC%93%B0%EB%A0%88%EC%8B%B1-threshing\" aria-label=\"쓰레싱 threshing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쓰레싱 (Threshing)</h2>\n<p>스레싱은 멀티프로그래밍 환경에서 페이지 폴트가 많이 일어나서 시스템이 아무런 작업도 하지 못하고 페이지를 메모리에서 가져오고 빼내는 과정만 반복해 CPU 이용률이 급격하게 떨어지는 현상이다.</p>\n<p>더 최악인 점은 CPU 이용률이 떨어지니, 레디큐에 프로세스를 올리는 Long-term scheduler가 판단하기를\n”CPU 이용률을 높이기 위해 멀티프로그래밍 정도를 올려야 함”이라고 판단하고 레디큐에 더 많은 프로세스를 올리면서 페이지폴트는 더 늘어간다.</p>\n<ul>\n<li>여기서 멀티프로그래밍 정도가 느는것과 페이지폴트가 무슨상관일까?\n<ul>\n<li>새로운 프로세스가 올라오면, Short-term scheduler가 새로운 프로세스에 CPU를 할당할 것이고, 이때는 initial page fault가 생기기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<p>결국 Swap-in,Swap-out만을 하느라 바쁘고, 프로세스는 Block 되며, CPU는 대부분의 상황에서 <strong>IDLE</strong> 상태다.</p>\n<blockquote>\n<p>I/O 작업만 하니까..</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABS0lEQVQoz2WRa2/iMBRE+/9/1fKpW22Xso7ygDSJHeK8gDQkYUEUOKvrqqXSjjS6liwfzfU83G43ROfzmbZtGceRYRj+8ygeR6ZpYrNpsbZgnRvn7aZ1DGE9fAIvlwvGGIqiYL1eO8vZiq3F5DmZ1mRZRmYKjO1RUYkfN2RFz4e+ASWFAOu6pqoql1ZAuYC1Jgl8Fr9fUIs/7i61B1TcszQjv/wdP55rDsf3O7BpGtI0dbMsS6Iowvd9wigiVIro6Set1timYdt1vLyOxMVEnA+Eac9i2fEc7O7A/X7/tarneSRJ4tJKmqZtCVcrat+jenpktww5ZIZTmnDabDm9w/V6ZZjOd6BIEiqlHFRSypSVS2sJggDfU+TxCms0HP9yOx2FxHc5oFj+azabMZ/P3eM4jtE6I00Tl1Zareqaru/p3t64ftXw0e6n/wF+nwqm/nfotAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/fcbecb569fce34f2614a5907b36464b2/37523/thresing.png\"\n        srcset=\"/static/fcbecb569fce34f2614a5907b36464b2/e9ff0/thresing.png 180w,\n/static/fcbecb569fce34f2614a5907b36464b2/f21e7/thresing.png 360w,\n/static/fcbecb569fce34f2614a5907b36464b2/37523/thresing.png 720w,\n/static/fcbecb569fce34f2614a5907b36464b2/6029f/thresing.png 906w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 그림처럼 MPD를 계속 올리다보니 스레싱이 발생하고, 그러면 더 MPD를 올리게되고 페이지폴트는 더 자주일어나면서 CPU 이용률은 급감한다.</p>\n<p>결국에 자주 접근되는 페이지가 메모리에 올라와있지 않으면 이런 많은 페이지 폴트가 생기는데,<br>\n그렇기 때문에 각 프로세스가 필요로 하는 <strong>최소 프레임의 개수만큼은 보장</strong>을 해주어야 한다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-virtual-memory\">가상 메모리 (Virtual Memory)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95-demand-paging\">요구 페이징 (Demand Paging)</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8-page-fault\">페이지 폴트 (Page Fault)</a></p>\n<ul>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81\">페이지 폴트 핸들링</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%93%B0%EB%A0%88%EC%8B%B1-threshing\">쓰레싱 (Threshing)</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 28, 2022","title":"운영체제의 메모리 훔쳐보기 2편 - 가상 메모리(Virtual Memory)","categories":"운영체제","author":"weasel","emoji":"📓"},"fields":{"slug":"/virtual-memory/"}},"site":{"siteMetadata":{"siteUrl":"https://becomeweasel.me","comments":{"utterances":{"repo":"BecomeWeasel/BecomeWeasel.github.io"}}}}},"pageContext":{"slug":"/array-and-linked-list/","nextSlug":"/paging/","prevSlug":"/virtual-memory/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}